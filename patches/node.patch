Only in nw/node: .git
Only in up/node: .github
diff -r -u --color up/node/common.gypi nw/node/common.gypi
--- up/node/common.gypi	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/common.gypi	2024-08-26 19:33:02.430596109 +0000
@@ -6,22 +6,31 @@
     'visibility%': 'hidden',          # V8's visibility setting
     'target_arch%': 'ia32',           # set v8's target architecture
     'host_arch%': 'ia32',             # set v8's host architecture
-    'want_separate_host_toolset%': 0, # V8 should not build target and host
+    'want_separate_host_toolset%': 1, # V8 should not build target and host
     'library%': 'static_library',     # allow override to 'shared_library' for DLL/.so builds
     'component%': 'static_library',   # NB. these names match with what V8 expects
     'msvs_multi_core_compile': '0',   # we do enable multicore compiles, but not using the V8 way
     'enable_pgo_generate%': '0',
     'enable_pgo_use%': '0',
-    'python%': 'python',
+    'python%': 'python3',
 
-    'node_shared%': 'false',
+    'node_shared%': 'true',
     'force_dynamic_crt%': 0,
     'node_use_v8_platform%': 'true',
     'node_use_bundled_v8%': 'true',
+    'node_debug_lib': 'false',
+    'node_shared_libuv': 'false',
     'node_module_version%': '',
     'node_with_ltcg%': '',
     'node_shared_openssl%': 'false',
 
+    'build_v8_with_gn': 'false',
+    'openssl_no_asm': 1,
+    'mac_product_name': 'nwjs',
+    'enable_lto': 'false',
+    'v8_enable_pointer_compression': 0,
+    'v8_enable_31bit_smis_on_64bit_arch': 0,
+
     'node_tag%': '',
     'uv_library%': 'static_library',
 
@@ -29,7 +38,10 @@
     'error_on_warn%': 'false',
 
     'openssl_product': '<(STATIC_LIB_PREFIX)openssl<(STATIC_LIB_SUFFIX)',
-    'openssl_no_asm%': 0,
+    'openssl_fips': '',
+    'node_fipsinstall': 'false',
+    'experimental_quic': 0,
+    'llvm_version': '6.0',
 
     # Don't use ICU data file (icudtl.dat) from V8, we use our own.
     'icu_use_data_file_flag%': 0,
@@ -69,6 +81,11 @@
     # Disable v8 hugepage by default.
     'v8_enable_hugepage%': 0,
 
+    'v8_use_external_startup_data': 1,
+    'v8_enable_i18n_support%': 1,
+    #'icu_use_data_file_flag%': 1,
+    'win_fastlink': 0,
+
     # This is more of a V8 dev setting
     # https://github.com/nodejs/node/pull/22920/files#r222779926
     'v8_enable_fast_mksnapshot': 0,
@@ -87,27 +104,46 @@
     'tsan%': 0,
 
     ##### end V8 defaults #####
+    'variables': {
+      'building_nw%' : 0,
+    },
+    'building_nw%' : '<(building_nw)',
 
     'conditions': [
       ['OS == "win"', {
         'os_posix': 0,
         'v8_postmortem_support%': 0,
         'obj_dir': '<(PRODUCT_DIR)/obj',
-        'v8_base': '<(PRODUCT_DIR)/lib/libv8_snapshot.a',
+        #'v8_base': '<(PRODUCT_DIR)/lib/libv8_snapshot.a',
+        'clang_dir': 'third_party/llvm-build/Release+Asserts/',
       }, {
         'os_posix': 1,
         'v8_postmortem_support%': 1,
+        'clang_dir': '<!(cd <(DEPTH) && pwd -P)/third_party/llvm-build/Release+Asserts',
       }],
       ['GENERATOR == "ninja"', {
         'obj_dir': '<(PRODUCT_DIR)/obj',
-        'v8_base': '<(PRODUCT_DIR)/obj/tools/v8_gypfiles/libv8_snapshot.a',
+        #'v8_base': '<(PRODUCT_DIR)/obj/tools/v8_gypfiles/libv8_snapshot.a',
       }, {
         'obj_dir%': '<(PRODUCT_DIR)/obj.target',
-        'v8_base': '<(PRODUCT_DIR)/obj.target/tools/v8_gypfiles/libv8_snapshot.a',
+        #'v8_base': '<(PRODUCT_DIR)/obj.target/tools/v8_gypfiles/libv8_snapshot.a',
+      }],
+      ['target_arch=="x64" or target_arch=="arm64"', {
+        'v8_enable_pointer_compression': 1,
+        'v8_enable_31bit_smis_on_64bit_arch': 1,
+      }],
+      ['OS=="linux" and target_arch=="ia32" and <(building_nw)==1', {
+        'sysroot': '<!(cd <(DEPTH) && pwd -P)/build/linux/debian_sid_i386-sysroot',
+      }],
+      ['OS=="linux" and target_arch=="x64" and <(building_nw)==1', {
+        'sysroot': '<!(cd <(DEPTH) && pwd -P)/build/linux/debian_sid_amd64-sysroot',
+      }],
+      ['OS=="linux" and target_arch=="arm" and <(building_nw)==1', {
+        'sysroot': '<!(cd <(DEPTH) && pwd -P)/build/linux/debian_sid_arm-sysroot',
       }],
       ['OS=="mac"', {
         'obj_dir%': '<(PRODUCT_DIR)/obj.target',
-        'v8_base': '<(PRODUCT_DIR)/libv8_snapshot.a',
+        #'v8_base': '<(PRODUCT_DIR)/libv8_snapshot.a',
       }],
       # V8 pointer compression only supports 64bit architectures.
       ['target_arch in "arm ia32 mips mipsel ppc"', {
@@ -127,10 +163,132 @@
     ],
   },
 
+  'conditions': [
+      [ 'clang==1 and OS == "linux" and building_nw==1', {
+        'make_global_settings': [
+          ['CC', '<(clang_dir)/bin/clang'],
+          ['CXX', '<(clang_dir)/bin/clang++'],
+          ['CC.host', '$(CC)'],
+          ['CXX.host', '$(CXX)'],
+        ],
+      }],
+      [ 'clang==1 and OS == "win" and building_nw==1', {
+        'make_global_settings': [
+          ['CC', 'third_party/llvm-build/Release+Asserts/bin/clang-cl'],
+          ['CXX', 'third_party/llvm-build/Release+Asserts/bin/clang-cl'],
+          ['CC.host', '$(CC)'],
+          ['CXX.host', '$(CXX)'],
+        ],
+      }],
+      [ 'OS == "win" and building_nw==1', {
+        'make_global_settings': [
+          ['LD', 'third_party/llvm-build/Release+Asserts/bin/lld-link.exe'],
+        ],
+      }],
+  ],
   'target_defaults': {
     'default_configuration': 'Release',
+    'variables': {
+      'conditions': [
+        ['OS=="win" and component=="shared_library"', {
+          # See http://msdn.microsoft.com/en-us/library/aa652367.aspx
+          'win_release_RuntimeLibrary%': '2', # 2 = /MD (nondebug DLL)
+          'win_debug_RuntimeLibrary%': '3',   # 3 = /MDd (debug DLL)
+        }, {
+          # See http://msdn.microsoft.com/en-us/library/aa652367.aspx
+          'win_release_RuntimeLibrary%': '0', # 0 = /MT (nondebug static)
+          'win_debug_RuntimeLibrary%': '1',   # 1 = /MTd (debug static)
+        }],
+      ],
+    },
     'configurations': {
-      'Debug': {
+      'Common_Base': {
+        'abstract': 1,
+        'msvs_settings':{
+          'VCCLCompilerTool': {
+            'AdditionalOptions': [
+              '/bigobj',
+              # Tell the compiler to crash on failures. This is undocumented
+              # and unsupported but very handy.
+              '/d2FastFail',
+            ],
+          },
+          'VCLinkerTool': {
+            # Add the default import libs.
+            'AdditionalDependencies': [
+              'kernel32.lib',
+              'gdi32.lib',
+              'winspool.lib',
+              'comdlg32.lib',
+              'advapi32.lib',
+              'shell32.lib',
+              'ole32.lib',
+              'oleaut32.lib',
+              'user32.lib',
+              'uuid.lib',
+              'odbc32.lib',
+              'odbccp32.lib',
+              'delayimp.lib',
+              'credui.lib',
+              'dbghelp.lib',
+              'shlwapi.lib',
+              'winmm.lib',
+              #'msvcprt.lib',
+            ],
+            'AdditionalOptions': [
+              # Suggested by Microsoft Devrel to avoid
+              #   LINK : fatal error LNK1248: image size (80000000) exceeds maximum allowable size (80000000)
+              # which started happening more regularly after VS2013 Update 4.
+              # Needs to be a bit lower for VS2015, or else errors out.
+              '/maxilksize:0x7ff00000',
+              # Tell the linker to crash on failures.
+              '/fastfail',
+            ],
+          },
+        },
+        'conditions': [
+          ['OS=="win" and win_fastlink==1 and MSVS_VERSION != "2013"', {
+            'msvs_settings': {
+              'VCLinkerTool': {
+                # /PROFILE is incompatible with /debug:fastlink
+                'Profile': 'false',
+                'AdditionalOptions': [
+                  # Tell VS 2015+ to create a PDB that references debug
+                  # information in .obj and .lib files instead of copying
+                  # it all.
+                  '/DEBUG:FASTLINK',
+                ],
+              },
+            },
+          }],
+          ['OS=="win"', {
+            'msvs_settings': {
+              'VCCLCompilerTool': {
+                'AdditionalOptions': [
+                  '/Zc:dllexportInlines-',
+		  '/std:c++20',
+                ],
+              },
+            },
+          }],
+          ['OS=="win" and MSVS_VERSION == "2015"', {
+            'msvs_settings': {
+              'VCCLCompilerTool': {
+                'AdditionalOptions': [
+                  # Work around crbug.com/526851, bug in VS 2015 RTM compiler.
+                  '/Zc:sizedDealloc-',
+                  # Disable thread-safe statics to avoid overhead and because
+                  # they are disabled on other platforms. See crbug.com/587210
+                  # and -fno-threadsafe-statics.
+                  '/Zc:threadSafeInit-',
+                ],
+              },
+            },
+          }],
+        ],
+      },
+      'Debug_Base': {
+        'abstract': 1,
         'variables': {
           'v8_enable_handle_zapping': 1,
           'conditions': [
@@ -141,7 +299,7 @@
             }],
           ],
         },
-        'defines': [ 'DEBUG', '_DEBUG' ],
+        'defines': [ 'DEBUG', '_DEBUG', '_HAS_ITERATOR_DEBUGGING=0' ],
         'cflags': [ '-g', '-O0' ],
         'conditions': [
           ['OS in "aix os400"', {
@@ -158,11 +316,10 @@
         ],
         'msvs_settings': {
           'VCCLCompilerTool': {
-            'BasicRuntimeChecks': 3,        # /RTC1
+            'RuntimeLibrary': '<(win_debug_RuntimeLibrary)', # static debug
             'MinimalRebuild': 'false',
             'OmitFramePointers': 'false',
             'Optimization': 0,              # /Od, no optimization
-            'RuntimeLibrary': '<(MSVC_runtimeType)',
           },
           'VCLinkerTool': {
             'LinkIncremental': 2, # enable incremental linking
@@ -172,7 +329,8 @@
           'GCC_OPTIMIZATION_LEVEL': '0', # stop gyp from defaulting to -Os
         },
       },
-      'Release': {
+      'Release_Base': {
+        'abstract': 1,
         'variables': {
           'v8_enable_handle_zapping': 0,
           'pgo_generate': ' -fprofile-generate ',
@@ -260,32 +418,40 @@
             'InlineFunctionExpansion': 2,   # /Ob2, inline anything eligible
             'OmitFramePointers': 'true',
             'Optimization': 3,              # /Ox, full optimization
-            'RuntimeLibrary': '<(MSVC_runtimeType)',
+            'RuntimeLibrary': '<(win_release_RuntimeLibrary)',
             'RuntimeTypeInfo': 'false',
           }
         },
         'xcode_settings': {
           'GCC_OPTIMIZATION_LEVEL': '3', # stop gyp from defaulting to -Os
         },
-      }
+      },
+      'Debug': {
+        'inherit_from': ['Common_Base', 'Debug_Base'],
+      },
+      'Release': {
+        'inherit_from': ['Common_Base', 'Release_Base'],
+      },
+      'conditions': [
+        [ 'OS=="win"', {
+              'Debug_x64': { 'inherit_from': ['Debug'] },
+              'Release_x64': { 'inherit_from': ['Release'], },
+        }],
+      ],
     },
 
     # Defines these mostly for node-gyp to pickup.
     'defines': [
+      'V8_REVERSE_JSARGS',
       '_GLIBCXX_USE_CXX11_ABI=1',
+      '_LIBCPP_HAS_NO_VENDOR_AVAILABILITY_ANNOTATIONS',
+      '_LIBCPP_HARDENING_MODE=_LIBCPP_HARDENING_MODE_NONE',
     ],
 
     # Forcibly disable -Werror.  We support a wide range of compilers, it's
     # simply not feasible to squelch all warnings, never mind that the
     # libraries in deps/ are not under our control.
-    'conditions': [
-      [ 'error_on_warn=="false"', {
-        'cflags!': ['-Werror'],
-      }, '(_target_name!="<(node_lib_target_name)" or '
-          '_target_name!="<(node_core_target_name)")', {
-        'cflags!': ['-Werror'],
-      }],
-    ],
+
     'msvs_settings': {
       'VCCLCompilerTool': {
         # TODO(targos): Remove condition and always use LanguageStandard options
@@ -352,10 +518,16 @@
     #   drowns out other, more legitimate warnings.
     # - "C4244: conversion from 'type1' to 'type2', possible loss of data"
     #   Ususaly safe. Disable for `dep`, enable for `src`
-    'msvs_disabled_warnings': [4351, 4355, 4800, 4251, 4275, 4244, 4267],
     'msvs_cygwin_shell': 0, # prevent actions from trying to use cygwin
 
+    'msvs_disabled_warnings': [4351, 4355, 4800, 4251, 4275, 4244, 4267, 4595],
     'conditions': [
+      [ 'error_on_warn=="false"', {
+        'cflags!': ['-Werror'],
+      }, '(_target_name!="<(node_lib_target_name)" or '
+          '_target_name!="<(node_core_target_name)")', {
+        'cflags!': ['-Werror'],
+      }],
       [ 'configuring_node', {
         'msvs_configuration_attributes': {
           'OutputDirectory': '<(DEPTH)/out/$(Configuration)/',
@@ -433,6 +605,9 @@
       ['v8_enable_pointer_compression == 1 and v8_enable_pointer_compression_shared_cage != 1', {
         'defines': ['V8_COMPRESS_POINTERS_IN_ISOLATE_CAGE'],
       }],
+      ['target_arch=="x64"', {
+        'defines': ['V8_VIRTUAL_MEMORY_CAGE'],
+      }],
       ['v8_enable_pointer_compression == 1 or v8_enable_31bit_smis_on_64bit_arch == 1', {
         'defines': ['V8_31BIT_SMIS_ON_64BIT_ARCH'],
       }],
@@ -473,14 +648,28 @@
           # POSIX names
           '_CRT_NONSTDC_NO_DEPRECATE',
           # Make sure the STL doesn't try to use exceptions
-          '_HAS_EXCEPTIONS=0',
-          'BUILDING_V8_SHARED=1',
+          '_HAS_EXCEPTIONS=1',
+          #'BUILDING_V8_SHARED=1',
           'BUILDING_UV_SHARED=1',
           # Stop <windows.h> from defining macros that conflict with
           # std::min() and std::max().  We don't use <windows.h> (much)
           # but we still inherit it from uv.h.
           'NOMINMAX',
         ],
+        'conditions': [
+          [ 'building_nw==1 and component=="shared_library"', {
+            'defines': [ '_LIBCPP_NO_AUTO_LINK' ],
+            'include_dirs': [ '<(DEPTH)/third_party/libc++/src/include',
+	                      '<(DEPTH)/buildtools/third_party/libc++/',
+			    ],
+          }],
+          [ 'building_nw==1 and component!="shared_library"', {
+            'defines': [ '_LIBCPP_DISABLE_VISIBILITY_ANNOTATIONS' ],
+            'include_dirs': [ #'<(DEPTH)/third_party/libc++/src/include',
+                              #'<(DEPTH)/third_party/libc++',
+                            ],
+          }],
+        ],
       }],
       [ 'OS in "linux freebsd openbsd solaris aix os400"', {
         'cflags': [ '-pthread' ],
@@ -488,7 +677,7 @@
       }],
       [ 'OS in "linux freebsd openbsd solaris android aix os400 cloudabi"', {
         'cflags': [ '-Wall', '-Wextra', '-Wno-unused-parameter', ],
-        'cflags_cc': [ '-fno-rtti', '-fno-exceptions', '-std=gnu++17' ],
+        'cflags_cc': [ '-fno-rtti', '-fno-exceptions', '-std=c++20' ],
         'defines': [ '__STDC_FORMAT_MACROS' ],
         'ldflags': [ '-rdynamic' ],
         'target_conditions': [
@@ -502,6 +691,9 @@
           }],
           ['_toolset=="host"', {
             'conditions': [
+              ['clang==1 and OS=="linux"', {
+                'cflags': ['-I/usr/include/c++/13', '-I/usr/include/x86_64-linux-gnu/' ],
+              }],
               [ 'host_arch=="ia32"', {
                 'cflags': [ '-m32' ],
                 'ldflags': [ '-m32' ],
@@ -526,6 +718,18 @@
           }],
           ['_toolset=="target"', {
             'conditions': [
+              [ 'building_nw==1 and OS=="linux"', {
+                'cflags': [ '--sysroot=<(sysroot)', '-nostdinc++', 
+                        '-isystem<(PRODUCT_DIR)/../../third_party/libc++/src/include', 
+                        '-isystem<(PRODUCT_DIR)/../../third_party/libc++', 
+                        '-isystem<(PRODUCT_DIR)/../../buildtools/third_party/libc++', 
+                        '-isystem<(PRODUCT_DIR)/../../third_party/libc++abi/src/include' ],
+                'ldflags': [ '--sysroot=<(sysroot)','<!(<(DEPTH)/content/nw/tools/sysroot_ld_path.sh <(sysroot))', '-nostdlib++' ],
+              }],
+              ['clang==1', {
+                'cflags': ['-Wno-error=missing-declarations', '-Wno-error=array-bounds'],
+                'defines': [ '_LIBCPP_ABI_NAMESPACE=__1' ],
+              }],
               [ 'target_arch=="ia32"', {
                 'cflags': [ '-m32' ],
                 'ldflags': [ '-m32' ],
@@ -550,6 +754,10 @@
           }],
         ],
         'conditions': [
+          [ 'OS=="linux" and target_arch=="arm"', {
+            'cflags': [ '--target=arm-linux-gnueabihf' ],
+            'ldflags': [ '--target=arm-linux-gnueabihf' ],
+          }],
           [ 'OS=="solaris"', {
             'cflags': [ '-pthreads' ],
             'ldflags': [ '-pthreads' ],
@@ -656,7 +864,7 @@
           ['clang==1', {
             'xcode_settings': {
               'GCC_VERSION': 'com.apple.compilers.llvm.clang.1_0',
-              'CLANG_CXX_LANGUAGE_STANDARD': 'gnu++17',  # -std=gnu++17
+              'CLANG_CXX_LANGUAGE_STANDARD': 'gnu++20',  # -std=gnu++17
               'CLANG_CXX_LIBRARY': 'libc++',
             },
           }],
Only in nw/node: config.gypi
diff -r -u --color up/node/deps/ada/ada.gyp nw/node/deps/ada/ada.gyp
--- up/node/deps/ada/ada.gyp	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/deps/ada/ada.gyp	2024-08-26 19:33:02.438596106 +0000
@@ -2,6 +2,7 @@
   'variables': {
     'v8_enable_i18n_support%': 1,
     'ada_sources': [ 'ada.cpp' ],
+    'icu_gyp_path%': '../../../icu/icu.gyp',
   },
   'targets': [
     {
diff -r -u --color up/node/deps/cares/cares.gyp nw/node/deps/cares/cares.gyp
--- up/node/deps/cares/cares.gyp	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/deps/cares/cares.gyp	2024-08-26 19:33:02.454596102 +0000
@@ -117,6 +117,7 @@
       'src/lib/config-win32.h',
       'src/lib/windows_port.c',
     ],
+    'library%': 'static_library',
   },
 
   'target_defaults': {
@@ -177,6 +178,7 @@
             '_WINSOCK_DEPRECATED_NO_WARNINGS',
           ],
           'include_dirs': [ 'config/win32' ],
+          'msvs_disabled_warnings': [4133],
           'sources': [
             '<@(cares_sources_win)',
           ],
diff -r -u --color up/node/deps/cares/src/lib/ares_create_query.c nw/node/deps/cares/src/lib/ares_create_query.c
--- up/node/deps/cares/src/lib/ares_create_query.c	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/deps/cares/src/lib/ares_create_query.c	2024-08-26 19:33:02.474596095 +0000
@@ -25,6 +25,12 @@
  */
 
 #include "ares_setup.h"
+
+#ifndef _WIN32
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Warray-bounds"
+#endif
+
 #include "ares.h"
 #include "ares_private.h"
 
@@ -78,3 +84,7 @@
 {
   return ares_create_query_int(name, dnsclass, type, id, rd, buf, buflen, 0);
 }
+
+#ifndef _WIN32
+#pragma clang diagnostic pop
+#endif
diff -r -u --color up/node/deps/cares/src/lib/ares_process.c nw/node/deps/cares/src/lib/ares_process.c
--- up/node/deps/cares/src/lib/ares_process.c	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/deps/cares/src/lib/ares_process.c	2024-08-26 19:33:02.478596095 +0000
@@ -440,7 +440,7 @@
         fromlen = sizeof(from.sa6);
       }
       read_len = ares__socket_recvfrom(channel, conn->fd, (void *)buf,
-                                       sizeof(buf), 0, &from.sa, &fromlen);
+                                       sizeof(buf), 0, &from.sa, (socklen_t *)&fromlen);
     }
 
     if (read_len == 0) {
diff -r -u --color up/node/deps/nghttp2/lib/includes/nghttp2/nghttp2.h nw/node/deps/nghttp2/lib/includes/nghttp2/nghttp2.h
--- up/node/deps/nghttp2/lib/includes/nghttp2/nghttp2.h	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/deps/nghttp2/lib/includes/nghttp2/nghttp2.h	2024-08-26 19:33:02.646596047 +0000
@@ -36,6 +36,10 @@
 #  define __has_declspec_attribute(x) 0
 #endif
 
+#if defined(WIN32)
+#define ssize_t ptrdiff_t
+#endif
+
 #ifdef __cplusplus
 extern "C" {
 #endif
diff -r -u --color up/node/deps/nghttp2/nghttp2.gyp nw/node/deps/nghttp2/nghttp2.gyp
--- up/node/deps/nghttp2/nghttp2.gyp	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/deps/nghttp2/nghttp2.gyp	2024-08-26 19:33:02.650596046 +0000
@@ -56,7 +56,7 @@
             },
           },
         }],
-        ['debug_nghttp2 == 1', {
+        ['0 == 1', {
           'defines': [ 'DEBUGBUILD=1' ]
         }]
       ],
Only in up/node/deps: npm
diff -r -u --color up/node/deps/openssl/openssl/providers/implementations/rands/seeding/rand_unix.c nw/node/deps/openssl/openssl/providers/implementations/rands/seeding/rand_unix.c
--- up/node/deps/openssl/openssl/providers/implementations/rands/seeding/rand_unix.c	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/deps/openssl/openssl/providers/implementations/rands/seeding/rand_unix.c	2024-08-26 19:33:03.314595857 +0000
@@ -357,7 +357,7 @@
      * internally. So we need to check errno for ENOSYS
      */
 #  if !defined(__DragonFly__) && !defined(__NetBSD__)
-#    if defined(__GNUC__) && __GNUC__>=2 && defined(__ELF__) && !defined(__hpux)
+#    if 0 //defined(__GNUC__) && __GNUC__>=2 && defined(__ELF__) && !defined(__hpux)
     extern int getentropy(void *buffer, size_t length) __attribute__((weak));
 
     if (getentropy != NULL) {
diff -r -u --color up/node/deps/openssl/openssl.gyp nw/node/deps/openssl/openssl.gyp
--- up/node/deps/openssl/openssl.gyp	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/deps/openssl/openssl.gyp	2024-08-26 19:33:03.090595920 +0000
@@ -3,6 +3,10 @@
     'gas_version%': '0.0',
     'llvm_version%': '0.0',
     'nasm_version%': '0.0',
+    'openssl_no_asm%': 0,
+    'is_clang': 1,
+    'openssl_fips%': '',
+    'node_byteorder%': 'little',
     'openssl-cli': '<(PRODUCT_DIR)/<(EXECUTABLE_PREFIX)openssl-cli<(EXECUTABLE_SUFFIX)',
     'conditions': [
       ['OS == "win"', {
@@ -18,13 +22,14 @@
       ['OS=="mac"', {
         'obj_dir_abs%': '<(PRODUCT_DIR_ABS)/obj.target',
         'modules_dir': '<(PRODUCT_DIR_ABS)/obj.target/deps/openssl/lib/openssl-modules',
+        'openssl_no_asm%': 1
       }],
     ],
   },
   'targets': [
     {
       'target_name': 'openssl',
-      'type': '<(library)',
+      'type': 'static_library',
       'includes': ['./openssl_common.gypi'],
       'defines': [
         # Compile out hardware engines.  Most are stubs that dynamically load
@@ -84,35 +89,6 @@
           'ldflags': [ '-fno-lto' ],
         }],
      ]
-    }, {
-      # openssl-fipsmodule target
-      'target_name': 'openssl-fipsmodule',
-      'type': 'shared_library',
-      'dependencies': ['openssl-cli'],
-      'includes': ['./openssl_common.gypi'],
-      'include_dirs+': ['openssl/apps/include'],
-      'cflags': [ '-fPIC' ],
-      #'ldflags': [ '-o', 'fips.so' ],
-      #'ldflags': [ '-Wl,--version-script=providers/fips.ld',],
-      'conditions': [
-        [ 'openssl_no_asm==1', {
-          'includes': ['./openssl-fips_no_asm.gypi'],
-        }, 'target_arch=="arm64" and OS=="win"', {
-          # VC-WIN64-ARM inherits from VC-noCE-common that has no asms.
-          'includes': ['./openssl-fips_no_asm.gypi'],
-        }, 'gas_version and v(gas_version) >= v("2.26") or '
-           'nasm_version and v(nasm_version) >= v("2.11.8")', {
-           # Require AVX512IFMA supported. See
-           # https://www.openssl.org/docs/man1.1.1/man3/OPENSSL_ia32cap.html
-           # Currently crypto/poly1305/asm/poly1305-x86_64.pl requires AVX512IFMA.
-          'includes': ['./openssl-fips_asm.gypi'],
-        }, {
-          'includes': ['./openssl-fips_asm_avx2.gypi'],
-        }],
-     ],
-     'direct_dependent_settings': {
-       'include_dirs': [ 'openssl/include', 'openssl/crypto/include']
-     }
-   },
+    },
   ]
 }
diff -r -u --color up/node/deps/openssl/openssl_common.gypi nw/node/deps/openssl/openssl_common.gypi
--- up/node/deps/openssl/openssl_common.gypi	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/deps/openssl/openssl_common.gypi	2024-08-26 19:33:03.482595809 +0000
@@ -12,6 +12,8 @@
     'config/',
   ],
   # build options specific to OS
+  'cflags!': ['-fvisibility=hidden'],
+  'cflags_cc!': ['-fvisibility-inlines-hidden'],
   'conditions': [
     [ 'OS in ("aix", "os400")', {
       # AIX is missing /usr/include/endian.h
@@ -34,7 +36,7 @@
       'cflags': [
         '-W3', '-wd4090', '-Gs0', '-GF', '-Gy', '-nologo','/O2',
       ],
-      'msvs_disabled_warnings': [4090],
+      'msvs_disabled_warnings': [4090, 4311],
       'link_settings': {
         'libraries': [
           '-lws2_32.lib',
diff -r -u --color up/node/deps/simdjson/simdjson.h nw/node/deps/simdjson/simdjson.h
--- up/node/deps/simdjson/simdjson.h	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/deps/simdjson/simdjson.h	2024-08-26 19:33:03.506595801 +0000
@@ -6278,6 +6278,12 @@
   /** Prints one character **/
   simdjson_inline void one_char(char c);
 
+  simdjson_inline void print_newline();
+
+  simdjson_inline void print_indents(size_t depth);
+
+  simdjson_inline void print_space();
+
   simdjson_inline void call_print_newline() {
       this->print_newline();
   }
diff -r -u --color up/node/deps/uv/include/uv/errno.h nw/node/deps/uv/include/uv/errno.h
--- up/node/deps/uv/include/uv/errno.h	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/deps/uv/include/uv/errno.h	2024-08-26 19:33:03.534595794 +0000
@@ -460,7 +460,7 @@
  * if C++ is being used. Define it directly to avoid problems when integrating
  * libuv in a C++ project.
  */
-#if defined(ENODATA) && !defined(_WIN32)
+#if 0 //defined(ENODATA) && !defined(_WIN32)
 # define UV__ENODATA UV__ERR(ENODATA)
 #elif defined(__FreeBSD__)
 # define UV__ENODATA (-9919)
diff -r -u --color up/node/deps/uv/include/uv.h nw/node/deps/uv/include/uv.h
--- up/node/deps/uv/include/uv.h	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/deps/uv/include/uv.h	2024-08-26 19:33:03.534595794 +0000
@@ -33,6 +33,8 @@
 
 #ifndef UV_EXTERN
 #ifdef _WIN32
+#pragma warning(push)
+#pragma warning(disable: 4201)
   /* Windows - set up dll import/export decorators. */
 # if defined(BUILDING_UV_SHARED)
     /* Building shared library. */
@@ -286,6 +288,7 @@
                                    uv_free_func free_func);
 
 UV_EXTERN uv_loop_t* uv_default_loop(void);
+UV_EXTERN void uv_init_nw(int);
 UV_EXTERN int uv_loop_init(uv_loop_t* loop);
 UV_EXTERN int uv_loop_close(uv_loop_t* loop);
 /*
@@ -914,6 +917,9 @@
                             uv_async_t* async,
                             uv_async_cb async_cb);
 UV_EXTERN int uv_async_send(uv_async_t* async);
+#ifdef _WIN32
+UV_EXTERN int uv_async_send_nw(uv_async_t* async);
+#endif
 
 
 /*
@@ -1897,6 +1903,7 @@
   void* internal_fields;
   /* Internal flag to signal loop stop. */
   unsigned int stop_flag;
+  void* keventfunc;
   UV_LOOP_PRIVATE_FIELDS
 };
 
@@ -1936,6 +1943,10 @@
 #undef UV_LOOP_PRIVATE_PLATFORM_FIELDS
 #undef UV__ERR
 
+#ifdef _WIN32
+#pragma warning(pop)
+#endif
+
 #ifdef __cplusplus
 }
 #endif
diff -r -u --color up/node/deps/uv/src/unix/core.c nw/node/deps/uv/src/unix/core.c
--- up/node/deps/uv/src/unix/core.c	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/deps/uv/src/unix/core.c	2024-08-26 19:33:03.538595793 +0000
@@ -1876,9 +1876,11 @@
    * glibc it's... complicated... so for consistency try sched_getaffinity()
    * before falling back to sysconf(_SC_NPROCESSORS_ONLN).
    */
+#if defined(CPU_COUNT)
   if (0 == sched_getaffinity(0, sizeof(set), &set))
     rc = CPU_COUNT(&set);
   else
+#endif
     rc = sysconf(_SC_NPROCESSORS_ONLN);
 
   if (rc < 1)
diff -r -u --color up/node/deps/uv/src/unix/fs.c nw/node/deps/uv/src/unix/fs.c
--- up/node/deps/uv/src/unix/fs.c	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/deps/uv/src/unix/fs.c	2024-08-26 19:33:03.538595793 +0000
@@ -25,6 +25,8 @@
  * return -1 with errno set. The dispatcher in uv__fs_work() takes care of
  * getting the errno to the right place (req->result or as the return value.)
  */
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Warray-bounds"
 
 #include "uv.h"
 #include "internal.h"
@@ -293,15 +295,13 @@
   /* z/os doesn't have RTLD_DEFAULT but that's okay
    * because it doesn't have mkostemp(O_CLOEXEC) either.
    */
-#ifdef RTLD_DEFAULT
-  uv__mkostemp = (int (*)(char*, int)) dlsym(RTLD_DEFAULT, "mkostemp");
+  uv__mkostemp = (int (*)(char*, int)) dlsym(((void *) 0), "mkostemp");
 
   /* We don't care about errors, but we do want to clean them up.
    * If there has been no error, then dlerror() will just return
    * NULL.
    */
   dlerror();
-#endif  /* RTLD_DEFAULT */
 }
 
 
@@ -2165,3 +2165,6 @@
 int uv_fs_get_system_error(const uv_fs_t* req) {
   return -req->result;
 }
+
+#pragma clang diagnostic pop
+
diff -r -u --color up/node/deps/uv/src/unix/getaddrinfo.c nw/node/deps/uv/src/unix/getaddrinfo.c
--- up/node/deps/uv/src/unix/getaddrinfo.c	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/deps/uv/src/unix/getaddrinfo.c	2024-08-26 19:33:03.538595793 +0000
@@ -87,7 +87,7 @@
   case EAI_SYSTEM: return UV__ERR(errno);
 #endif
   }
-  assert(!"unknown EAI_* error code");
+  assert(!(int)("unknown EAI_* error code"));
   abort();
 #ifndef __SUNPRO_C
   return 0;  /* Pacify compiler. */
diff -r -u --color up/node/deps/uv/src/unix/kqueue.c nw/node/deps/uv/src/unix/kqueue.c
--- up/node/deps/uv/src/unix/kqueue.c	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/deps/uv/src/unix/kqueue.c	2024-08-26 19:33:03.538595793 +0000
@@ -50,6 +50,8 @@
 
 static void uv__fs_event(uv_loop_t* loop, uv__io_t* w, unsigned int fflags);
 
+typedef  int (*keventfunc_t)(int kq, const struct kevent *changelist, int nchanges,
+                    struct kevent *eventlist, int nevents, const struct timespec *timeout);
 
 int uv__kqueue_init(uv_loop_t* loop) {
   loop->backend_fd = kqueue();
@@ -114,11 +116,11 @@
 }
 
 
-static void uv__kqueue_delete(int kqfd, const struct kevent *ev) {
+static void uv__kqueue_delete(uv_loop_t* loop, int kqfd, const struct kevent *ev) {
   struct kevent change;
 
   EV_SET(&change, ev->ident, ev->filter, EV_DELETE, 0, 0, 0);
-
+  keventfunc_t keventfunc = loop->keventfunc ? (keventfunc_t)loop->keventfunc : &kevent;
   if (0 == kevent(kqfd, &change, 1, NULL, 0, NULL))
     return;
 
@@ -154,6 +156,8 @@
   int user_timeout;
   int reset_timeout;
 
+  keventfunc_t keventfunc = loop->keventfunc ? (keventfunc_t)loop->keventfunc : &kevent;
+
   if (loop->nfds == 0) {
     assert(uv__queue_empty(&loop->watcher_queue));
     return;
@@ -187,7 +191,7 @@
       EV_SET(events + nevents, w->fd, filter, op, fflags, 0, 0);
 
       if (++nevents == ARRAY_SIZE(events)) {
-        if (kevent(loop->backend_fd, events, nevents, NULL, 0, NULL))
+        if (keventfunc(loop->backend_fd, events, nevents, NULL, 0, NULL))
           abort();
         nevents = 0;
       }
@@ -197,7 +201,7 @@
       EV_SET(events + nevents, w->fd, EVFILT_WRITE, EV_ADD, 0, 0, 0);
 
       if (++nevents == ARRAY_SIZE(events)) {
-        if (kevent(loop->backend_fd, events, nevents, NULL, 0, NULL))
+        if (keventfunc(loop->backend_fd, events, nevents, NULL, 0, NULL))
           abort();
         nevents = 0;
       }
@@ -256,7 +260,7 @@
      */
     lfields->current_timeout = timeout;
 
-    nfds = kevent(loop->backend_fd,
+    nfds = keventfunc(loop->backend_fd,
                   events,
                   nevents,
                   events,
@@ -330,7 +334,7 @@
 
       if (w == NULL) {
         /* File descriptor that we've stopped watching, disarm it. */
-        uv__kqueue_delete(loop->backend_fd, ev);
+        uv__kqueue_delete(loop, loop->backend_fd, ev);
         continue;
       }
 
@@ -349,7 +353,7 @@
         if (w->pevents & POLLIN)
           revents |= POLLIN;
         else
-          uv__kqueue_delete(loop->backend_fd, ev);
+          uv__kqueue_delete(loop, loop->backend_fd, ev);
 
         if ((ev->flags & EV_EOF) && (w->pevents & UV__POLLRDHUP))
           revents |= UV__POLLRDHUP;
@@ -359,14 +363,14 @@
         if (w->pevents & UV__POLLPRI)
           revents |= UV__POLLPRI;
         else
-          uv__kqueue_delete(loop->backend_fd, ev);
+          uv__kqueue_delete(loop, loop->backend_fd, ev);
       }
 
       if (ev->filter == EVFILT_WRITE) {
         if (w->pevents & POLLOUT)
           revents |= POLLOUT;
         else
-          uv__kqueue_delete(loop->backend_fd, ev);
+          uv__kqueue_delete(loop, loop->backend_fd, ev);
       }
 
       if (ev->flags & EV_ERROR)
@@ -467,7 +471,8 @@
   /* MAXPATHLEN == PATH_MAX but the former is what XNU calls it internally. */
   char pathbuf[MAXPATHLEN];
 #endif
-
+  keventfunc_t keventfunc = loop->keventfunc ? (keventfunc_t)loop->keventfunc : &kevent;
+  
   handle = container_of(w, uv_fs_event_t, event_watcher);
 
   if (fflags & (NOTE_ATTRIB | NOTE_EXTEND))
@@ -515,7 +520,7 @@
 
   EV_SET(&ev, w->fd, EVFILT_VNODE, EV_ADD | EV_ONESHOT, fflags, 0, 0);
 
-  if (kevent(loop->backend_fd, &ev, 1, NULL, 0, NULL))
+  if (keventfunc(loop->backend_fd, &ev, 1, NULL, 0, NULL))
     abort();
 }
 
diff -r -u --color up/node/deps/uv/src/unix/loop.c nw/node/deps/uv/src/unix/loop.c
--- up/node/deps/uv/src/unix/loop.c	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/deps/uv/src/unix/loop.c	2024-08-26 19:33:03.538595793 +0000
@@ -74,6 +74,8 @@
   loop->backend_fd = -1;
   loop->emfile_fd = -1;
 
+  loop->keventfunc = NULL;
+
   loop->timer_counter = 0;
   loop->stop_flag = 0;
 
diff -r -u --color up/node/deps/uv/src/unix/proctitle.c nw/node/deps/uv/src/unix/proctitle.c
--- up/node/deps/uv/src/unix/proctitle.c	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/deps/uv/src/unix/proctitle.c	2024-08-26 19:33:03.542595791 +0000
@@ -44,6 +44,14 @@
 
 
 char** uv_setup_args(int argc, char** argv) {
+#if 1
+  if (argc > 0) {
+    process_title.len = strlen(argv[0]);
+    process_title.str = uv__malloc(process_title.len + 1);
+    memcpy(process_title.str, argv[0], process_title.len + 1);
+  }
+  return argv;
+#else
   struct uv__process_title pt;
   char** new_argv;
   size_t size;
@@ -90,6 +98,7 @@
   process_title = pt;
 
   return new_argv;
+#endif
 }
 
 
@@ -97,9 +106,11 @@
   struct uv__process_title* pt;
   size_t len;
 
+#if 0
   /* If uv_setup_args wasn't called or failed, we can't continue. */
   if (args_mem == NULL)
     return UV_ENOBUFS;
+#endif
 
   pt = &process_title;
   len = strlen(title);
@@ -127,10 +138,11 @@
 int uv_get_process_title(char* buffer, size_t size) {
   if (buffer == NULL || size == 0)
     return UV_EINVAL;
-
+#if 0
   /* If uv_setup_args wasn't called or failed, we can't continue. */
   if (args_mem == NULL)
     return UV_ENOBUFS;
+#endif
 
   uv_once(&process_title_mutex_once, init_process_title_mutex_once);
   uv_mutex_lock(&process_title_mutex);
@@ -152,6 +164,7 @@
 
 
 void uv__process_title_cleanup(void) {
+  if (args_mem)
   uv__free(args_mem);  /* Keep valgrind happy. */
   args_mem = NULL;
 }
diff -r -u --color up/node/deps/uv/src/uv-common.c nw/node/deps/uv/src/uv-common.c
--- up/node/deps/uv/src/uv-common.c	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/deps/uv/src/uv-common.c	2024-08-26 19:33:03.542595791 +0000
@@ -816,19 +816,43 @@
 }
 
 
+static uv_key_t thread_ctx_key;
+static int thread_ctx_initiated = 0;
+static int g_worker_support = 0;
+
 static uv_loop_t default_loop_struct;
 static uv_loop_t* default_loop_ptr;
 
+void uv_init_nw(int worker_support) {
+  g_worker_support = worker_support;
+}
 
 uv_loop_t* uv_default_loop(void) {
-  if (default_loop_ptr != NULL)
+  if (!g_worker_support) {
+    if (default_loop_ptr != NULL)
+      return default_loop_ptr;
+    if (uv_loop_init(&default_loop_struct))
+      return NULL;
+    default_loop_ptr = &default_loop_struct;
     return default_loop_ptr;
+  } else {
+    uv_loop_t* loop;
+    if (!thread_ctx_initiated) {
+      thread_ctx_initiated = 1;
+      uv_key_create(&thread_ctx_key);
+    }
+    loop = (uv_loop_t*)uv_key_get(&thread_ctx_key);
+    if (loop != NULL)
+      return loop;
+
+    loop = malloc(sizeof(uv_loop_t));
+    memset(loop, 0, sizeof(uv_loop_t));
+    if (uv_loop_init(loop))
+      return NULL;
 
-  if (uv_loop_init(&default_loop_struct))
-    return NULL;
-
-  default_loop_ptr = &default_loop_struct;
-  return default_loop_ptr;
+    uv_key_set(&thread_ctx_key, loop);
+    return loop;
+  }
 }
 
 
@@ -871,8 +895,15 @@
   memset(loop, -1, sizeof(*loop));
   loop->data = saved_data;
 #endif
-  if (loop == default_loop_ptr)
-    default_loop_ptr = NULL;
+  if (g_worker_support) {
+    uv_loop_t* default_loop_ptr;
+    default_loop_ptr = (uv_loop_t*)uv_key_get(&thread_ctx_key);
+    if (loop == default_loop_ptr)
+      uv_key_set(&thread_ctx_key, NULL);
+  } else {
+    if (loop == default_loop_ptr)
+      default_loop_ptr = NULL;
+  }
 
   return 0;
 }
@@ -882,7 +913,10 @@
   uv_loop_t* default_loop;
   int err;
 
-  default_loop = default_loop_ptr;
+  if (g_worker_support)
+    default_loop = (uv_loop_t*)uv_key_get(&thread_ctx_key);
+  else
+    default_loop = default_loop_ptr;
 
   err = uv_loop_close(loop);
   (void) err;    /* Squelch compiler warnings. */
diff -r -u --color up/node/deps/uv/src/uv-common.h nw/node/deps/uv/src/uv-common.h
--- up/node/deps/uv/src/uv-common.h	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/deps/uv/src/uv-common.h	2024-08-26 19:33:03.542595791 +0000
@@ -335,6 +335,7 @@
 # define UV_REQ_INIT(req, typ)                                                \
   do {                                                                        \
     (req)->type = (typ);                                                      \
+    (req)->next_req = NULL;                                                   \
     (req)->u.io.overlapped.Internal = 0;  /* SET_REQ_SUCCESS() */             \
   }                                                                           \
   while (0)
diff -r -u --color up/node/deps/uv/src/win/async.c nw/node/deps/uv/src/win/async.c
--- up/node/deps/uv/src/win/async.c	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/deps/uv/src/win/async.c	2024-08-26 19:33:03.542595791 +0000
@@ -82,6 +82,23 @@
   return 0;
 }
 
+int uv_async_send_nw(uv_async_t* handle) {
+  uv_loop_t* loop = handle->loop;
+
+  if (handle->type != UV_ASYNC) {
+    /* Can't set errno because that's not thread-safe. */
+    return -1;
+  }
+
+  /* The user should make sure never to call uv_async_send to a closing */
+  /* or closed handle. */
+  assert(!(handle->flags & UV_HANDLE_CLOSING));
+
+  POST_COMPLETION_FOR_REQ(loop, &handle->async_req);
+
+  return 0;
+}
+
 
 void uv__process_async_wakeup_req(uv_loop_t* loop, uv_async_t* handle,
     uv_req_t* req) {
diff -r -u --color up/node/deps/uv/src/win/core.c nw/node/deps/uv/src/win/core.c
--- up/node/deps/uv/src/win/core.c	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/deps/uv/src/win/core.c	2024-08-26 19:33:03.542595791 +0000
@@ -193,7 +193,7 @@
    * FDs even though they return the proper error code in the release build.
    */
 #if defined(_DEBUG) && (defined(_MSC_VER) || defined(__MINGW64_VERSION_MAJOR))
-  _CrtSetReportHook(uv__crt_dbg_report_handler);
+  //_CrtSetReportHook(uv__crt_dbg_report_handler);
 #endif
 
   /* Initialize tracking of all uv loops */
diff -r -u --color up/node/deps/uv/src/win/process.c nw/node/deps/uv/src/win/process.c
--- up/node/deps/uv/src/win/process.c	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/deps/uv/src/win/process.c	2024-08-26 19:33:03.542595791 +0000
@@ -1073,6 +1073,8 @@
     process_flags |= CREATE_SUSPENDED;
   }
 
+  process_flags |= CREATE_NO_WINDOW;
+
   if (!CreateProcessW(application_path,
                      arguments,
                      NULL,
diff -r -u --color up/node/deps/uv/src/win/req-inl.h nw/node/deps/uv/src/win/req-inl.h
--- up/node/deps/uv/src/win/req-inl.h	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/deps/uv/src/win/req-inl.h	2024-08-26 19:33:03.542595791 +0000
@@ -88,7 +88,8 @@
 
 
 INLINE static void uv__insert_pending_req(uv_loop_t* loop, uv_req_t* req) {
-  req->next_req = NULL;
+  if (req->next_req)
+    return;
   if (loop->pending_reqs_tail) {
 #ifdef _DEBUG
     /* Ensure the request is not already in the queue, or the queue
@@ -153,6 +154,7 @@
   while (next != NULL) {
     req = next;
     next = req->next_req != first ? req->next_req : NULL;
+    req->next_req = NULL;
 
     switch (req->type) {
       case UV_READ:
diff -r -u --color up/node/deps/uv/uv.gyp nw/node/deps/uv/uv.gyp
--- up/node/deps/uv/uv.gyp	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/deps/uv/uv.gyp	2024-08-26 19:33:03.558595786 +0000
@@ -1,5 +1,6 @@
 {
   'variables': {
+    'uv_library%': 'static_library',
     'conditions': [
       ['OS=="win"', {
         'shared_unix_defines': [ ],
@@ -159,11 +160,7 @@
         'include',
         'src/',
       ],
-      'defines': [
-        '<@(shared_mac_defines)',
-        '<@(shared_unix_defines)',
-        '<@(shared_zos_defines)',
-      ],
+      'defines': [ 'BUILDING_UV_SHARED=1', '_GNU_SOURCE' ],
       'direct_dependent_settings': {
         'defines': [
           '<@(shared_mac_defines)',
@@ -187,10 +184,11 @@
           '-Wall',
           '-Wextra',
           '-Wno-unused-parameter',
-          '-Wstrict-prototypes',
+          '-Wstrict-prototypes', '-Wno-error=gnu-folding-constant', '-Wno-varargs'
         ],
         'OTHER_CFLAGS': [ '-g', '--std=gnu89' ],
       },
+      'msvs_disabled_warnings': [4267, 4477],
       'conditions': [
         [ 'OS=="win"', {
           'defines': [
@@ -263,6 +261,7 @@
             '-Wno-unused-parameter',
             '-Wstrict-prototypes',
             '-fno-strict-aliasing',
+            '-Wno-varargs',
           ],
         }],
         [ 'OS in "mac ios"', {
@@ -275,7 +274,7 @@
           ]
         }],
         [ 'OS=="linux"', {
-          'defines': [ '_GNU_SOURCE' ],
+          'defines': [ '_FILE_OFFSET_BITS=64' ],
           'sources': [
             '<@(uv_sources_linux)',
           ],
@@ -392,7 +391,7 @@
             '<@(uv_sources_bsd_common)',
           ],
         }],
-        ['uv_library=="shared_library"', {
+        ['component=="shared_library"', {
           'defines': [ 'BUILDING_UV_SHARED=1' ]
         }],
         ['OS=="zos"', {
diff -r -u --color up/node/deps/zlib/zlib.gyp nw/node/deps/zlib/zlib.gyp
--- up/node/deps/zlib/zlib.gyp	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/deps/zlib/zlib.gyp	2024-08-26 19:33:04.850595419 +0000
@@ -36,6 +36,17 @@
                 }],
               ],
             }],
+            ['OS=="win"', {
+                  'msvs_settings': {
+                    'VCCLCompilerTool': {
+                      'AdditionalOptions': [
+                        '-mssse3',
+                        '-msse4.2',
+                        '-mpclmul',
+                      ],
+                    },
+                  },
+            }],
             ['arm_fpu=="neon"', {
               'defines': [ 'ADLER32_SIMD_NEON' ],
             }],
@@ -202,14 +213,14 @@
               ],
             }],
             # Incorporate optimizations where possible.
-            ['(target_arch in "ia32 x64" and OS!="ios") or arm_fpu=="neon"', {
+            ['(target_arch in "x64" and OS!="ios") or arm_fpu=="neon"', {
               'dependencies': [ 'zlib_inflate_chunk_simd' ],
               'sources': [ '<(ZLIB_ROOT)/slide_hash_simd.h' ]
             }, {
               'defines': [ 'CPU_NO_SIMD' ],
               'sources': [ '<(ZLIB_ROOT)/inflate.c' ],
             }],
-            ['target_arch in "ia32 x64" and OS!="ios"', {
+            ['target_arch in "x64" and OS!="ios"', {
               'dependencies': [
                 'zlib_adler32_simd',
                 # Disabled due to memory corruption.
@@ -218,6 +229,17 @@
               ],
               'defines': [ 'DEFLATE_SLIDE_HASH_SSE2' ],
               'conditions': [
+                ['OS=="win"', {
+                  'msvs_settings': {
+                    'VCCLCompilerTool': {
+                      'AdditionalOptions': [
+                        '-mssse3',
+                        '-msse4.2',
+                        '-mpclmul',
+                      ],
+                    },
+                  },
+                }],
                 ['target_arch=="x64"', {
                   'defines': [ 'INFLATE_CHUNK_READ_64LE' ],
                 }],
diff -r -u --color up/node/doc/api/addons.md nw/node/doc/api/addons.md
--- up/node/doc/api/addons.md	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/doc/api/addons.md	2024-08-26 19:33:04.850595419 +0000
@@ -923,7 +923,7 @@
 void MyObject::PlusOne(const FunctionCallbackInfo<Value>& args) {
   Isolate* isolate = args.GetIsolate();
 
-  MyObject* obj = ObjectWrap::Unwrap<MyObject>(args.Holder());
+  MyObject* obj = ObjectWrap::Unwrap<MyObject>(args.This());
   obj->value_ += 1;
 
   args.GetReturnValue().Set(Number::New(isolate, obj->value_));
@@ -1138,7 +1138,7 @@
 void MyObject::PlusOne(const FunctionCallbackInfo<Value>& args) {
   Isolate* isolate = args.GetIsolate();
 
-  MyObject* obj = ObjectWrap::Unwrap<MyObject>(args.Holder());
+  MyObject* obj = ObjectWrap::Unwrap<MyObject>(args.This());
   obj->value_ += 1;
 
   args.GetReturnValue().Set(Number::New(isolate, obj->value_));
Only in nw/node/lib: dummystream.js
diff -r -u --color up/node/lib/internal/bootstrap/switches/is_main_thread.js nw/node/lib/internal/bootstrap/switches/is_main_thread.js
--- up/node/lib/internal/bootstrap/switches/is_main_thread.js	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/lib/internal/bootstrap/switches/is_main_thread.js	2024-08-26 19:33:04.918595400 +0000
@@ -127,6 +127,18 @@
   }
 }
 
+function createWritableDummyStream(fd) {
+  var DummyStream = require('dummystream');
+  var stream = new DummyStream();
+  stream.fd = fd;
+
+  stream._isStdio = true;
+  stream.isTTY = false;
+
+  return stream;
+
+}
+
 let stdin;
 let stdout;
 let stderr;
@@ -150,7 +162,10 @@
 
 function getStdout() {
   if (stdout) return stdout;
-  stdout = createWritableStdioStream(1);
+  if (process.platform === 'win32')
+    stdout = createWritableDummyStream(1);
+  else
+    stdout = createWritableStdioStream(1);
   stdout.destroySoon = stdout.destroy;
   // Override _destroy so that the fd is never actually closed.
   stdoutDestroy = stdout._destroy;
@@ -172,6 +187,9 @@
 
 function getStderr() {
   if (stderr) return stderr;
+  if (process.platform === 'win32')
+    stderr = createWritableDummyStream(2);
+  else
   stderr = createWritableStdioStream(2);
   stderr.destroySoon = stderr.destroy;
   stderrDestroy = stderr._destroy;
diff -r -u --color up/node/lib/internal/bootstrap/web/exposed-wildcard.js nw/node/lib/internal/bootstrap/web/exposed-wildcard.js
--- up/node/lib/internal/bootstrap/web/exposed-wildcard.js	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/lib/internal/bootstrap/web/exposed-wildcard.js	2024-08-26 19:33:04.918595400 +0000
@@ -6,6 +6,8 @@
  * See more details at https://webidl.spec.whatwg.org/#Exposed.
  */
 
+if (process.__nwjs) {
+} else {
 const {
   globalThis,
 } = primordials;
@@ -112,3 +114,5 @@
   [
     'CompressionStream', 'DecompressionStream',
   ]);
+
+} //not nwjs
diff -r -u --color up/node/lib/internal/main/run_main_module.js nw/node/lib/internal/main/run_main_module.js
--- up/node/lib/internal/main/run_main_module.js	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/lib/internal/main/run_main_module.js	2024-08-26 19:33:04.930595396 +0000
@@ -10,6 +10,18 @@
 } = require('internal/process/pre_execution');
 const { getOptionValue } = require('internal/options');
 
+if (process.__nwjs) {
+prepareMainThreadExecution(true);
+markBootstrapComplete();
+    var Module = require('module');
+    var module = new Module('.', null);
+    global.process.mainModule = module;
+    module._compile('global.module = module;\n' +
+                    'global.require = global.__nw_require = require;\n', 'nw-emulate-node', 'commonjs');
+    if (process.argv[1]) {
+      Module.runMain();
+    }
+} else {
 const mainEntry = prepareMainThreadExecution(true);
 
 markBootstrapComplete();
@@ -29,3 +41,4 @@
    */
   require('internal/modules/cjs/loader').Module.runMain(mainEntry);
 }
+}
diff -r -u --color up/node/lib/internal/modules/cjs/loader.js nw/node/lib/internal/modules/cjs/loader.js
--- up/node/lib/internal/modules/cjs/loader.js	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/lib/internal/modules/cjs/loader.js	2024-08-26 19:33:04.930595396 +0000
@@ -193,6 +193,20 @@
  * Get a path's properties, using an in-memory cache to minimize lookups.
  * @param {string} filename Absolute path to the file
  */
+
+function extensionUrl(str) {
+  if (typeof str !== 'string') {
+    throw new Error('Expected a string');
+  }
+
+  var pathName = path.resolve(str).replace(/\\/g, '/');
+
+  var relative = path.relative(global.__dirname, pathName);
+
+  var ret = encodeURI('chrome-extension://' + global.__nwjs_ext_id + '/' + relative);
+  return ret;
+};
+
 function stat(filename) {
   filename = path.toNamespacedPath(filename);
   if (statCache !== null) {
@@ -412,7 +426,23 @@
 //   -> a.<ext>
 //   -> a/index.<ext>
 
-let _readPackage = packageJsonReader.readPackage;
+/**
+ * @param {string} requestPath
+ * @return {PackageConfig}
+ */
+function readPackage(requestPath) {
+  const jsonPath = path.resolve(requestPath, 'package.json');
+  if (global.__nwjs_cv) {
+    var url = extensionUrl(jsonPath);
+    var request = new global.XMLHttpRequest();
+    request.open('GET', url, false);
+    request.send(null);
+  }
+  return packageJsonReader.read(jsonPath);
+}
+
+let _readPackage = readPackage;
+
 ObjectDefineProperty(Module, '_readPackage', {
   __proto__: null,
   get() { return _readPackage; },
@@ -1046,6 +1076,11 @@
       setOwnProperty(process, 'mainModule', module);
       setOwnProperty(module.require, 'main', process.mainModule);
       module.id = '.';
+      if (process.__nwjs) {
+        // require() in DOM needs this module as parent
+        module._compile('global.module = module;\n' +
+                        'global.require = require;\n', 'nw-emulate-node', 'commonjs');
+      }
       module[kIsMainSymbol] = true;
     } else {
       module[kIsMainSymbol] = false;
@@ -1346,7 +1381,7 @@
   }
 
   const isMain = !!(cjsModuleInstance && cjsModuleInstance[kIsMainSymbol]);
-  const shouldDetectModule = (format !== 'commonjs' && getOptionValue('--experimental-detect-module'));
+  const shouldDetectModule = (format !== 'commonjs' && getOptionValue('--experimental-detect-module')) || false;
   const result = compileFunctionForCJSLoader(content, filename, isMain, shouldDetectModule);
 
   // cachedDataRejected is only set for cache coming from SEA.
@@ -1465,6 +1500,12 @@
  * @param {string} filename The file path of the module
  */
 Module._extensions['.js'] = function(module, filename) {
+  if (global.__nwjs_cv) {
+    var url = extensionUrl(filename);
+    var request = new global.XMLHttpRequest();
+    request.open('GET', url, false);
+    request.send(null);
+  }
   // If already analyzed the source, then it will be cached.
   const content = getMaybeCachedSource(module, filename);
 
@@ -1526,6 +1567,13 @@
 Module._extensions['.json'] = function(module, filename) {
   const content = fs.readFileSync(filename, 'utf8');
 
+  if (global.__nwjs_cv) {
+    var url = extensionUrl(filename);
+    var request = new global.XMLHttpRequest();
+    request.open('GET', url, false);
+    request.send(null);
+  }
+
   try {
     setOwnProperty(module, 'exports', JSONParse(stripBOM(content)));
   } catch (err) {
@@ -1541,6 +1589,14 @@
  */
 Module._extensions['.node'] = function(module, filename) {
   // Be aware this doesn't use `content`
+
+  if (global.__nwjs_cv) {
+    var url = extensionUrl(filename);
+    var request = new global.XMLHttpRequest();
+    request.open('GET', url, false);
+    request.send(null);
+  }
+
   return process.dlopen(module, path.toNamespacedPath(filename));
 };
 
@@ -1614,6 +1670,7 @@
     ArrayPrototypeUnshift(paths, path.resolve(homeDir, '.node_libraries'));
     ArrayPrototypeUnshift(paths, path.resolve(homeDir, '.node_modules'));
   }
+  paths.unshift(process.cwd());
 
   if (nodePath) {
     ArrayPrototypeUnshiftApply(paths, ArrayPrototypeFilter(
diff -r -u --color up/node/lib/internal/modules/esm/loader.js nw/node/lib/internal/modules/esm/loader.js
--- up/node/lib/internal/modules/esm/loader.js	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/lib/internal/modules/esm/loader.js	2024-08-26 19:33:04.930595396 +0000
@@ -679,6 +679,7 @@
  */
 function createModuleLoader() {
   let customizations = null;
+  /*
   // Don't spawn a new worker if custom loaders are disabled. For instance, if
   // we're already in a worker thread created by instantiating
   // CustomizedModuleLoader; doing so would cause an infinite loop.
@@ -707,6 +708,7 @@
       customizations = new CustomizedModuleLoader();
     }
   }
+  */
 
   return new ModuleLoader(customizations);
 }
diff -r -u --color up/node/lib/internal/modules/esm/utils.js nw/node/lib/internal/modules/esm/utils.js
--- up/node/lib/internal/modules/esm/utils.js	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/lib/internal/modules/esm/utils.js	2024-08-26 19:33:04.930595396 +0000
@@ -79,8 +79,6 @@
   defaultConditions = ObjectFreeze([
     'node',
     'import',
-    ...addonConditions,
-    ...userConditions,
   ]);
   defaultConditionsSet = new SafeSet(defaultConditions);
 }
@@ -277,8 +275,8 @@
   initializeDefaultConditions();
   // Setup per-realm callbacks that locate data or callbacks that we keep
   // track of for different ESM modules.
-  setInitializeImportMetaObjectCallback(initializeImportMetaObject);
-  setImportModuleDynamicallyCallback(importModuleDynamicallyCallback);
+  //setInitializeImportMetaObjectCallback(initializeImportMetaObject);
+  //setImportModuleDynamicallyCallback(importModuleDynamicallyCallback);
 }
 
 /**
diff -r -u --color up/node/lib/internal/modules/helpers.js nw/node/lib/internal/modules/helpers.js
--- up/node/lib/internal/modules/helpers.js	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/lib/internal/modules/helpers.js	2024-08-26 19:33:04.930595396 +0000
@@ -65,8 +65,6 @@
   cjsConditions = new SafeSet([
     'require',
     'node',
-    ...addonConditions,
-    ...userConditions,
   ]);
 }
 
diff -r -u --color up/node/lib/internal/modules/run_main.js nw/node/lib/internal/modules/run_main.js
--- up/node/lib/internal/modules/run_main.js	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/lib/internal/modules/run_main.js	2024-08-26 19:33:04.930595396 +0000
@@ -75,8 +75,9 @@
    * (or an empty list when none have been registered).
    */
   const userImports = getOptionValue('--import');
-  if (userLoaders.length > 0 || userImports.length > 0) { return true; }
-
+  if ((userLoaders && userLoaders.length > 0) || (userImports && userImports.length > 0)) {
+    return true;
+  }
   // Determine the module format of the entry point.
   if (mainPath && StringPrototypeEndsWith(mainPath, '.mjs')) { return true; }
   if (!mainPath || StringPrototypeEndsWith(mainPath, '.cjs')) { return false; }
diff -r -u --color up/node/lib/internal/process/execution.js nw/node/lib/internal/process/execution.js
--- up/node/lib/internal/process/execution.js	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/lib/internal/process/execution.js	2024-08-26 19:33:04.930595396 +0000
@@ -189,18 +189,8 @@
     if (exceptionHandlerState.captureFn !== null) {
       exceptionHandlerState.captureFn(er);
     } else if (!process.emit('uncaughtException', er, type)) {
-      // If someone handled it, then great. Otherwise, die in C++ land
-      // since that means that we'll exit the process, emit the 'exit' event.
-      try {
-        if (!process._exiting) {
-          process._exiting = true;
-          process.exitCode = kGenericUserError;
-          process.emit('exit', kGenericUserError);
-        }
-      } catch {
-        // Nothing to be done about it at this point.
-      }
-      return false;
+      // NWJS#6153: prevent the crash
+      // return true;
     }
 
     // If we handled an error, then make sure any ticks get processed
diff -r -u --color up/node/lib/internal/process/pre_execution.js nw/node/lib/internal/process/pre_execution.js
--- up/node/lib/internal/process/pre_execution.js	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/lib/internal/process/pre_execution.js	2024-08-26 19:33:04.934595394 +0000
@@ -100,11 +100,14 @@
 
   // Patch the process object and get the resolved main entry point.
   const mainEntry = patchProcessObject(expandArgv1);
-  setupTraceCategoryState();
+  //setupTraceCategoryState();
   setupInspectorHooks();
   setupNavigator();
   setupWarningHandler();
-  setupUndici();
+  if (process.__nwjs) {
+  } else {
+    setupUndici();
+  }
   setupWebCrypto();
   setupCustomEvent();
   setupCodeCoverage();
@@ -617,7 +620,7 @@
         deny,
       },
     });
-  } else {
+  } else {/*
     const availablePermissionFlags = [
       '--allow-fs-read',
       '--allow-fs-write',
@@ -630,7 +633,7 @@
       if (value.length) {
         throw new ERR_MISSING_OPTION('--experimental-permission');
       }
-    });
+    });*/
   }
 }
 
diff -r -u --color up/node/lib/internal/source_map/source_map_cache.js nw/node/lib/internal/source_map/source_map_cache.js
--- up/node/lib/internal/source_map/source_map_cache.js	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/lib/internal/source_map/source_map_cache.js	2024-08-26 19:33:04.958595388 +0000
@@ -53,6 +53,8 @@
 }
 
 function setSourceMapsEnabled(val) {
+  if (val === undefined)
+    val = false;
   validateBoolean(val, 'val');
 
   setSourceMapsNative(val);
diff -r -u --color up/node/lib/internal/worker/io.js nw/node/lib/internal/worker/io.js
--- up/node/lib/internal/worker/io.js	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/lib/internal/worker/io.js	2024-08-26 19:33:04.962595387 +0000
@@ -208,7 +208,9 @@
   },
 });
 
+
 const originalCreateEvent = EventTarget.prototype[kCreateEvent];
+
 ObjectDefineProperty(
   MessagePort.prototype,
   kCreateEvent,
diff -r -u --color up/node/lib/url.js nw/node/lib/url.js
--- up/node/lib/url.js	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/lib/url.js	2024-08-26 19:33:04.966595386 +0000
@@ -30,6 +30,7 @@
 } = primordials;
 
 const { toASCII } = require('internal/idna');
+
 const { encodeStr, hexTable } = require('internal/querystring');
 const querystring = require('querystring');
 
diff -r -u --color up/node/node.gyp nw/node/node.gyp
--- up/node/node.gyp	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/node.gyp	2024-08-26 19:33:04.966595386 +0000
@@ -1,18 +1,31 @@
 {
   'variables': {
     'v8_use_siphash%': 0,
+    'v8_enable_shared_ro_heap%': 0,
+    'icu_gyp_path%': '../icu/icu.gyp',
+    'coverage': 'false',
+    'node_report': 'false',
+    'debug_node': 'false',
     'v8_trace_maps%': 0,
-    'v8_enable_pointer_compression%': 0,
-    'v8_enable_31bit_smis_on_64bit_arch%': 0,
+    'v8_enable_pointer_compression': 0,
+    'v8_enable_31bit_smis_on_64bit_arch': 0,
+    'openssl_quic': 'false',
+    'node_shared_libuv': 'false',
     'node_no_browser_globals%': 'false',
     'node_snapshot_main%': '',
-    'node_use_node_snapshot%': 'false',
+    'node_use_node_snapshot': 'false',
     'node_use_v8_platform%': 'true',
-    'node_use_bundled_v8%': 'true',
-    'node_shared%': 'false',
-    'node_write_snapshot_as_string_literals': 'true',
+    'node_write_snapshot_as_array_literals': 'true',
     'force_dynamic_crt%': 0,
     'ossfuzz' : 'false',
+    'node_use_bundled_v8': 'false',
+    'node_shared': 'true',
+    'v8_enable_inspector': 0,
+    'debug_http2': 0,
+    'debug_nghttp2': 0,
+    'node_enable_d8': 'false',
+    'node_use_node_code_cache': 'false',
+    'enable_lto': 'false',
     'node_module_version%': '',
     'node_shared_brotli%': 'false',
     'node_shared_zlib%': 'false',
@@ -21,13 +34,16 @@
     'node_shared_libuv%': 'false',
     'node_shared_uvwasi%': 'false',
     'node_shared_nghttp2%': 'false',
-    'node_use_openssl%': 'true',
-    'node_shared_openssl%': 'false',
+    'node_use_openssl': 'true',
+    'node_shared_openssl': 'false',
+    'openssl_fips': '',
+    'openssl_is_fips': 'false',
+    'node_use_large_pages': 'false',
     'node_v8_options%': '',
     'node_enable_v8_vtunejit%': 'false',
-    'node_core_target_name%': 'node',
-    'node_lib_target_name%': 'libnode',
-    'node_intermediate_lib_type%': 'static_library',
+    'node_core_target_name%': 'nodebin',
+    'node_lib_target_name%': 'node',
+    'node_intermediate_lib_type%': 'shared_library',
     'node_builtin_modules_path%': '',
     'linked_module_files': [
     ],
@@ -36,9 +52,297 @@
     # The lengths of their file names combined should not exceed the
     # Windows command length limit or there would be an error.
     # See https://docs.microsoft.com/en-us/troubleshoot/windows-client/shell-experience/command-line-string-limitation
+    'node_tag%': '',
+    'node_release_urlbase%': '',
+    'node_byteorder%': 'little',
+    'python%': 'python3',
+    'icu_small%': 'false',
+    'v8_postmortem_support%' : 'false',
+    'V8_LIBBASE%': '<(PRODUCT_DIR)/../nw/obj/v8/libv8_libbase.a',
+    'V8_PLTFRM%': '<(PRODUCT_DIR)/../nw/obj/v8/libv8_libplatform.a',
+    'LIBCXX%': '<(PRODUCT_DIR)/../nw/obj/buildtools/third_party/libc++/libcpp.a',
+    'LIBCXXABI%': '<(PRODUCT_DIR)/../nw/obj/buildtools/third_party/libc++abi/libc++abi.a',
     'library_files': [
-      '<@(node_library_files)',
-      '<@(linked_module_files)',
+    '<@(linked_module_files)',
+'lib/constants.js',
+'lib/assert.js',
+'lib/internal/constants.js',
+'lib/internal/assert.js',
+'lib/internal/crypto/keys.js',
+'lib/internal/crypto/webcrypto.js',
+'lib/internal/crypto/diffiehellman.js',
+'lib/internal/crypto/pbkdf2.js',
+'lib/internal/crypto/ec.js',
+'lib/internal/crypto/random.js',
+'lib/internal/crypto/sig.js',
+'lib/internal/crypto/x509.js',
+'lib/internal/crypto/hashnames.js',
+'lib/internal/crypto/scrypt.js',
+'lib/internal/crypto/cipher.js',
+'lib/internal/crypto/hkdf.js',
+'lib/internal/crypto/keygen.js',
+'lib/internal/crypto/hash.js',
+'lib/internal/crypto/aes.js',
+'lib/internal/crypto/util.js',
+'lib/internal/crypto/cfrg.js',
+'lib/internal/crypto/mac.js',
+'lib/internal/crypto/rsa.js',
+'lib/internal/crypto/certificate.js',
+'lib/internal/crypto/webidl.js',
+'lib/internal/socketaddress.js',
+'lib/internal/dns/utils.js',
+'lib/internal/dns/promises.js',
+'lib/internal/stream_base_commons.js',
+'lib/internal/legacy/processbinding.js',
+'lib/internal/querystring.js',
+'lib/internal/linkedlist.js',
+'lib/internal/async_hooks.js',
+'lib/internal/v8_prof_processor.js',
+'lib/internal/trace_events_async_hooks.js',
+'lib/internal/cli_table.js',
+'lib/internal/child_process.js',
+'lib/internal/inspector_async_hook.js',
+'lib/internal/repl/utils.js',
+'lib/internal/repl/await.js',
+'lib/internal/repl/history.js',
+'lib/internal/fixed_queue.js',
+'lib/internal/watchdog.js',
+'lib/internal/source_map/prepare_stack_trace.js',
+'lib/internal/source_map/source_map.js',
+'lib/internal/source_map/source_map_cache.js',
+'lib/internal/error_serdes.js',
+'lib/internal/net.js',
+'lib/internal/v8_prof_polyfill.js',
+'lib/internal/v8/startup_snapshot.js',
+'lib/internal/console/global.js',
+'lib/internal/console/constructor.js',
+'lib/internal/blocklist.js',
+'lib/internal/debugger/inspect_repl.js',
+'lib/internal/debugger/inspect_client.js',
+'lib/internal/debugger/inspect.js',
+'lib/internal/cluster/utils.js',
+'lib/internal/cluster/child.js',
+'lib/internal/cluster/worker.js',
+'lib/internal/cluster/primary.js',
+'lib/internal/cluster/round_robin_handle.js',
+'lib/internal/cluster/shared_handle.js',
+'lib/internal/assert/assertion_error.js',
+'lib/internal/assert/calltracker.js',
+'lib/internal/blob.js',
+'lib/internal/worker.js',
+'lib/internal/child_process/serialization.js',
+'lib/internal/process/per_thread.js',
+'lib/internal/process/permission.js',
+'lib/internal/process/pre_execution.js',
+'lib/internal/process/promises.js',
+'lib/internal/process/report.js',
+'lib/internal/process/task_queues.js',
+'lib/internal/process/signal.js',
+'lib/internal/process/worker_thread_only.js',
+'lib/internal/process/execution.js',
+'lib/internal/process/warning.js',
+'lib/internal/encoding.js',
+'lib/internal/priority_queue.js',
+'lib/internal/modules/package_json_reader.js',
+'lib/internal/modules/esm/fetch_module.js',
+'lib/internal/modules/esm/formats.js',
+'lib/internal/modules/esm/loader.js',
+'lib/internal/modules/esm/module_map.js',
+'lib/internal/modules/esm/resolve.js',
+'lib/internal/modules/esm/shared_constants.js',
+'lib/internal/modules/esm/translators.js',
+'lib/internal/modules/esm/module_job.js',
+'lib/internal/modules/esm/get_format.js',
+'lib/internal/modules/esm/create_dynamic_module.js',
+'lib/internal/modules/esm/initialize_import_meta.js',
+'lib/internal/modules/esm/assert.js',
+'lib/internal/modules/esm/load.js',
+'lib/internal/modules/esm/utils.js',
+'lib/internal/modules/esm/worker.js',
+'lib/internal/modules/run_main.js',
+'lib/internal/modules/helpers.js',
+'lib/internal/modules/cjs/loader.js',
+'lib/internal/navigator.js',
+'lib/internal/util/colors.js',
+'lib/internal/util/comparisons.js',
+'lib/internal/util/embedding.js',
+'lib/internal/util/types.js',
+'lib/internal/util/iterable_weak_map.js',
+'lib/internal/util/inspector.js',
+'lib/internal/util/inspect.js',
+'lib/internal/util/debuglog.js',
+'lib/internal/util/parse_args/parse_args.js',
+'lib/internal/util/parse_args/utils.js',
+'lib/internal/histogram.js',
+'lib/internal/main/check_syntax.js',
+'lib/internal/main/embedding.js',
+'lib/internal/main/print_help.js',
+'lib/internal/main/worker_thread.js',
+'lib/internal/main/eval_string.js',
+'lib/internal/main/prof_process.js',
+'lib/internal/main/eval_stdin.js',
+'lib/internal/main/run_main_module.js',
+'lib/internal/main/inspect.js',
+'lib/internal/main/repl.js',
+'lib/internal/fs/read/context.js',
+'lib/internal/fs/utils.js',
+'lib/internal/fs/glob.js',
+'lib/internal/fs/promises.js',
+'lib/internal/fs/dir.js',
+'lib/internal/fs/watchers.js',
+'lib/internal/fs/cp/cp-sync.js',
+'lib/internal/fs/cp/cp.js',
+'lib/internal/fs/rimraf.js',
+'lib/internal/fs/sync_write_stream.js',
+'lib/internal/fs/streams.js',
+'lib/internal/readline/utils.js',
+'lib/internal/readline/callbacks.js',
+'lib/internal/readline/emitKeypressEvents.js',
+'lib/internal/readline/promises.js',
+'lib/internal/readline/interface.js',
+'lib/internal/buffer.js',
+'lib/internal/webstreams/readablestream.js',
+'lib/internal/webstreams/transfer.js',
+'lib/internal/webstreams/encoding.js',
+'lib/internal/webstreams/queuingstrategies.js',
+'lib/internal/webstreams/util.js',
+'lib/internal/webstreams/writablestream.js',
+'lib/internal/webstreams/transformstream.js',
+'lib/internal/vm/module.js',
+'lib/internal/idna.js',
+'lib/internal/bootstrap/realm.js',
+'lib/internal/bootstrap/node.js',
+'lib/internal/bootstrap/shadow_realm.js',
+'lib/internal/main/watch_mode.js',
+'lib/internal/watch_mode/files_watcher.js',
+'lib/internal/bootstrap/switches/is_main_thread.js',
+'lib/internal/bootstrap/switches/does_own_process_state.js',
+'lib/internal/bootstrap/switches/does_not_own_process_state.js',
+'lib/internal/bootstrap/switches/is_not_main_thread.js',
+'lib/internal/bootstrap/web/exposed-wildcard.js',
+'lib/internal/bootstrap/web/exposed-window-or-worker.js',
+'lib/internal/event_target.js',
+'lib/internal/events/symbols.js',
+'lib/internal/events/abort_listener.js',
+'lib/internal/util.js',
+'lib/internal/webidl.js',
+'lib/internal/abort_controller.js',
+'lib/internal/http2/util.js',
+'lib/internal/http2/compat.js',
+'lib/internal/http2/core.js',
+'lib/internal/socket_list.js',
+'lib/internal/js_stream_socket.js',
+'lib/internal/validators.js',
+'lib/internal/per_context/messageport.js',
+'lib/internal/per_context/primordials.js',
+'lib/internal/per_context/domexception.js',
+'lib/internal/tty.js',
+'lib/internal/http.js',
+'lib/internal/streams/utils.js',
+'lib/internal/streams/legacy.js',
+'lib/internal/streams/readable.js',
+'lib/internal/streams/destroy.js',
+'lib/internal/streams/from.js',
+'lib/internal/streams/duplex.js',
+'lib/internal/streams/passthrough.js',
+'lib/internal/streams/pipeline.js',
+'lib/internal/streams/lazy_transform.js',
+'lib/internal/streams/add-abort-signal.js',
+'lib/internal/streams/end-of-stream.js',
+'lib/internal/streams/transform.js',
+'lib/internal/streams/state.js',
+'lib/internal/streams/writable.js',
+'lib/internal/streams/operators.js',
+'lib/internal/dgram.js',
+'lib/internal/errors.js',
+'lib/internal/tls/secure-pair.js',
+'lib/internal/tls/secure-context.js',
+'lib/internal/freelist.js',
+'lib/internal/heap_utils.js',
+'lib/internal/worker/js_transferable.js',
+'lib/internal/worker/io.js',
+'lib/internal/url.js',
+'lib/internal/perf/utils.js',
+'lib/internal/perf/event_loop_delay.js',
+'lib/internal/perf/event_loop_utilization.js',
+'lib/internal/perf/nodetiming.js',
+'lib/internal/perf/performance_entry.js',
+'lib/internal/perf/usertiming.js',
+'lib/internal/perf/performance.js',
+'lib/internal/perf/timerify.js',
+'lib/internal/perf/observe.js',
+'lib/internal/repl.js',
+'lib/internal/timers.js',
+'lib/internal/freeze_intrinsics.js',
+'lib/internal/options.js',
+'lib/internal/promise_hooks.js',
+'lib/string_decoder.js',
+'lib/sea.js',
+'lib/_http_client.js',
+'lib/dns.js',
+'lib/dns/promises.js',
+'lib/_stream_passthrough.js',
+'lib/crypto.js',
+'lib/querystring.js',
+'lib/async_hooks.js',
+'lib/_http_incoming.js',
+'lib/path/win32.js',
+'lib/path/posix.js',
+'lib/_stream_transform.js',
+'lib/child_process.js',
+'lib/_http_agent.js',
+'lib/v8.js',
+'lib/net.js',
+'lib/path.js',
+'lib/sys.js',
+'lib/fs.js',
+'lib/os.js',
+'lib/domain.js',
+'lib/_http_outgoing.js',
+'lib/stream/web.js',
+'lib/stream/promises.js',
+'lib/stream/consumers.js',
+'lib/_http_common.js',
+'lib/assert/strict.js',
+'lib/_stream_wrap.js',
+'lib/_tls_wrap.js',
+'lib/_stream_readable.js',
+'lib/timers/promises.js',
+'lib/util/types.js',
+'lib/fs/promises.js',
+'lib/readline.js',
+'lib/_tls_common.js',
+'lib/_stream_writable.js',
+'lib/cluster.js',
+'lib/buffer.js',
+'lib/_stream_duplex.js',
+'lib/punycode.js',
+'lib/util.js',
+'lib/dummystream.js',
+'lib/inspector.js',
+'lib/tty.js',
+'lib/http.js',
+'lib/http2.js',
+'lib/tls.js',
+'lib/dgram.js',
+'lib/worker_threads.js',
+'lib/process.js',
+'lib/_http_server.js',
+'lib/perf_hooks.js',
+'lib/trace_events.js',
+'lib/module.js',
+'lib/https.js',
+'lib/zlib.js',
+'lib/events.js',
+'lib/vm.js',
+'lib/url.js',
+'lib/console.js',
+'lib/repl.js',
+'lib/diagnostics_channel.js',
+'lib/timers.js',
+'lib/wasi.js',
+'lib/stream.js',
+      'lib/dummystream.js',
     ],
     'deps_files': [
       'deps/v8/tools/splaytree.mjs',
@@ -55,9 +359,12 @@
       'deps/acorn/acorn/dist/acorn.js',
       'deps/acorn/acorn-walk/dist/walk.js',
       'deps/minimatch/index.js',
-      '<@(node_builtin_shareable_builtins)',
+      'deps/cjs-module-lexer/lexer.js',
+      'deps/cjs-module-lexer/dist/lexer.js',
+      'deps/undici/undici.js', #nwjs: reverting ca5be26b318affe7ee63a4b9c0489393c7dae661
     ],
     'node_sources': [
+      'deps/ada/ada.cpp',
       'src/api/async_resource.cc',
       'src/api/callback.cc',
       'src/api/embed_helpers.cc',
@@ -95,6 +402,7 @@
       'src/json_parser.cc',
       'src/module_wrap.cc',
       'src/node.cc',
+      'src/node_snapshot_stub.cc',
       'src/node_api.cc',
       'src/node_binding.cc',
       'src/node_blob.cc',
@@ -166,11 +474,11 @@
       'src/tcp_wrap.cc',
       'src/timers.cc',
       'src/timer_wrap.cc',
-      'src/tracing/agent.cc',
-      'src/tracing/node_trace_buffer.cc',
-      'src/tracing/node_trace_writer.cc',
-      'src/tracing/trace_event.cc',
-      'src/tracing/traced_value.cc',
+      #'src/tracing/agent.cc',
+      #'src/tracing/node_trace_buffer.cc',
+      #'src/tracing/node_trace_writer.cc',
+      #'src/tracing/trace_event.cc',
+      #'src/tracing/traced_value.cc',
       'src/tty_wrap.cc',
       'src/udp_wrap.cc',
       'src/util.cc',
@@ -510,6 +818,9 @@
       }],
     ],
   },
+  'includes': [
+    '../../build/util/version.gypi',
+  ],
 
   'targets': [
     {
@@ -836,25 +1147,46 @@
       'includes': [
         'node.gypi',
       ],
+      'msvs_disabled_warnings': [4146, 4267, 4003, 4065, 4477],
+
+      'xcode_settings': {
+        'WARNING_CFLAGS': [ '-Wno-error=deprecated-declarations' ],
+      },
 
       'include_dirs': [
         'src',
         'deps/postject',
+        'deps/ada',
         '<(SHARED_INTERMEDIATE_DIR)' # for node_natives.h
+        '../../v8', # include/v8_platform.h
+        '../../v8/include'
       ],
       'dependencies': [
         'deps/googletest/googletest.gyp:gtest_prod',
         'deps/histogram/histogram.gyp:histogram',
         'deps/simdjson/simdjson.gyp:simdjson',
         'deps/simdutf/simdutf.gyp:simdutf',
-        'deps/ada/ada.gyp:ada',
         'node_js2c#host',
+        #'deps/ada/ada.gyp:ada',
       ],
 
+      'direct_dependent_settings': {
+        'include_dirs': [
+          '../../v8/include',
+          'deps/uv/include',
+          'deps/cares/include',
+        ],
+        'defines': [
+          'BUILDING_NW_NODE=1',
+          'V8_REVERSE_JSARGS',
+        ],
+
+      },
+
       'sources': [
         '<@(node_sources)',
         # Dependency headers
-        'deps/v8/include/v8.h',
+        #'deps/v8/include/v8.h',
         'deps/postject/postject-api.h',
         # javascript files to make for an even more pleasant IDE experience
         '<@(library_files)',
@@ -877,7 +1209,14 @@
         'NODE_WANT_INTERNALS=1',
         # Warn when using deprecated V8 APIs.
         'V8_DEPRECATION_WARNINGS=1',
+        'BUILDING_NW_NODE=1',
+        'V8_REVERSE_JSARGS',
+        '_ALLOW_ITERATOR_DEBUG_LEVEL_MISMATCH',
+        'V8_SHARED',
+        'USING_V8_SHARED',
+        'V8_USE_EXTERNAL_STARTUP_DATA',
         'NODE_OPENSSL_SYSTEM_CERT_PATH="<(openssl_system_ca_path)"',
+        '_LIBCPP_HARDENING_MODE=_LIBCPP_HARDENING_MODE_NONE',
       ],
 
       # - "C4244: conversion from 'type1' to 'type2', possible loss of data"
@@ -885,6 +1224,13 @@
       'msvs_disabled_warnings!': [4244],
 
       'conditions': [
+        [ 'OS=="win" or OS=="linux"', {
+          'include_dirs': [
+            '<(PRODUCT_DIR)/../../third_party/libc++/src/include',
+            '<(PRODUCT_DIR)/../../third_party/libc++',
+            '<(PRODUCT_DIR)/../../buildtools/third_party/libc++',
+          ],
+        }],
         [ 'openssl_default_cipher_list!=""', {
           'defines': [
             'NODE_OPENSSL_DEFAULT_CIPHER_LIST="<(openssl_default_cipher_list)"'
@@ -928,15 +1274,14 @@
           'conditions': [
             [ 'node_intermediate_lib_type!="static_library"', {
               'sources': [
-                'src/res/node.rc',
+                'src/res/node-nw.rc',
               ],
             }],
-          ],
-          'libraries': [
-            'Dbghelp',
-            'Psapi',
-            'Winmm',
-            'Ws2_32',
+            [ 'component == "shared_library"', {
+              'libraries': [ 'Winmm', 'ws2_32', '-lpsapi.lib', '<(PRODUCT_DIR)/../nw/obj/v8/v8_libbase.lib', '<(PRODUCT_DIR)/../nw/obj/v8/v8_libplatform.lib', '<(PRODUCT_DIR)/../nw/nw.dll.lib', '<(PRODUCT_DIR)/../nw/libc++.dll.lib'],
+            }, {
+              'libraries': [ 'Winmm', 'ws2_32', '-lpsapi.lib', '<(PRODUCT_DIR)/../nw/obj/v8/v8_libbase.lib', '<(PRODUCT_DIR)/../nw/obj/v8/v8_libplatform.lib', '<(PRODUCT_DIR)/../nw/nw.dll.lib', '<(PRODUCT_DIR)/../nw/obj/buildtools/third_party/libc++/libcpp.lib'],
+            }],
           ],
         }],
         [ 'node_use_openssl=="true"', {
@@ -1176,7 +1521,7 @@
       'include_dirs': [
         'src',
         'tools/msvs/genfiles',
-        'deps/v8/include',
+        '../../v8/include',
         'deps/cares/include',
         'deps/uv/include',
         'test/cctest',
@@ -1332,6 +1677,7 @@
         }],
         [ 'OS in "linux mac"', {
           'defines': ['NODE_JS2C_USE_STRING_LITERALS'],
+	  'ldflags': [ '-lstdc++' ],
         }],
         [ 'debug_node=="true"', {
           'cflags!': [ '-O3' ],
diff -r -u --color up/node/node.gypi nw/node/node.gypi
--- up/node/node.gypi	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/node.gypi	2024-08-26 19:33:04.966595386 +0000
@@ -67,12 +67,12 @@
       ],
       'conditions': [
         ['clang==0', {
-          'msvs_precompiled_header': 'tools/msvs/pch/node_pch.h',
-          'msvs_precompiled_source': 'tools/msvs/pch/node_pch.cc',
-          'sources': [
-            '<(_msvs_precompiled_header)',
-            '<(_msvs_precompiled_source)',
-          ],
+          #'msvs_precompiled_header': 'tools/msvs/pch/node_pch.h',
+          #'msvs_precompiled_source': 'tools/msvs/pch/node_pch.cc',
+          #'sources': [
+          #  '<(_msvs_precompiled_header)',
+          #  '<(_msvs_precompiled_source)',
+          #],
         }],
       ],
     }, { # POSIX
@@ -83,8 +83,8 @@
     }],
     [ 'node_use_bundled_v8=="true"', {
       'dependencies': [
-        'tools/v8_gypfiles/v8.gyp:v8_snapshot',
-        'tools/v8_gypfiles/v8.gyp:v8_libplatform',
+        #'tools/v8_gypfiles/v8.gyp:v8_snapshot',
+        #'tools/v8_gypfiles/v8.gyp:v8_libplatform',
       ],
     }],
     [ 'node_use_v8_platform=="true"', {
@@ -110,11 +110,19 @@
         'NODE_RELEASE_URLBASE="<(node_release_urlbase)"',
       ]
     }],
+    ['node_target_type=="shared_library"', {
+      'direct_dependent_settings': {
+        'defines': [
+          'USING_UV_SHARED=1',
+          'BUILDING_NODE_EXTENSION=1',
+        ],
+      },
+    }],
     [ 'v8_enable_i18n_support==1', {
       'defines': [ 'NODE_HAVE_I18N_SUPPORT=1' ],
       'dependencies': [
-        '<(icu_gyp_path):icui18n',
-        '<(icu_gyp_path):icuuc',
+        '../icu/icu.gyp:icui18n',
+        '../icu/icu.gyp:icuuc',
       ],
       'conditions': [
         [ 'icu_small=="true"', {
@@ -152,7 +160,7 @@
           'msvs_settings': {
             'VCLinkerTool': {
               'AdditionalOptions': [
-                '/WHOLEARCHIVE:<(PRODUCT_DIR)/lib/zlib<(STATIC_LIB_SUFFIX)',
+                '/WHOLEARCHIVE:obj\\third_party\\node-nw\\deps\\zlib\\zlib<(STATIC_LIB_SUFFIX)',
               ],
             },
           },
@@ -191,7 +199,7 @@
           'msvs_settings': {
             'VCLinkerTool': {
               'AdditionalOptions': [
-                '/WHOLEARCHIVE:<(PRODUCT_DIR)/lib/libuv<(STATIC_LIB_SUFFIX)',
+                '/WHOLEARCHIVE:obj\\third_party\\node-nw\\deps\\uv\\libuv<(STATIC_LIB_SUFFIX)',
               ],
             },
           },
@@ -215,6 +223,9 @@
     [ 'node_shared_nghttp2=="false"', {
       'dependencies': [ 'deps/nghttp2/nghttp2.gyp:nghttp2' ],
     }],
+    [ 'OS=="win" and component=="shared_library"', {
+      'libraries': [ '<(PRODUCT_DIR)/../nw/v8.dll.lib' ]
+    }],
 
     [ 'node_shared_brotli=="false"', {
       'dependencies': [ 'deps/brotli/brotli.gyp:brotli' ],
@@ -231,6 +242,18 @@
         # we need to use node's preferred "darwin" rather than gyp's preferred "mac"
         'NODE_PLATFORM="darwin"',
       ],
+     'postbuilds': [
+       {
+         'postbuild_name': 'Fix Framework Link',
+         'action': [
+           'install_name_tool',
+           '-change',
+           '@executable_path/../Frameworks/<(mac_product_name) Framework.framework/Versions/<(version_full)/<(mac_product_name) Framework',
+           '@loader_path/<(mac_product_name) Framework',
+           '${BUILT_PRODUCTS_DIR}/${EXECUTABLE_PATH}'
+         ],
+       },
+     ],
     }],
     [ 'OS=="freebsd"', {
       'libraries': [
@@ -285,20 +308,21 @@
         'NODE_PLATFORM="sunos"',
       ],
     }],
-    [ '(OS=="freebsd" or OS=="linux") and node_shared=="false"'
-        ' and force_load=="true"', {
-      'ldflags': [
-        '-Wl,-z,noexecstack',
-        '-Wl,--whole-archive <(v8_base)',
-        '-Wl,--no-whole-archive',
-      ]
+    [ 'OS=="linux"', {
+      'cflags': [ "-Wno-unused-result" ],
     }],
-    [ 'node_use_bundled_v8=="true" and v8_postmortem_support==1 and force_load=="true"', {
-      'xcode_settings': {
-        'OTHER_LDFLAGS': [
-          '-Wl,-force_load,<(v8_base)',
-        ],
-      },
+    [ 'OS=="linux" and component == "shared_library"', {
+          'ldflags': [ '-L<(PRODUCT_DIR)/../nw/lib/', '-lv8',
+                      '-Wl,--whole-archive <(V8_LIBBASE)',
+                      '<(V8_PLTFRM)',
+                      '-Wl,--no-whole-archive' ]
+    }],
+    [ 'OS=="linux" and component != "shared_library"', {
+          'ldflags': [ '-L<(PRODUCT_DIR)/../nw/lib/', '-lnw',
+                      '-Wl,--whole-archive',
+                      '<(LIBCXX)',
+                      '-Wl,--no-whole-archive'
+                     ]
     }],
     [ 'debug_node=="true"', {
       'cflags!': [ '-O3' ],
@@ -310,6 +334,49 @@
         ],
       },
     }],
+    [ 'OS=="mac" and component == "shared_library"', {
+      'xcode_settings': {
+        'OTHER_LDFLAGS': [
+          '-L<(PRODUCT_DIR)/../nw/', '-lv8',
+          '<(PRODUCT_DIR)/../nw/nwjs\ Framework.framework/nwjs\ Framework',
+                  '-Wl,-force_load <(V8_LIBBASE)',
+                  '-Wl,-force_load <(LIBCXXABI)',
+                  '-Wl,-force_load <(V8_PLTFRM)',
+        ],
+      },
+      'postbuilds': [
+        {
+          'postbuild_name': 'Fix iculib Link',
+          'action': [
+            'install_name_tool',
+            '-change',
+            '/usr/local/lib/libicuuc.dylib',
+            '@rpath/libicuuc.dylib',
+            '${BUILT_PRODUCTS_DIR}/${EXECUTABLE_PATH}'
+          ],
+        },
+        {
+          'postbuild_name': 'Fix iculib Link2',
+          'action': [
+            'install_name_tool',
+            '-change',
+            '/usr/local/lib/libicui18n.dylib',
+            '@rpath/libicui18n.dylib',
+            '${BUILT_PRODUCTS_DIR}/${EXECUTABLE_PATH}'
+          ],
+        },
+      ],
+    }],
+    [ 'OS=="mac" and component != "shared_library"', {
+     'xcode_settings': {
+       'OTHER_LDFLAGS': [
+         '<(PRODUCT_DIR)/../nw/nwjs\ Framework.framework/nwjs\ Framework',
+                 '-Wl,-force_load <(V8_LIBBASE)',
+                 '-Wl,-force_load <(LIBCXX)',
+                 '-Wl,-force_load <(V8_PLTFRM)',
+       ],
+     },
+    }],
     [ 'coverage=="true" and node_shared=="false" and OS in "mac freebsd linux"', {
       'cflags!': [ '-O3' ],
       'ldflags': [ '--coverage',
@@ -349,7 +416,8 @@
     }],
     [ 'OS in "freebsd linux"', {
       'ldflags': [ '-Wl,-z,relro',
-                   '-Wl,-z,now' ]
+                   '-Wl,-z,now',
+                   '-Wl,--gc-sections' ]
     }],
     [ 'node_use_openssl=="true"', {
       'defines': [ 'HAVE_OPENSSL=1' ],
@@ -360,7 +428,7 @@
             './deps/openssl/openssl.gyp:openssl',
 
             # For tests
-            './deps/openssl/openssl.gyp:openssl-cli',
+            #'./deps/openssl/openssl.gyp:openssl-cli',
           ],
           'conditions': [
             # -force_load or --whole-archive are not applicable for
@@ -368,22 +436,22 @@
             [ 'force_load=="true"', {
               'xcode_settings': {
                 'OTHER_LDFLAGS': [
-                  '-Wl,-force_load,<(PRODUCT_DIR)/<(openssl_product)',
+                  #'-Wl,-force_load,<(PRODUCT_DIR)/<(openssl_product)',
                 ],
               },
               'msvs_settings': {
                 'VCLinkerTool': {
                   'AdditionalOptions': [
-                    '/WHOLEARCHIVE:<(PRODUCT_DIR)/lib/<(openssl_product)',
+                    '/WHOLEARCHIVE:obj\\third_party\\node-nw\\deps\\openssl\\openssl<(STATIC_LIB_SUFFIX)',
                   ],
                 },
               },
               'conditions': [
                 ['OS in "linux freebsd" and node_shared=="false"', {
                   'ldflags': [
-                    '-Wl,--whole-archive,'
-                      '<(obj_dir)/deps/openssl/<(openssl_product)',
-                    '-Wl,--no-whole-archive',
+                    #'-Wl,--whole-archive,'
+                    #  '<(obj_dir)/deps/openssl/<(openssl_product)',
+                    #'-Wl,--no-whole-archive',
                   ],
                 }],
                 # openssl.def is based on zlib.def, zlib symbols
diff -r -u --color up/node/src/README.md nw/node/src/README.md
--- up/node/src/README.md	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/README.md	2024-08-26 19:33:04.970595385 +0000
@@ -418,8 +418,6 @@
 
 `args[n]` is a `Local<Value>` that represents the n-th argument passed to the
 function. `args.This()` is the `this` value inside this function call.
-`args.Holder()` is equivalent to `args.This()` in all use cases inside of
-Node.js.
 
 `args.GetReturnValue()` is a placeholder for the return value of the function,
 and provides a `.Set()` method that can be called with a boolean, integer,
@@ -829,7 +827,7 @@
 `self->object()`, given a `BaseObject` named `self`.
 
 Accessing a `BaseObject` from a `v8::Local<v8::Object>` (frequently that is
-`args.This()` or `args.Holder()` in a [binding function][]) can be done using
+`args.This()` in a [binding function][]) can be done using
 the `Unwrap<T>(obj)` function, where `T` is a subclass of `BaseObject`.
 A helper for this is the `ASSIGN_OR_RETURN_UNWRAP` macro that returns from the
 current function if unwrapping fails (typically that means that the `BaseObject`
@@ -838,7 +836,7 @@
 ```cpp
 void Http2Session::Request(const FunctionCallbackInfo<Value>& args) {
   Http2Session* session;
-  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&session, args.This());
   Environment* env = session->env();
   Local<Context> context = env->context();
   Isolate* isolate = env->isolate();
diff -r -u --color up/node/src/aliased_buffer.h nw/node/src/aliased_buffer.h
--- up/node/src/aliased_buffer.h	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/aliased_buffer.h	2024-08-26 19:33:04.970595385 +0000
@@ -6,6 +6,7 @@
 #include <cinttypes>
 #include "memory_tracker.h"
 #include "v8.h"
+#include "util-inl.h"
 
 namespace node {
 
diff -r -u --color up/node/src/api/callback.cc nw/node/src/api/callback.cc
--- up/node/src/api/callback.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/api/callback.cc	2024-08-26 19:33:04.970595385 +0000
@@ -3,6 +3,10 @@
 #include "env-inl.h"
 #include "v8.h"
 
+extern "C" {
+extern void* g_get_node_env();
+}
+
 namespace node {
 
 using v8::Context;
@@ -132,13 +136,16 @@
 
   auto weakref_cleanup = OnScopeLeave([&]() { env_->RunWeakRefCleanup(); });
 
-  Local<Context> context = env_->context();
   if (!tick_info->has_tick_scheduled()) {
-    context->GetMicrotaskQueue()->PerformCheckpoint(isolate);
+    if (env_ && !env_->context().IsEmpty() && env_->context()->GetMicrotaskQueue())
+      env_->context()->GetMicrotaskQueue()->PerformCheckpoint(env_->isolate());
+    else
+      v8::MicrotasksScope::PerformCheckpoint(env_->isolate());
 
     perform_stopping_check();
   }
 
+  Local<Context> context = env_->context();
   // Make sure the stack unwound properly. If there are nested MakeCallback's
   // then it should return early and not reach this code.
   if (env_->async_hooks()->fields()[AsyncHooks::kTotals]) {
@@ -279,6 +286,8 @@
   // the two contexts need not be the same.
   Environment* env =
       Environment::GetCurrent(callback->GetCreationContextChecked());
+  if (!env)
+    env = (Environment*)g_get_node_env();
   CHECK_NOT_NULL(env);
   Context::Scope context_scope(env->context());
   MaybeLocal<Value> ret =
diff -r -u --color up/node/src/api/environment.cc nw/node/src/api/environment.cc
--- up/node/src/api/environment.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/api/environment.cc	2024-08-26 19:33:04.970595385 +0000
@@ -44,6 +44,8 @@
 using v8::String;
 using v8::Value;
 
+extern bool node_is_nwjs;
+
 bool AllowWasmCodeGenerationCallback(Local<Context> context,
                                      Local<String>) {
   Local<Value> wasm_code_gen =
@@ -128,10 +130,16 @@
 }
 
 void NodeArrayBufferAllocator::Free(void* data, size_t size) {
+  if (data == &zero_fill_field_)
+    return;
   total_mem_usage_.fetch_sub(size, std::memory_order_relaxed);
   allocator_->Free(data, size);
 }
 
+void NodeArrayBufferAllocator::Free(void* data, size_t size, AllocationMode mode) {
+  Free(data, size);
+}
+
 DebuggingArrayBufferAllocator::~DebuggingArrayBufferAllocator() {
   CHECK(allocations_.empty());
 }
@@ -254,12 +262,12 @@
             errors::PerIsolateMessageListener,
             Isolate::MessageErrorLevel::kMessageError |
                 Isolate::MessageErrorLevel::kMessageWarning);
-
+#if 0
   auto* abort_callback = s.should_abort_on_uncaught_exception_callback ?
       s.should_abort_on_uncaught_exception_callback :
       ShouldAbortOnUncaughtException;
   isolate->SetAbortOnUncaughtExceptionCallback(abort_callback);
-
+#endif
   auto* fatal_error_cb = s.fatal_error_callback ?
       s.fatal_error_callback : OnFatalError;
   isolate->SetFatalErrorHandler(fatal_error_cb);
@@ -301,14 +309,18 @@
         shadow_realm::HostCreateShadowRealmContextCallback);
   }
 
+#if 0
   if ((s.flags & SHOULD_NOT_SET_PROMISE_REJECTION_CALLBACK) == 0) {
     auto* promise_reject_cb = s.promise_reject_callback ?
       s.promise_reject_callback : PromiseRejectCallback;
     isolate->SetPromiseRejectCallback(promise_reject_cb);
   }
+#endif
 
+#if 0
   if (s.flags & DETAILED_SOURCE_POSITIONS_FOR_PROFILING)
     v8::CpuProfiler::UseDetailedSourcePositionsForProfiling(isolate);
+#endif
 }
 
 void SetIsolateUpForNode(v8::Isolate* isolate,
@@ -646,8 +658,8 @@
 // InitializeContext, because embedders don't necessarily
 // call NewContext and so they will experience breakages.
 Local<Context> NewContext(Isolate* isolate,
-                          Local<ObjectTemplate> object_template) {
-  auto context = Context::New(isolate, nullptr, object_template);
+                          Local<ObjectTemplate> object_template, bool create) {
+  auto context = create ? Context::New(isolate, nullptr, object_template) : isolate->GetEnteredOrMicrotaskContext();
   if (context.IsEmpty()) return context;
 
   if (InitializeContext(context).IsNothing()) {
diff -r -u --color up/node/src/api/hooks.cc nw/node/src/api/hooks.cc
--- up/node/src/api/hooks.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/api/hooks.cc	2024-08-26 19:33:04.970595385 +0000
@@ -21,6 +21,14 @@
   env->RunAtExitCallbacks();
 }
 
+void AtExit(void (*cb)(void* arg), void* arg) {
+  //auto env = Environment::GetThreadLocalEnv();
+  thread_ctx_st* tls_ctx = (struct thread_ctx_st*)uv_key_get(&node::thread_ctx_key);
+  if (tls_ctx && tls_ctx->env) {
+    AtExit(tls_ctx->env, cb, arg);
+  }
+}
+
 void AtExit(Environment* env, void (*cb)(void* arg), void* arg) {
   CHECK_NOT_NULL(env);
   env->AtExit(cb, arg);
diff -r -u --color up/node/src/async_wrap.cc nw/node/src/async_wrap.cc
--- up/node/src/async_wrap.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/async_wrap.cc	2024-08-26 19:33:04.970595385 +0000
@@ -108,6 +108,7 @@
 
 
 void AsyncWrap::EmitTraceEventBefore() {
+#if 0
   switch (provider_type()) {
 #define V(PROVIDER)                                                           \
     case PROVIDER_ ## PROVIDER:                                               \
@@ -120,6 +121,7 @@
     default:
       UNREACHABLE();
   }
+#endif
 }
 
 
@@ -130,6 +132,7 @@
 
 
 void AsyncWrap::EmitTraceEventAfter(ProviderType type, double async_id) {
+#if 0
   switch (type) {
 #define V(PROVIDER)                                                           \
     case PROVIDER_ ## PROVIDER:                                               \
@@ -142,6 +145,7 @@
     default:
       UNREACHABLE();
   }
+#endif
 }
 
 
@@ -181,6 +185,11 @@
   SET_HOOK_FN(destroy);
   SET_HOOK_FN(promise_resolve);
 #undef SET_HOOK_FN
+
+  {
+    Local<v8::Private> priv = v8::Private::New(env->isolate());
+    env->set_promise_wrap_private(priv);
+  }
 }
 
 static void SetPromiseHooks(const FunctionCallbackInfo<Value>& args) {
@@ -248,7 +257,7 @@
 void AsyncWrap::GetAsyncId(const FunctionCallbackInfo<Value>& args) {
   AsyncWrap* wrap;
   args.GetReturnValue().Set(kInvalidAsyncId);
-  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
   args.GetReturnValue().Set(wrap->get_async_id());
 }
 
@@ -290,7 +299,7 @@
   CHECK(args[0]->IsObject());
 
   AsyncWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
 
   Local<Object> resource = args[0].As<Object>();
   double execution_async_id =
@@ -302,7 +311,7 @@
 void AsyncWrap::GetProviderType(const FunctionCallbackInfo<Value>& args) {
   AsyncWrap* wrap;
   args.GetReturnValue().Set(AsyncWrap::PROVIDER_NONE);
-  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
   args.GetReturnValue().Set(wrap->provider_type());
 }
 
@@ -539,6 +548,7 @@
 }
 
 void AsyncWrap::EmitTraceEventDestroy() {
+#if 0
   switch (provider_type()) {
   #define V(PROVIDER)                                                         \
     case PROVIDER_ ## PROVIDER:                                               \
@@ -551,6 +561,7 @@
     default:
       UNREACHABLE();
   }
+#endif
 }
 
 void AsyncWrap::EmitDestroy(Environment* env, double async_id) {
@@ -607,6 +618,7 @@
     }
   }
 
+#if 0
   switch (provider_type()) {
 #define V(PROVIDER)                                                           \
     case PROVIDER_ ## PROVIDER:                                               \
@@ -628,7 +640,7 @@
     default:
       UNREACHABLE();
   }
-
+#endif
   if (silent) return;
 
   EmitAsyncInit(env(), resource,
diff -r -u --color up/node/src/base_object-inl.h nw/node/src/base_object-inl.h
--- up/node/src/base_object-inl.h	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/base_object-inl.h	2024-08-26 19:33:04.970595385 +0000
@@ -132,19 +132,18 @@
 
 template <int Field>
 void BaseObject::InternalFieldGet(
-    v8::Local<v8::String> property,
-    const v8::PropertyCallbackInfo<v8::Value>& info) {
-  info.GetReturnValue().Set(
-      info.This()->GetInternalField(Field).As<v8::Value>());
+    const v8::FunctionCallbackInfo<v8::Value>& args) {
+  args.GetReturnValue().Set(
+      args.This()->GetInternalField(Field).As<v8::Value>());
 }
 
-template <int Field, bool (v8::Value::* typecheck)() const>
-void BaseObject::InternalFieldSet(v8::Local<v8::String> property,
-                                  v8::Local<v8::Value> value,
-                                  const v8::PropertyCallbackInfo<void>& info) {
+template <int Field, bool (v8::Value::*typecheck)() const>
+void BaseObject::InternalFieldSet(
+    const v8::FunctionCallbackInfo<v8::Value>& args) {
+  v8::Local<v8::Value> value = args[0];
   // This could be e.g. value->IsFunction().
   CHECK(((*value)->*typecheck)());
-  info.This()->SetInternalField(Field, value);
+  args.This()->SetInternalField(Field, value);
 }
 
 bool BaseObject::has_pointer_data() const {
diff -r -u --color up/node/src/base_object.h nw/node/src/base_object.h
--- up/node/src/base_object.h	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/base_object.h	2024-08-26 19:33:04.970595385 +0000
@@ -111,12 +111,9 @@
 
   // Setter/Getter pair for internal fields that can be passed to SetAccessor.
   template <int Field>
-  static void InternalFieldGet(v8::Local<v8::String> property,
-                               const v8::PropertyCallbackInfo<v8::Value>& info);
+  static void InternalFieldGet(const v8::FunctionCallbackInfo<v8::Value>& args);
   template <int Field, bool (v8::Value::*typecheck)() const>
-  static void InternalFieldSet(v8::Local<v8::String> property,
-                               v8::Local<v8::Value> value,
-                               const v8::PropertyCallbackInfo<void>& info);
+  static void InternalFieldSet(const v8::FunctionCallbackInfo<v8::Value>& args);
 
   // This is a bit of a hack. See the override in async_wrap.cc for details.
   virtual bool IsDoneInitializing() const;
diff -r -u --color up/node/src/cares_wrap.cc nw/node/src/cares_wrap.cc
--- up/node/src/cares_wrap.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/cares_wrap.cc	2024-08-26 19:33:04.970595385 +0000
@@ -1404,7 +1404,7 @@
 static void Query(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   ChannelWrap* channel;
-  ASSIGN_OR_RETURN_UNWRAP(&channel, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&channel, args.This());
 
   CHECK_EQ(false, args.IsConstructCall());
   CHECK(args[0]->IsObject());
@@ -1664,7 +1664,7 @@
 void GetServers(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   ChannelWrap* channel;
-  ASSIGN_OR_RETURN_UNWRAP(&channel, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&channel, args.This());
 
   Local<Array> server_array = Array::New(env->isolate());
 
@@ -1702,7 +1702,7 @@
 void SetServers(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   ChannelWrap* channel;
-  ASSIGN_OR_RETURN_UNWRAP(&channel, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&channel, args.This());
 
   if (channel->active_query_count()) {
     return args.GetReturnValue().Set(DNS_ESETSRVPENDING);
@@ -1783,7 +1783,7 @@
 void SetLocalAddress(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   ChannelWrap* channel;
-  ASSIGN_OR_RETURN_UNWRAP(&channel, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&channel, args.This());
 
   CHECK_EQ(args.Length(), 2);
   CHECK(args[0]->IsString());
@@ -1846,7 +1846,7 @@
 
 void Cancel(const FunctionCallbackInfo<Value>& args) {
   ChannelWrap* channel;
-  ASSIGN_OR_RETURN_UNWRAP(&channel, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&channel, args.This());
 
   TRACE_EVENT_INSTANT0(TRACING_CATEGORY_NODE2(dns, native),
       "cancel", TRACE_EVENT_SCOPE_THREAD);
diff -r -u --color up/node/src/crypto/crypto_cipher.cc nw/node/src/crypto/crypto_cipher.cc
--- up/node/src/crypto/crypto_cipher.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/crypto/crypto_cipher.cc	2024-08-26 19:33:04.970595385 +0000
@@ -438,7 +438,7 @@
 
 void CipherBase::Init(const FunctionCallbackInfo<Value>& args) {
   CipherBase* cipher;
-  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.This());
   Environment* env = Environment::GetCurrent(args);
 
   CHECK_GE(args.Length(), 3);
@@ -510,7 +510,7 @@
 
 void CipherBase::InitIv(const FunctionCallbackInfo<Value>& args) {
   CipherBase* cipher;
-  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.This());
   Environment* env = cipher->env();
 
   CHECK_GE(args.Length(), 4);
@@ -645,7 +645,7 @@
 void CipherBase::GetAuthTag(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   CipherBase* cipher;
-  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.This());
 
   // Only callable after Final and if encrypting.
   if (cipher->ctx_ ||
@@ -661,7 +661,7 @@
 
 void CipherBase::SetAuthTag(const FunctionCallbackInfo<Value>& args) {
   CipherBase* cipher;
-  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.This());
   Environment* env = Environment::GetCurrent(args);
 
   if (!cipher->ctx_ ||
@@ -774,7 +774,7 @@
 
 void CipherBase::SetAAD(const FunctionCallbackInfo<Value>& args) {
   CipherBase* cipher;
-  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.This());
   Environment* env = Environment::GetCurrent(args);
 
   CHECK_EQ(args.Length(), 2);
@@ -887,7 +887,7 @@
 
 void CipherBase::SetAutoPadding(const FunctionCallbackInfo<Value>& args) {
   CipherBase* cipher;
-  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.This());
 
   bool b = cipher->SetAutoPadding(args.Length() < 1 || args[0]->IsTrue());
   args.GetReturnValue().Set(b);  // Possibly report invalid state failure
@@ -962,7 +962,7 @@
   Environment* env = Environment::GetCurrent(args);
 
   CipherBase* cipher;
-  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.This());
   if (cipher->ctx_ == nullptr)
     return THROW_ERR_CRYPTO_INVALID_STATE(env);
 
diff -r -u --color up/node/src/crypto/crypto_context.cc nw/node/src/crypto/crypto_context.cc
--- up/node/src/crypto/crypto_context.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/crypto/crypto_context.cc	2024-08-26 19:33:04.974595383 +0000
@@ -422,7 +422,7 @@
 
 void SecureContext::Init(const FunctionCallbackInfo<Value>& args) {
   SecureContext* sc;
-  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&sc, args.This());
   Environment* env = sc->env();
 
   CHECK_EQ(args.Length(), 3);
@@ -595,7 +595,7 @@
   Environment* env = Environment::GetCurrent(args);
 
   SecureContext* sc;
-  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&sc, args.This());
 
   CHECK_GE(args.Length(), 1);  // Private key argument is mandatory
 
@@ -626,7 +626,7 @@
 
 void SecureContext::SetSigalgs(const FunctionCallbackInfo<Value>& args) {
   SecureContext* sc;
-  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&sc, args.This());
   Environment* env = sc->env();
   ClearErrorOnReturn clear_error_on_return;
 
@@ -644,7 +644,7 @@
   Environment* env = Environment::GetCurrent(args);
 
   SecureContext* sc;
-  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&sc, args.This());
 
   CHECK_EQ(args.Length(), 2);
 
@@ -707,7 +707,7 @@
   Environment* env = Environment::GetCurrent(args);
 
   SecureContext* sc;
-  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&sc, args.This());
 
   CHECK_GE(args.Length(), 1);  // Certificate argument is mandatory
 
@@ -734,7 +734,7 @@
   Environment* env = Environment::GetCurrent(args);
 
   SecureContext* sc;
-  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&sc, args.This());
 
   CHECK_GE(args.Length(), 1);  // CA certificate argument is mandatory
 
@@ -771,7 +771,7 @@
   Environment* env = Environment::GetCurrent(args);
 
   SecureContext* sc;
-  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&sc, args.This());
 
   CHECK_GE(args.Length(), 1);  // CRL argument is mandatory
 
@@ -790,7 +790,7 @@
 
 void SecureContext::AddRootCerts(const FunctionCallbackInfo<Value>& args) {
   SecureContext* sc;
-  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&sc, args.This());
   sc->SetRootCerts();
 }
 
@@ -798,7 +798,7 @@
   // BoringSSL doesn't allow API config of TLS1.3 cipher suites.
 #ifndef OPENSSL_IS_BORINGSSL
   SecureContext* sc;
-  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&sc, args.This());
   Environment* env = sc->env();
   ClearErrorOnReturn clear_error_on_return;
 
@@ -813,7 +813,7 @@
 
 void SecureContext::SetCiphers(const FunctionCallbackInfo<Value>& args) {
   SecureContext* sc;
-  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&sc, args.This());
   Environment* env = sc->env();
   ClearErrorOnReturn clear_error_on_return;
 
@@ -837,7 +837,7 @@
 
 void SecureContext::SetECDHCurve(const FunctionCallbackInfo<Value>& args) {
   SecureContext* sc;
-  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&sc, args.This());
   Environment* env = sc->env();
 
   CHECK_GE(args.Length(), 1);  // ECDH curve name argument is mandatory
@@ -899,7 +899,7 @@
 
 void SecureContext::SetMinProto(const FunctionCallbackInfo<Value>& args) {
   SecureContext* sc;
-  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&sc, args.This());
 
   CHECK_EQ(args.Length(), 1);
   CHECK(args[0]->IsInt32());
@@ -911,7 +911,7 @@
 
 void SecureContext::SetMaxProto(const FunctionCallbackInfo<Value>& args) {
   SecureContext* sc;
-  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&sc, args.This());
 
   CHECK_EQ(args.Length(), 1);
   CHECK(args[0]->IsInt32());
@@ -923,7 +923,7 @@
 
 void SecureContext::GetMinProto(const FunctionCallbackInfo<Value>& args) {
   SecureContext* sc;
-  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&sc, args.This());
 
   CHECK_EQ(args.Length(), 0);
 
@@ -934,7 +934,7 @@
 
 void SecureContext::GetMaxProto(const FunctionCallbackInfo<Value>& args) {
   SecureContext* sc;
-  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&sc, args.This());
 
   CHECK_EQ(args.Length(), 0);
 
@@ -946,7 +946,7 @@
 void SecureContext::SetOptions(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   SecureContext* sc;
-  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&sc, args.This());
 
   CHECK_GE(args.Length(), 1);
   CHECK(args[0]->IsNumber());
@@ -960,7 +960,7 @@
 void SecureContext::SetSessionIdContext(
     const FunctionCallbackInfo<Value>& args) {
   SecureContext* sc;
-  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&sc, args.This());
   Environment* env = sc->env();
 
   CHECK_GE(args.Length(), 1);
@@ -992,7 +992,7 @@
 
 void SecureContext::SetSessionTimeout(const FunctionCallbackInfo<Value>& args) {
   SecureContext* sc;
-  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&sc, args.This());
 
   CHECK_GE(args.Length(), 1);
   CHECK(args[0]->IsInt32());
@@ -1003,7 +1003,7 @@
 
 void SecureContext::Close(const FunctionCallbackInfo<Value>& args) {
   SecureContext* sc;
-  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&sc, args.This());
   sc->Reset();
 }
 
@@ -1015,7 +1015,7 @@
   bool ret = false;
 
   SecureContext* sc;
-  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&sc, args.This());
   ClearErrorOnReturn clear_error_on_return;
 
   if (args.Length() < 1) {
@@ -1124,7 +1124,7 @@
   CHECK(args[0]->IsString());
 
   SecureContext* sc;
-  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&sc, args.This());
 
   MarkPopErrorOnReturn mark_pop_error_on_return;
 
@@ -1161,7 +1161,7 @@
 
 void SecureContext::GetTicketKeys(const FunctionCallbackInfo<Value>& args) {
   SecureContext* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
 
   Local<Object> buff;
   if (!Buffer::New(wrap->env(), 48).ToLocal(&buff))
@@ -1176,7 +1176,7 @@
 
 void SecureContext::SetTicketKeys(const FunctionCallbackInfo<Value>& args) {
   SecureContext* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
 
   CHECK_GE(args.Length(), 1);  // Ticket keys argument is mandatory
   CHECK(args[0]->IsArrayBufferView());
@@ -1196,7 +1196,7 @@
 void SecureContext::EnableTicketKeyCallback(
     const FunctionCallbackInfo<Value>& args) {
   SecureContext* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
 
   SSL_CTX_set_tlsext_ticket_key_cb(wrap->ctx_.get(), TicketKeyCallback);
 }
@@ -1350,7 +1350,7 @@
 template <bool primary>
 void SecureContext::GetCertificate(const FunctionCallbackInfo<Value>& args) {
   SecureContext* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
   Environment* env = wrap->env();
   X509* cert;
 
diff -r -u --color up/node/src/crypto/crypto_dh.cc nw/node/src/crypto/crypto_dh.cc
--- up/node/src/crypto/crypto_dh.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/crypto/crypto_dh.cc	2024-08-26 19:33:04.974595383 +0000
@@ -292,7 +292,7 @@
   Environment* env = Environment::GetCurrent(args);
 
   DiffieHellman* diffieHellman;
-  ASSIGN_OR_RETURN_UNWRAP(&diffieHellman, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&diffieHellman, args.This());
 
   if (!DH_generate_key(diffieHellman->dh_.get())) {
     return ThrowCryptoError(env, ERR_get_error(), "Key generation failed");
@@ -327,7 +327,7 @@
   Environment* env = Environment::GetCurrent(args);
 
   DiffieHellman* dh;
-  ASSIGN_OR_RETURN_UNWRAP(&dh, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&dh, args.This());
 
   const BIGNUM* num = get_field(dh->dh_.get());
   if (num == nullptr)
@@ -388,7 +388,7 @@
   Environment* env = Environment::GetCurrent(args);
 
   DiffieHellman* diffieHellman;
-  ASSIGN_OR_RETURN_UNWRAP(&diffieHellman, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&diffieHellman, args.This());
 
   ClearErrorOnReturn clear_error_on_return;
 
@@ -447,7 +447,7 @@
                            int (*set_field)(DH*, BIGNUM*), const char* what) {
   Environment* env = Environment::GetCurrent(args);
   DiffieHellman* dh;
-  ASSIGN_OR_RETURN_UNWRAP(&dh, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&dh, args.This());
   CHECK_EQ(args.Length(), 1);
   ArrayBufferOrViewContents<unsigned char> buf(args[0]);
   if (UNLIKELY(!buf.CheckSizeInt32()))
@@ -473,7 +473,7 @@
   HandleScope scope(args.GetIsolate());
 
   DiffieHellman* diffieHellman;
-  ASSIGN_OR_RETURN_UNWRAP(&diffieHellman, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&diffieHellman, args.This());
 
   args.GetReturnValue().Set(diffieHellman->verifyError_);
 }
diff -r -u --color up/node/src/crypto/crypto_ec.cc nw/node/src/crypto/crypto_ec.cc
--- up/node/src/crypto/crypto_ec.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/crypto/crypto_ec.cc	2024-08-26 19:33:04.974595383 +0000
@@ -155,7 +155,7 @@
   Environment* env = Environment::GetCurrent(args);
 
   ECDH* ecdh;
-  ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.This());
 
   if (!EC_KEY_generate_key(ecdh->key_.get()))
     return THROW_ERR_CRYPTO_OPERATION_FAILED(env, "Failed to generate key");
@@ -196,7 +196,7 @@
   CHECK(IsAnyBufferSource(args[0]));
 
   ECDH* ecdh;
-  ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.This());
 
   MarkPopErrorOnReturn mark_pop_error_on_return;
 
@@ -240,7 +240,7 @@
   CHECK_EQ(args.Length(), 1);
 
   ECDH* ecdh;
-  ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.This());
 
   const EC_GROUP* group = EC_KEY_get0_group(ecdh->key_.get());
   const EC_POINT* pub = EC_KEY_get0_public_key(ecdh->key_.get());
@@ -263,7 +263,7 @@
   Environment* env = Environment::GetCurrent(args);
 
   ECDH* ecdh;
-  ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.This());
 
   const BIGNUM* b = EC_KEY_get0_private_key(ecdh->key_.get());
   if (b == nullptr)
@@ -289,7 +289,7 @@
   Environment* env = Environment::GetCurrent(args);
 
   ECDH* ecdh;
-  ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.This());
 
   ArrayBufferOrViewContents<unsigned char> priv_buffer(args[0]);
   if (UNLIKELY(!priv_buffer.CheckSizeInt32()))
@@ -345,7 +345,7 @@
   Environment* env = Environment::GetCurrent(args);
 
   ECDH* ecdh;
-  ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.This());
 
   CHECK(IsAnyBufferSource(args[0]));
 
diff -r -u --color up/node/src/crypto/crypto_hash.cc nw/node/src/crypto/crypto_hash.cc
--- up/node/src/crypto/crypto_hash.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/crypto/crypto_hash.cc	2024-08-26 19:33:04.974595383 +0000
@@ -378,7 +378,7 @@
   Environment* env = Environment::GetCurrent(args);
 
   Hash* hash;
-  ASSIGN_OR_RETURN_UNWRAP(&hash, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&hash, args.This());
 
   enum encoding encoding = BUFFER;
   if (args.Length() >= 1) {
diff -r -u --color up/node/src/crypto/crypto_hmac.cc nw/node/src/crypto/crypto_hmac.cc
--- up/node/src/crypto/crypto_hmac.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/crypto/crypto_hmac.cc	2024-08-26 19:33:04.974595383 +0000
@@ -85,7 +85,7 @@
 
 void Hmac::HmacInit(const FunctionCallbackInfo<Value>& args) {
   Hmac* hmac;
-  ASSIGN_OR_RETURN_UNWRAP(&hmac, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&hmac, args.This());
   Environment* env = hmac->env();
 
   const node::Utf8Value hash_type(env->isolate(), args[0]);
@@ -114,7 +114,7 @@
   Environment* env = Environment::GetCurrent(args);
 
   Hmac* hmac;
-  ASSIGN_OR_RETURN_UNWRAP(&hmac, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&hmac, args.This());
 
   enum encoding encoding = BUFFER;
   if (args.Length() >= 1) {
diff -r -u --color up/node/src/crypto/crypto_keys.cc nw/node/src/crypto/crypto_keys.cc
--- up/node/src/crypto/crypto_keys.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/crypto/crypto_keys.cc	2024-08-26 19:33:04.974595383 +0000
@@ -971,7 +971,7 @@
 
 void KeyObjectHandle::Init(const FunctionCallbackInfo<Value>& args) {
   KeyObjectHandle* key;
-  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&key, args.This());
   MarkPopErrorOnReturn mark_pop_error_on_return;
 
   CHECK(args[0]->IsInt32());
@@ -1015,7 +1015,7 @@
 void KeyObjectHandle::InitJWK(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   KeyObjectHandle* key;
-  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&key, args.This());
   MarkPopErrorOnReturn mark_pop_error_on_return;
 
   // The argument must be a JavaScript object that we will inspect
@@ -1054,7 +1054,7 @@
 void KeyObjectHandle::InitECRaw(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   KeyObjectHandle* key;
-  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&key, args.This());
 
   CHECK(args[0]->IsString());
   Utf8Value name(env->isolate(), args[0]);
@@ -1092,7 +1092,7 @@
 void KeyObjectHandle::InitEDRaw(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   KeyObjectHandle* key;
-  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&key, args.This());
 
   CHECK(args[0]->IsString());
   Utf8Value name(env->isolate(), args[0]);
@@ -1134,7 +1134,7 @@
 void KeyObjectHandle::Equals(const FunctionCallbackInfo<Value>& args) {
   KeyObjectHandle* self_handle;
   KeyObjectHandle* arg_handle;
-  ASSIGN_OR_RETURN_UNWRAP(&self_handle, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&self_handle, args.This());
   ASSIGN_OR_RETURN_UNWRAP(&arg_handle, args[0].As<Object>());
   std::shared_ptr<KeyObjectData> key = self_handle->Data();
   std::shared_ptr<KeyObjectData> key2 = arg_handle->Data();
@@ -1182,7 +1182,7 @@
 void KeyObjectHandle::GetKeyDetail(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   KeyObjectHandle* key;
-  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&key, args.This());
 
   CHECK(args[0]->IsObject());
 
@@ -1235,7 +1235,7 @@
 void KeyObjectHandle::GetAsymmetricKeyType(
     const FunctionCallbackInfo<Value>& args) {
   KeyObjectHandle* key;
-  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&key, args.This());
 
   args.GetReturnValue().Set(key->GetAsymmetricKeyType());
 }
@@ -1263,7 +1263,7 @@
 
 void KeyObjectHandle::CheckEcKeyData(const FunctionCallbackInfo<Value>& args) {
   KeyObjectHandle* key;
-  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&key, args.This());
 
   args.GetReturnValue().Set(key->CheckEcKeyData());
 }
@@ -1271,14 +1271,14 @@
 void KeyObjectHandle::GetSymmetricKeySize(
     const FunctionCallbackInfo<Value>& args) {
   KeyObjectHandle* key;
-  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&key, args.This());
   args.GetReturnValue().Set(
       static_cast<uint32_t>(key->Data()->GetSymmetricKeySize()));
 }
 
 void KeyObjectHandle::Export(const FunctionCallbackInfo<Value>& args) {
   KeyObjectHandle* key;
-  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&key, args.This());
 
   KeyType type = key->Data()->GetKeyType();
 
@@ -1328,7 +1328,7 @@
     const v8::FunctionCallbackInfo<v8::Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   KeyObjectHandle* key;
-  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&key, args.This());
 
   CHECK(args[0]->IsObject());
   CHECK(args[1]->IsBoolean());
diff -r -u --color up/node/src/crypto/crypto_sig.cc nw/node/src/crypto/crypto_sig.cc
--- up/node/src/crypto/crypto_sig.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/crypto/crypto_sig.cc	2024-08-26 19:33:04.974595383 +0000
@@ -371,7 +371,7 @@
 void Sign::SignInit(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   Sign* sign;
-  ASSIGN_OR_RETURN_UNWRAP(&sign, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&sign, args.This());
 
   const node::Utf8Value sign_type(args.GetIsolate(), args[0]);
   crypto::CheckThrow(env, sign->Init(*sign_type));
@@ -414,7 +414,7 @@
 void Sign::SignFinal(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   Sign* sign;
-  ASSIGN_OR_RETURN_UNWRAP(&sign, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&sign, args.This());
 
   ClearErrorOnReturn clear_error_on_return;
 
@@ -492,7 +492,7 @@
 void Verify::VerifyInit(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   Verify* verify;
-  ASSIGN_OR_RETURN_UNWRAP(&verify, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&verify, args.This());
 
   const node::Utf8Value verify_type(args.GetIsolate(), args[0]);
   crypto::CheckThrow(env, verify->Init(*verify_type));
@@ -545,7 +545,7 @@
   ClearErrorOnReturn clear_error_on_return;
 
   Verify* verify;
-  ASSIGN_OR_RETURN_UNWRAP(&verify, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&verify, args.This());
 
   unsigned int offset = 0;
   ManagedEVPPKey pkey =
diff -r -u --color up/node/src/crypto/crypto_tls.cc nw/node/src/crypto/crypto_tls.cc
--- up/node/src/crypto/crypto_tls.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/crypto/crypto_tls.cc	2024-08-26 19:33:04.974595383 +0000
@@ -506,7 +506,7 @@
 
 void TLSWrap::Receive(const FunctionCallbackInfo<Value>& args) {
   TLSWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
 
   ArrayBufferViewContents<char> buffer(args[0]);
   const char* data = buffer.data();
@@ -528,7 +528,7 @@
 
 void TLSWrap::Start(const FunctionCallbackInfo<Value>& args) {
   TLSWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
 
   CHECK(!wrap->started_);
   wrap->started_ = true;
@@ -1155,7 +1155,7 @@
 
 void TLSWrap::SetVerifyMode(const FunctionCallbackInfo<Value>& args) {
   TLSWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
 
   CHECK_EQ(args.Length(), 2);
   CHECK(args[0]->IsBoolean());
@@ -1187,7 +1187,7 @@
 
 void TLSWrap::EnableSessionCallbacks(const FunctionCallbackInfo<Value>& args) {
   TLSWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
   CHECK_NOT_NULL(wrap->ssl_);
   wrap->enable_session_callbacks();
 
@@ -1203,7 +1203,7 @@
 
 void TLSWrap::EnableKeylogCallback(const FunctionCallbackInfo<Value>& args) {
   TLSWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
   CHECK(wrap->sc_);
   wrap->sc_->SetKeylogCallback(KeylogCallback);
 }
@@ -1220,7 +1220,7 @@
 
 void TLSWrap::EnableTrace(const FunctionCallbackInfo<Value>& args) {
   TLSWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
 
 #if HAVE_SSL_TRACE
   if (wrap->ssl_) {
@@ -1243,7 +1243,7 @@
 
 void TLSWrap::DestroySSL(const FunctionCallbackInfo<Value>& args) {
   TLSWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
   wrap->Destroy();
   Debug(wrap, "DestroySSL() finished");
 }
@@ -1272,7 +1272,7 @@
 
 void TLSWrap::EnableCertCb(const FunctionCallbackInfo<Value>& args) {
   TLSWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
   wrap->WaitForCertCb(OnClientHelloParseEnd, wrap);
 }
 
@@ -1289,7 +1289,7 @@
 
 void TLSWrap::EnableALPNCb(const FunctionCallbackInfo<Value>& args) {
   TLSWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
   wrap->alpn_callback_enabled_ = true;
 
   SSL* ssl = wrap->ssl_.get();
@@ -1301,7 +1301,7 @@
   Environment* env = Environment::GetCurrent(args);
 
   TLSWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
 
   CHECK_NOT_NULL(wrap->ssl_);
 
@@ -1317,7 +1317,7 @@
   Environment* env = Environment::GetCurrent(args);
 
   TLSWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
 
   CHECK_EQ(args.Length(), 1);
   CHECK(args[0]->IsString());
@@ -1382,7 +1382,7 @@
 
 void TLSWrap::SetPskIdentityHint(const FunctionCallbackInfo<Value>& args) {
   TLSWrap* p;
-  ASSIGN_OR_RETURN_UNWRAP(&p, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&p, args.This());
   CHECK_NOT_NULL(p->ssl_);
 
   Environment* env = p->env();
@@ -1399,7 +1399,7 @@
 
 void TLSWrap::EnablePskCallback(const FunctionCallbackInfo<Value>& args) {
   TLSWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
   CHECK_NOT_NULL(wrap->ssl_);
 
   SSL_set_psk_server_callback(wrap->ssl_.get(), PskServerCallback);
@@ -1533,7 +1533,7 @@
 void TLSWrap::CertCbDone(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   TLSWrap* w;
-  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
 
   CHECK(w->is_waiting_cert_cb() && w->cert_cb_running_);
 
@@ -1578,7 +1578,7 @@
 
 void TLSWrap::SetALPNProtocols(const FunctionCallbackInfo<Value>& args) {
   TLSWrap* w;
-  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
   Environment* env = w->env();
   if (args.Length() < 1 || !Buffer::HasInstance(args[0]))
     return env->ThrowTypeError("Must give a Buffer as first argument");
@@ -1597,7 +1597,7 @@
 
 void TLSWrap::GetPeerCertificate(const FunctionCallbackInfo<Value>& args) {
   TLSWrap* w;
-  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
   Environment* env = w->env();
 
   bool abbreviated = args.Length() < 1 || !args[0]->IsTrue();
@@ -1613,7 +1613,7 @@
 
 void TLSWrap::GetPeerX509Certificate(const FunctionCallbackInfo<Value>& args) {
   TLSWrap* w;
-  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
   Environment* env = w->env();
 
   X509Certificate::GetPeerCertificateFlag flag = w->is_server()
@@ -1627,7 +1627,7 @@
 
 void TLSWrap::GetCertificate(const FunctionCallbackInfo<Value>& args) {
   TLSWrap* w;
-  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
   Environment* env = w->env();
 
   Local<Value> ret;
@@ -1637,7 +1637,7 @@
 
 void TLSWrap::GetX509Certificate(const FunctionCallbackInfo<Value>& args) {
   TLSWrap* w;
-  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
   Environment* env = w->env();
   Local<Value> ret;
   if (X509Certificate::GetCert(env, w->ssl_).ToLocal(&ret))
@@ -1648,7 +1648,7 @@
   Environment* env = Environment::GetCurrent(args);
 
   TLSWrap* w;
-  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
 
   // We cannot just pass nullptr to SSL_get_finished()
   // because it would further be propagated to memcpy(),
@@ -1679,7 +1679,7 @@
   Environment* env = Environment::GetCurrent(args);
 
   TLSWrap* w;
-  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
 
   // We cannot just pass nullptr to SSL_get_peer_finished()
   // because it would further be propagated to memcpy(),
@@ -1710,7 +1710,7 @@
   Environment* env = Environment::GetCurrent(args);
 
   TLSWrap* w;
-  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
 
   SSL_SESSION* sess = SSL_get_session(w->ssl_.get());
   if (sess == nullptr)
@@ -1739,7 +1739,7 @@
   Environment* env = Environment::GetCurrent(args);
 
   TLSWrap* w;
-  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
 
   if (args.Length() < 1)
     return THROW_ERR_MISSING_ARGS(env, "Session argument is mandatory");
@@ -1756,7 +1756,7 @@
 
 void TLSWrap::IsSessionReused(const FunctionCallbackInfo<Value>& args) {
   TLSWrap* w;
-  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
   bool yes = SSL_session_reused(w->ssl_.get());
   args.GetReturnValue().Set(yes);
 }
@@ -1764,7 +1764,7 @@
 void TLSWrap::VerifyError(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   TLSWrap* w;
-  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
 
   // XXX(bnoordhuis) The UNABLE_TO_GET_ISSUER_CERT error when there is no
   // peer certificate is questionable but it's compatible with what was
@@ -1792,14 +1792,14 @@
 void TLSWrap::GetCipher(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   TLSWrap* w;
-  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
   args.GetReturnValue().Set(
       GetCipherInfo(env, w->ssl_).FromMaybe(Local<Object>()));
 }
 
 void TLSWrap::LoadSession(const FunctionCallbackInfo<Value>& args) {
   TLSWrap* w;
-  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
 
   // TODO(@sam-github) check arg length and types in js, and CHECK in c++
   if (args.Length() >= 1 && Buffer::HasInstance(args[0])) {
@@ -1816,7 +1816,7 @@
 void TLSWrap::GetSharedSigalgs(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   TLSWrap* w;
-  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
 
   SSL* ssl = w->ssl_.get();
   int nsig = SSL_get_shared_sigalgs(ssl, 0, nullptr, nullptr, nullptr, nullptr,
@@ -1898,7 +1898,7 @@
 
   Environment* env = Environment::GetCurrent(args);
   TLSWrap* w;
-  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
 
   uint32_t olen = args[0].As<Uint32>()->Value();
   Utf8Value label(env->isolate(), args[1]);
@@ -1937,13 +1937,13 @@
 
 void TLSWrap::EndParser(const FunctionCallbackInfo<Value>& args) {
   TLSWrap* w;
-  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
   w->hello_parser_.End();
 }
 
 void TLSWrap::Renegotiate(const FunctionCallbackInfo<Value>& args) {
   TLSWrap* w;
-  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
   ClearErrorOnReturn clear_error_on_return;
   if (SSL_renegotiate(w->ssl_.get()) != 1)
     return ThrowCryptoError(w->env(), ERR_get_error());
@@ -1951,7 +1951,7 @@
 
 void TLSWrap::GetTLSTicket(const FunctionCallbackInfo<Value>& args) {
   TLSWrap* w;
-  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
   Environment* env = w->env();
 
   SSL_SESSION* sess = SSL_get_session(w->ssl_.get());
@@ -1971,14 +1971,14 @@
 
 void TLSWrap::NewSessionDone(const FunctionCallbackInfo<Value>& args) {
   TLSWrap* w;
-  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
   w->awaiting_new_session_ = false;
   w->NewSessionDoneCb();
 }
 
 void TLSWrap::SetOCSPResponse(const FunctionCallbackInfo<Value>& args) {
   TLSWrap* w;
-  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
   Environment* env = w->env();
 
   if (args.Length() < 1)
@@ -1991,14 +1991,14 @@
 
 void TLSWrap::RequestOCSP(const FunctionCallbackInfo<Value>& args) {
   TLSWrap* w;
-  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
 
   SSL_set_tlsext_status_type(w->ssl_.get(), TLSEXT_STATUSTYPE_ocsp);
 }
 
 void TLSWrap::GetEphemeralKeyInfo(const FunctionCallbackInfo<Value>& args) {
   TLSWrap* w;
-  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
   Environment* env = Environment::GetCurrent(args);
 
   CHECK(w->ssl_);
@@ -2017,7 +2017,7 @@
 void TLSWrap::GetProtocol(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   TLSWrap* w;
-  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
   args.GetReturnValue().Set(
       OneByteString(env->isolate(), SSL_get_version(w->ssl_.get())));
 }
@@ -2025,7 +2025,7 @@
 void TLSWrap::GetALPNNegotiatedProto(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   TLSWrap* w;
-  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
 
   const unsigned char* alpn_proto;
   unsigned int alpn_proto_len;
@@ -2051,7 +2051,7 @@
 void TLSWrap::WritesIssuedByPrevListenerDone(
     const FunctionCallbackInfo<Value>& args) {
   TLSWrap* w;
-  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
 
   Debug(w, "WritesIssuedByPrevListenerDone is called");
   w->has_active_write_issued_by_prev_listener_ = false;
@@ -2076,7 +2076,7 @@
   CHECK(args.Length() >= 1 && args[0]->IsNumber());
   Environment* env = Environment::GetCurrent(args);
   TLSWrap* w;
-  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
   int rv = SSL_set_max_send_fragment(
       w->ssl_.get(),
       args[0]->Int32Value(env->context()).FromJust());
diff -r -u --color up/node/src/crypto/crypto_util.h nw/node/src/crypto/crypto_util.h
--- up/node/src/crypto/crypto_util.h	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/crypto/crypto_util.h	2024-08-26 19:33:04.974595383 +0000
@@ -136,7 +136,7 @@
             void (*callback)(T*, const v8::FunctionCallbackInfo<v8::Value>&,
                              const char*, size_t)) {
   T* ctx;
-  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.This());
 
   if (args[0]->IsString()) {
     StringBytes::InlineDecoder decoder;
@@ -412,7 +412,7 @@
     Environment* env = Environment::GetCurrent(args);
 
     CryptoJob<CryptoJobTraits>* job;
-    ASSIGN_OR_RETURN_UNWRAP(&job, args.Holder());
+    ASSIGN_OR_RETURN_UNWRAP(&job, args.This());
     if (job->mode() == kCryptoJobAsync)
       return job->ScheduleWork();
 
diff -r -u --color up/node/src/crypto/crypto_x509.cc nw/node/src/crypto/crypto_x509.cc
--- up/node/src/crypto/crypto_x509.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/crypto/crypto_x509.cc	2024-08-26 19:33:04.974595383 +0000
@@ -56,7 +56,7 @@
 void Fingerprint(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   X509Certificate* cert;
-  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&cert, args.This());
   Local<Value> ret;
   if (GetFingerprintDigest(env, algo(), cert->get()).ToLocal(&ret))
     args.GetReturnValue().Set(ret);
@@ -208,7 +208,7 @@
 static void ReturnPropertyThroughBIO(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   X509Certificate* cert;
-  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&cert, args.This());
   BIOPointer bio(BIO_new(BIO_s_mem()));
   CHECK(bio);
   Local<Value> ret;
@@ -244,7 +244,7 @@
 static void ReturnProperty(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   X509Certificate* cert;
-  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&cert, args.This());
   Local<Value> ret;
   if (Property(env, cert->get()).ToLocal(&ret)) args.GetReturnValue().Set(ret);
 }
@@ -264,7 +264,7 @@
 void X509Certificate::PublicKey(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   X509Certificate* cert;
-  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&cert, args.This());
 
   // TODO(tniessen): consider checking X509_get_pubkey() when the
   // X509Certificate object is being created.
@@ -283,7 +283,7 @@
 void X509Certificate::Pem(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   X509Certificate* cert;
-  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&cert, args.This());
   BIOPointer bio(BIO_new(BIO_s_mem()));
   CHECK(bio);
   if (PEM_write_bio_X509(bio.get(), cert->get()))
@@ -293,14 +293,14 @@
 void X509Certificate::CheckCA(const FunctionCallbackInfo<Value>& args) {
   X509Certificate* cert;
   ClearErrorOnReturn clear_error_on_return;
-  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&cert, args.This());
   args.GetReturnValue().Set(X509_check_ca(cert->get()) == 1);
 }
 
 void X509Certificate::CheckHost(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   X509Certificate* cert;
-  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&cert, args.This());
 
   CHECK(args[0]->IsString());  // name
   CHECK(args[1]->IsUint32());  // flags
@@ -335,7 +335,7 @@
 void X509Certificate::CheckEmail(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   X509Certificate* cert;
-  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&cert, args.This());
 
   CHECK(args[0]->IsString());  // name
   CHECK(args[1]->IsUint32());  // flags
@@ -362,7 +362,7 @@
 void X509Certificate::CheckIP(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   X509Certificate* cert;
-  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&cert, args.This());
 
   CHECK(args[0]->IsString());  // IP
   CHECK(args[1]->IsUint32());  // flags
@@ -385,7 +385,7 @@
 void X509Certificate::CheckIssued(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   X509Certificate* cert;
-  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&cert, args.This());
 
   CHECK(args[0]->IsObject());
   CHECK(X509Certificate::HasInstance(env, args[0].As<Object>()));
@@ -401,7 +401,7 @@
 
 void X509Certificate::CheckPrivateKey(const FunctionCallbackInfo<Value>& args) {
   X509Certificate* cert;
-  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&cert, args.This());
 
   CHECK(args[0]->IsObject());
   KeyObjectHandle* key;
@@ -418,7 +418,7 @@
 
 void X509Certificate::Verify(const FunctionCallbackInfo<Value>& args) {
   X509Certificate* cert;
-  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&cert, args.This());
 
   CHECK(args[0]->IsObject());
   KeyObjectHandle* key;
@@ -436,7 +436,7 @@
 void X509Certificate::ToLegacy(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   X509Certificate* cert;
-  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&cert, args.This());
   ClearErrorOnReturn clear_error_on_return;
   Local<Value> ret;
   if (X509ToObject(env, cert->get()).ToLocal(&ret))
@@ -445,7 +445,7 @@
 
 void X509Certificate::GetIssuerCert(const FunctionCallbackInfo<Value>& args) {
   X509Certificate* cert;
-  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&cert, args.This());
   if (cert->issuer_cert_)
     args.GetReturnValue().Set(cert->issuer_cert_->object());
 }
diff -r -u --color up/node/src/env-inl.h nw/node/src/env-inl.h
--- up/node/src/env-inl.h	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/env-inl.h	2024-08-26 19:33:04.978595383 +0000
@@ -62,31 +62,6 @@
   return event_loop_;
 }
 
-inline void IsolateData::SetCppgcReference(v8::Isolate* isolate,
-                                           v8::Local<v8::Object> object,
-                                           void* wrappable) {
-  v8::CppHeap* heap = isolate->GetCppHeap();
-  CHECK_NOT_NULL(heap);
-  v8::WrapperDescriptor descriptor = heap->wrapper_descriptor();
-  uint16_t required_size = std::max(descriptor.wrappable_instance_index,
-                                    descriptor.wrappable_type_index);
-  CHECK_GT(object->InternalFieldCount(), required_size);
-
-  uint16_t* id_ptr = nullptr;
-  {
-    Mutex::ScopedLock lock(isolate_data_mutex_);
-    auto it =
-        wrapper_data_map_.find(descriptor.embedder_id_for_garbage_collected);
-    CHECK_NE(it, wrapper_data_map_.end());
-    id_ptr = &(it->second->cppgc_id);
-  }
-
-  object->SetAlignedPointerInInternalField(descriptor.wrappable_type_index,
-                                           id_ptr);
-  object->SetAlignedPointerInInternalField(descriptor.wrappable_instance_index,
-                                           wrappable);
-}
-
 inline uint16_t* IsolateData::embedder_id_for_cppgc() const {
   return &(wrapper_data_->cppgc_id);
 }
@@ -226,13 +201,23 @@
 
 inline Environment* Environment::GetCurrent(
     const v8::FunctionCallbackInfo<v8::Value>& info) {
-  return GetCurrent(info.GetIsolate()->GetCurrentContext());
+  Environment* ret = GetCurrent(info.GetIsolate()->GetCurrentContext());
+  if (!ret) { //NWJS#7493: access node var directly from another context
+    node::thread_ctx_st* tls_ctx = (node::thread_ctx_st*)uv_key_get(&node::thread_ctx_key);
+    return tls_ctx->env;
+  }
+  return ret;
 }
 
 template <typename T>
 inline Environment* Environment::GetCurrent(
     const v8::PropertyCallbackInfo<T>& info) {
-  return GetCurrent(info.GetIsolate()->GetCurrentContext());
+  Environment* ret = GetCurrent(info.GetIsolate()->GetCurrentContext());
+  if (!ret) {
+    node::thread_ctx_st* tls_ctx = (node::thread_ctx_st*)uv_key_get(&node::thread_ctx_key);
+    return tls_ctx->env;
+  }
+  return ret;
 }
 
 inline v8::Isolate* Environment::isolate() const {
diff -r -u --color up/node/src/env.cc nw/node/src/env.cc
--- up/node/src/env.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/env.cc	2024-08-26 19:33:04.978595383 +0000
@@ -23,6 +23,7 @@
 #include "util-inl.h"
 #include "v8-cppgc.h"
 #include "v8-profiler.h"
+#include "v8-sandbox.h"  // v8::Object::Wrap(), v8::Object::Unwrap()
 
 #include <algorithm>
 #include <atomic>
@@ -70,9 +71,10 @@
 using v8::Uint32;
 using v8::Undefined;
 using v8::Value;
-using v8::WrapperDescriptor;
 using worker::Worker;
 
+extern bool node_is_nwjs;
+
 int const ContextEmbedderTag::kNodeContextTag = 0x6e6f64;
 void* const ContextEmbedderTag::kNodeContextTagPtr = const_cast<void*>(
     static_cast<const void*>(&ContextEmbedderTag::kNodeContextTag));
@@ -541,36 +543,17 @@
   v8::CppHeap* cpp_heap = isolate->GetCppHeap();
 
   uint16_t cppgc_id = kDefaultCppGCEmebdderID;
-  if (cpp_heap != nullptr) {
-    // The general convention of the wrappable layout for cppgc in the
-    // ecosystem is:
-    // [  0  ] -> embedder id
-    // [  1  ] -> wrappable instance
-    // If the Isolate includes a CppHeap attached by another embedder,
-    // And if they also use the field 0 for the ID, we DCHECK that
-    // the layout matches our layout, and record the embedder ID for cppgc
-    // to avoid accidentally enabling cppgc on non-cppgc-managed wrappers .
-    v8::WrapperDescriptor descriptor = cpp_heap->wrapper_descriptor();
-    if (descriptor.wrappable_type_index == BaseObject::kEmbedderType) {
-      cppgc_id = descriptor.embedder_id_for_garbage_collected;
-      DCHECK_EQ(descriptor.wrappable_instance_index, BaseObject::kSlot);
-    }
-    // If the CppHeap uses the slot we use to put non-cppgc-traced BaseObject
-    // for embedder ID, V8 could accidentally enable cppgc on them. So
-    // safe guard against this.
-    DCHECK_NE(descriptor.wrappable_type_index, BaseObject::kSlot);
-  } else {
-    cpp_heap_ = CppHeap::Create(
-        platform,
-        CppHeapCreateParams{
-            {},
-            WrapperDescriptor(
-                BaseObject::kEmbedderType, BaseObject::kSlot, cppgc_id)});
-    isolate->AttachCppHeap(cpp_heap_.get());
-  }
+
   // We do not care about overflow since we just want this to be different
   // from the cppgc id.
   uint16_t non_cppgc_id = cppgc_id + 1;
+  if (cpp_heap == nullptr) {
+    cpp_heap_ = CppHeap::Create(platform, v8::CppHeapCreateParams{{}});
+    // TODO(joyeecheung): pass it into v8::Isolate::CreateParams and let V8
+    // own it when we can keep the isolate registered/task runner discoverable
+    // during isolate disposal.
+    isolate->AttachCppHeap(cpp_heap_.get());
+  }
 
   {
     // GC could still be run after the IsolateData is destroyed, so we store
@@ -602,11 +585,12 @@
   }
 }
 
-// Public API
+// Deprecated API, embedders should use v8::Object::Wrap() directly instead.
 void SetCppgcReference(Isolate* isolate,
                        Local<Object> object,
                        void* wrappable) {
-  IsolateData::SetCppgcReference(isolate, object, wrappable);
+  v8::Object::Wrap<v8::CppHeapPointerTag::kDefaultTag>(
+      isolate, object, wrappable);
 }
 
 void IsolateData::MemoryInfo(MemoryTracker* tracker) const {
@@ -819,6 +803,7 @@
         isolate_data->worker_context()->env()->builtin_loader());
   } else if (isolate_data->snapshot_data() != nullptr) {
     // ... otherwise, if a snapshot was provided, use its code cache.
+#if 0
     size_t cache_size = isolate_data->snapshot_data()->code_cache.size();
     per_process::Debug(DebugCategory::CODE_CACHE,
                        "snapshot contains %zu code cache\n",
@@ -827,6 +812,7 @@
       builtin_loader()->RefreshCodeCache(
           isolate_data->snapshot_data()->code_cache);
     }
+#endif
   }
 
   // We are supposed to call builtin_loader_.SetEagerCompile() in
@@ -873,11 +859,13 @@
   inspector_agent_ = std::make_unique<inspector::Agent>(this);
 #endif
 
+#if 0
   if (tracing::AgentWriterHandle* writer = GetTracingAgentWriter()) {
     trace_state_observer_ = std::make_unique<TrackingTraceStateObserver>(this);
     if (TracingController* tracing_controller = writer->GetTracingController())
       tracing_controller->AddTraceStateObserver(trace_state_observer_.get());
   }
+#endif
 
   destroy_async_id_list_.reserve(512);
 
@@ -886,6 +874,7 @@
       time_origin_,
       time_origin_timestamp_,
       MAYBE_FIELD_PTR(env_info, performance_state));
+#if 0
 
   if (*TRACE_EVENT_API_GET_CATEGORY_GROUP_ENABLED(
           TRACING_CATEGORY_NODE1(environment)) != 0) {
@@ -902,6 +891,7 @@
                                       "args",
                                       std::move(traced_value));
   }
+#endif
 
   if (options_->experimental_permission) {
     permission()->EnablePermissions();
@@ -939,7 +929,7 @@
 void Environment::InitializeMainContext(Local<Context> context,
                                         const EnvSerializeInfo* env_info) {
   principal_realm_ = std::make_unique<PrincipalRealm>(
-      this, context, MAYBE_FIELD_PTR(env_info, principal_realm));
+     this, context, MAYBE_FIELD_PTR(env_info, principal_realm), node_is_nwjs);
   if (env_info != nullptr) {
     DeserializeProperties(env_info);
   }
@@ -1039,6 +1029,7 @@
 void Environment::InitializeLibuv() {
   HandleScope handle_scope(isolate());
   Context::Scope context_scope(context());
+  uv_initialized_ = true;
 
   CHECK_EQ(0, uv_timer_init(event_loop(), timer_handle()));
   uv_unref(reinterpret_cast<uv_handle_t*>(timer_handle()));
@@ -1501,7 +1492,7 @@
 }
 
 void Environment::ToggleImmediateRef(bool ref) {
-  if (started_cleanup_) return;
+  if (started_cleanup_|| !uv_initialized_) return;
 
   if (ref) {
     // Idle handle is needed only to stop the event loop from blocking in poll.
diff -r -u --color up/node/src/env.h nw/node/src/env.h
--- up/node/src/env.h	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/env.h	2024-08-26 19:33:04.978595383 +0000
@@ -165,10 +165,6 @@
   uint16_t* embedder_id_for_cppgc() const;
   uint16_t* embedder_id_for_non_cppgc() const;
 
-  static inline void SetCppgcReference(v8::Isolate* isolate,
-                                       v8::Local<v8::Object> object,
-                                       void* wrappable);
-
   inline uv_loop_t* event_loop() const;
   inline MultiIsolatePlatform* platform() const;
   inline const SnapshotData* snapshot_data() const;
@@ -1060,6 +1056,7 @@
   void TrackContext(v8::Local<v8::Context> context);
   void UntrackContext(v8::Local<v8::Context> context);
 
+  bool uv_initialized_ = false;
   std::list<binding::DLib> loaded_addons_;
   v8::Isolate* const isolate_;
   IsolateData* const isolate_data_;
diff -r -u --color up/node/src/env_properties.h nw/node/src/env_properties.h
--- up/node/src/env_properties.h	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/env_properties.h	2024-08-26 19:33:04.978595383 +0000
@@ -389,6 +389,7 @@
   V(microtask_queue_ctor_template, v8::FunctionTemplate)                       \
   V(pipe_constructor_template, v8::FunctionTemplate)                           \
   V(promise_wrap_template, v8::ObjectTemplate)                                 \
+  V(promise_wrap_private, v8::Private)                                         \
   V(sab_lifetimepartner_constructor_template, v8::FunctionTemplate)            \
   V(script_context_constructor_template, v8::FunctionTemplate)                 \
   V(secure_context_constructor_template, v8::FunctionTemplate)                 \
diff -r -u --color up/node/src/handle_wrap.cc nw/node/src/handle_wrap.cc
--- up/node/src/handle_wrap.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/handle_wrap.cc	2024-08-26 19:33:04.978595383 +0000
@@ -39,7 +39,7 @@
 
 void HandleWrap::Ref(const FunctionCallbackInfo<Value>& args) {
   HandleWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
 
   if (IsAlive(wrap))
     uv_ref(wrap->GetHandle());
@@ -48,7 +48,7 @@
 
 void HandleWrap::Unref(const FunctionCallbackInfo<Value>& args) {
   HandleWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
 
   if (IsAlive(wrap))
     uv_unref(wrap->GetHandle());
@@ -57,14 +57,14 @@
 
 void HandleWrap::HasRef(const FunctionCallbackInfo<Value>& args) {
   HandleWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
   args.GetReturnValue().Set(HasRef(wrap));
 }
 
 
 void HandleWrap::Close(const FunctionCallbackInfo<Value>& args) {
   HandleWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
 
   wrap->Close(args[0]);
 }
diff -r -u --color up/node/src/heap_utils.cc nw/node/src/heap_utils.cc
--- up/node/src/heap_utils.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/heap_utils.cc	2024-08-26 19:33:04.978595383 +0000
@@ -346,9 +346,11 @@
 inline void TakeSnapshot(Environment* env,
                          v8::OutputStream* out,
                          HeapProfiler::HeapSnapshotOptions options) {
+#if 0
   HeapSnapshotPointer snapshot{
       env->isolate()->GetHeapProfiler()->TakeHeapSnapshot(options)};
   snapshot->Serialize(out, HeapSnapshot::kJSON);
+#endif
 }
 
 }  // namespace
@@ -434,6 +436,7 @@
 }
 
 void CreateHeapSnapshotStream(const FunctionCallbackInfo<Value>& args) {
+#if 0
   Environment* env = Environment::GetCurrent(args);
   CHECK_EQ(args.Length(), 1);
   auto options = GetHeapSnapshotOptions(args[0]);
@@ -444,6 +447,7 @@
       CreateHeapSnapshotStream(env, std::move(snapshot));
   if (stream)
     args.GetReturnValue().Set(stream->object());
+#endif
 }
 
 void TriggerHeapSnapshot(const FunctionCallbackInfo<Value>& args) {
diff -r -u --color up/node/src/histogram.cc nw/node/src/histogram.cc
--- up/node/src/histogram.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/histogram.cc	2024-08-26 19:33:04.978595383 +0000
@@ -165,7 +165,7 @@
 
 void HistogramBase::RecordDelta(const FunctionCallbackInfo<Value>& args) {
   HistogramBase* histogram;
-  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.This());
   (*histogram)->RecordDelta();
 }
 
@@ -185,7 +185,7 @@
   if (!lossless || value < 1)
     return THROW_ERR_OUT_OF_RANGE(env, "value is out of range");
   HistogramBase* histogram;
-  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.This());
   (*histogram)->Record(value);
 }
 
@@ -204,7 +204,7 @@
 void HistogramBase::Add(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   HistogramBase* histogram;
-  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.This());
 
   CHECK(GetConstructorTemplate(env->isolate_data())->HasInstance(args[0]));
   HistogramBase* other;
@@ -432,7 +432,7 @@
 
 void IntervalHistogram::Start(const FunctionCallbackInfo<Value>& args) {
   IntervalHistogram* histogram;
-  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.This());
   histogram->OnStart(args[0]->IsTrue() ? StartFlags::RESET : StartFlags::NONE);
 }
 
@@ -444,7 +444,7 @@
 
 void IntervalHistogram::Stop(const FunctionCallbackInfo<Value>& args) {
   IntervalHistogram* histogram;
-  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.This());
   histogram->OnStop();
 }
 
@@ -455,67 +455,67 @@
 }
 
 void HistogramImpl::GetCount(const FunctionCallbackInfo<Value>& args) {
-  HistogramImpl* histogram = HistogramImpl::FromJSObject(args.Holder());
+  HistogramImpl* histogram = HistogramImpl::FromJSObject(args.This());
   double value = static_cast<double>((*histogram)->Count());
   args.GetReturnValue().Set(value);
 }
 
 void HistogramImpl::GetCountBigInt(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
-  HistogramImpl* histogram = HistogramImpl::FromJSObject(args.Holder());
+  HistogramImpl* histogram = HistogramImpl::FromJSObject(args.This());
   args.GetReturnValue().Set(
       BigInt::NewFromUnsigned(env->isolate(), (*histogram)->Count()));
 }
 
 void HistogramImpl::GetMin(const FunctionCallbackInfo<Value>& args) {
-  HistogramImpl* histogram = HistogramImpl::FromJSObject(args.Holder());
+  HistogramImpl* histogram = HistogramImpl::FromJSObject(args.This());
   double value = static_cast<double>((*histogram)->Min());
   args.GetReturnValue().Set(value);
 }
 
 void HistogramImpl::GetMinBigInt(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
-  HistogramImpl* histogram = HistogramImpl::FromJSObject(args.Holder());
+  HistogramImpl* histogram = HistogramImpl::FromJSObject(args.This());
   args.GetReturnValue().Set(BigInt::New(env->isolate(), (*histogram)->Min()));
 }
 
 void HistogramImpl::GetMax(const FunctionCallbackInfo<Value>& args) {
-  HistogramImpl* histogram = HistogramImpl::FromJSObject(args.Holder());
+  HistogramImpl* histogram = HistogramImpl::FromJSObject(args.This());
   double value = static_cast<double>((*histogram)->Max());
   args.GetReturnValue().Set(value);
 }
 
 void HistogramImpl::GetMaxBigInt(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
-  HistogramImpl* histogram = HistogramImpl::FromJSObject(args.Holder());
+  HistogramImpl* histogram = HistogramImpl::FromJSObject(args.This());
   args.GetReturnValue().Set(BigInt::New(env->isolate(), (*histogram)->Max()));
 }
 
 void HistogramImpl::GetMean(const FunctionCallbackInfo<Value>& args) {
-  HistogramImpl* histogram = HistogramImpl::FromJSObject(args.Holder());
+  HistogramImpl* histogram = HistogramImpl::FromJSObject(args.This());
   args.GetReturnValue().Set((*histogram)->Mean());
 }
 
 void HistogramImpl::GetExceeds(const FunctionCallbackInfo<Value>& args) {
-  HistogramImpl* histogram = HistogramImpl::FromJSObject(args.Holder());
+  HistogramImpl* histogram = HistogramImpl::FromJSObject(args.This());
   double value = static_cast<double>((*histogram)->Exceeds());
   args.GetReturnValue().Set(value);
 }
 
 void HistogramImpl::GetExceedsBigInt(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
-  HistogramImpl* histogram = HistogramImpl::FromJSObject(args.Holder());
+  HistogramImpl* histogram = HistogramImpl::FromJSObject(args.This());
   args.GetReturnValue().Set(
       BigInt::New(env->isolate(), (*histogram)->Exceeds()));
 }
 
 void HistogramImpl::GetStddev(const FunctionCallbackInfo<Value>& args) {
-  HistogramImpl* histogram = HistogramImpl::FromJSObject(args.Holder());
+  HistogramImpl* histogram = HistogramImpl::FromJSObject(args.This());
   args.GetReturnValue().Set((*histogram)->Stddev());
 }
 
 void HistogramImpl::GetPercentile(const FunctionCallbackInfo<Value>& args) {
-  HistogramImpl* histogram = HistogramImpl::FromJSObject(args.Holder());
+  HistogramImpl* histogram = HistogramImpl::FromJSObject(args.This());
   CHECK(args[0]->IsNumber());
   double percentile = args[0].As<Number>()->Value();
   double value = static_cast<double>((*histogram)->Percentile(percentile));
@@ -525,7 +525,7 @@
 void HistogramImpl::GetPercentileBigInt(
     const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
-  HistogramImpl* histogram = HistogramImpl::FromJSObject(args.Holder());
+  HistogramImpl* histogram = HistogramImpl::FromJSObject(args.This());
   CHECK(args[0]->IsNumber());
   double percentile = args[0].As<Number>()->Value();
   int64_t value = (*histogram)->Percentile(percentile);
@@ -534,7 +534,7 @@
 
 void HistogramImpl::GetPercentiles(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
-  HistogramImpl* histogram = HistogramImpl::FromJSObject(args.Holder());
+  HistogramImpl* histogram = HistogramImpl::FromJSObject(args.This());
   CHECK(args[0]->IsMap());
   Local<Map> map = args[0].As<Map>();
   (*histogram)->Percentiles([map, env](double key, int64_t value) {
@@ -548,7 +548,7 @@
 void HistogramImpl::GetPercentilesBigInt(
     const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
-  HistogramImpl* histogram = HistogramImpl::FromJSObject(args.Holder());
+  HistogramImpl* histogram = HistogramImpl::FromJSObject(args.This());
   CHECK(args[0]->IsMap());
   Local<Map> map = args[0].As<Map>();
   (*histogram)->Percentiles([map, env](double key, int64_t value) {
@@ -560,7 +560,7 @@
 }
 
 void HistogramImpl::DoReset(const FunctionCallbackInfo<Value>& args) {
-  HistogramImpl* histogram = HistogramImpl::FromJSObject(args.Holder());
+  HistogramImpl* histogram = HistogramImpl::FromJSObject(args.This());
   (*histogram)->Reset();
 }
 
diff -r -u --color up/node/src/inspector/node_inspector.gypi nw/node/src/inspector/node_inspector.gypi
--- up/node/src/inspector/node_inspector.gypi	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/inspector/node_inspector.gypi	2024-08-26 19:33:04.978595383 +0000
@@ -86,7 +86,7 @@
       ],
       'action': [
         '<(python)',
-        'tools/inspector_protocol/convert_protocol_to_json.py',
+        '../../v8/third_party/inspector_protocol/convert_protocol_to_json.py',
         '<@(_inputs)',
         '<@(_outputs)',
       ],
@@ -115,7 +115,7 @@
     {
       'action_name': 'concatenate_protocols',
       'inputs': [
-        '../../deps/v8/include/js_protocol.pdl',
+        #'../../../../v8/src/inspector/js_protocol.json',
         '<(SHARED_INTERMEDIATE_DIR)/src/node_protocol.json',
       ],
       'outputs': [
@@ -123,7 +123,7 @@
       ],
       'action': [
         '<(python)',
-        'tools/inspector_protocol/concatenate_protocols.py',
+        '../../v8/third_party/inspector_protocol/concatenate_protocols.py',
         '<@(_inputs)',
         '<@(_outputs)',
       ],
diff -r -u --color up/node/src/inspector/tracing_agent.cc nw/node/src/inspector/tracing_agent.cc
--- up/node/src/inspector/tracing_agent.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/inspector/tracing_agent.cc	2024-08-26 19:33:04.978595383 +0000
@@ -88,7 +88,7 @@
   void AppendTraceEvent(
       v8::platform::tracing::TraceObject* trace_event) override {
     if (!json_writer_)
-      json_writer_.reset(TraceWriter::CreateJSONTraceWriter(stream_, "value"));
+      json_writer_.reset(TraceWriter::CreateJSONTraceWriter(stream_));
     json_writer_->AppendTraceEvent(trace_event);
   }
 
@@ -153,6 +153,7 @@
   if (categories_set.empty())
     return DispatchResponse::Error("At least one category should be enabled");
 
+#if 0
   tracing::AgentWriterHandle* writer = GetTracingAgentWriter();
   if (writer != nullptr) {
     trace_writer_ =
@@ -161,6 +162,7 @@
                                        frontend_object_id_, main_thread_),
                                    tracing::Agent::kIgnoreDefaultCategories);
   }
+#endif
   return DispatchResponse::OK();
 }
 
diff -r -u --color up/node/src/inspector_agent.cc nw/node/src/inspector_agent.cc
--- up/node/src/inspector_agent.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/inspector_agent.cc	2024-08-26 19:33:04.978595383 +0000
@@ -816,6 +816,9 @@
 std::unique_ptr<InspectorSession> Agent::Connect(
     std::unique_ptr<InspectorSessionDelegate> delegate,
     bool prevent_shutdown) {
+  if (!client_)
+    return nullptr;
+
   THROW_IF_INSUFFICIENT_PERMISSIONS(parent_env_,
                                     permission::PermissionScope::kInspector,
                                     "Connect",
@@ -825,8 +828,6 @@
     return std::unique_ptr<InspectorSession>{};
   }
 
-  CHECK_NOT_NULL(client_);
-
   int session_id = client_->connectFrontend(std::move(delegate),
                                             prevent_shutdown);
   return std::unique_ptr<InspectorSession>(
diff -r -u --color up/node/src/inspector_js_api.cc nw/node/src/inspector_js_api.cc
--- up/node/src/inspector_js_api.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/inspector_js_api.cc	2024-08-26 19:33:04.978595383 +0000
@@ -92,6 +92,7 @@
                        Local<Function> callback)
       : BaseObject(env, wrap), callback_(env->isolate(), callback) {
     Agent* inspector = env->inspector_agent();
+    if (inspector)
     session_ = ConnectionType::Connect(
         inspector, std::make_unique<JSBindingsSessionDelegate>(env, this));
   }
@@ -131,14 +132,14 @@
 
   static void Disconnect(const FunctionCallbackInfo<Value>& info) {
     JSBindingsConnection* session;
-    ASSIGN_OR_RETURN_UNWRAP(&session, info.Holder());
+    ASSIGN_OR_RETURN_UNWRAP(&session, info.This());
     session->Disconnect();
   }
 
   static void Dispatch(const FunctionCallbackInfo<Value>& info) {
     Environment* env = Environment::GetCurrent(info);
     JSBindingsConnection* session;
-    ASSIGN_OR_RETURN_UNWRAP(&session, info.Holder());
+    ASSIGN_OR_RETURN_UNWRAP(&session, info.This());
     CHECK(info[0]->IsString());
 
     if (session->session_) {
@@ -204,11 +205,8 @@
     CHECK(inspector_method->IsFunction());
     if (!env->is_in_inspector_console_call()) {
       env->set_is_in_inspector_console_call(true);
-      MaybeLocal<Value> ret =
-          inspector_method.As<Function>()->Call(context,
-                                                info.Holder(),
-                                                call_args.length(),
-                                                call_args.out());
+      MaybeLocal<Value> ret = inspector_method.As<Function>()->Call(
+          context, info.This(), call_args.length(), call_args.out());
       env->set_is_in_inspector_console_call(false);
       if (ret.IsEmpty())
         return;
@@ -217,10 +215,8 @@
 
   Local<Value> node_method = info[1];
   CHECK(node_method->IsFunction());
-  USE(node_method.As<Function>()->Call(context,
-                                   info.Holder(),
-                                   call_args.length(),
-                                   call_args.out()));
+  USE(node_method.As<Function>()->Call(
+      context, info.This(), call_args.length(), call_args.out()));
 }
 
 static void* GetAsyncTask(int64_t asyncId) {
diff -r -u --color up/node/src/js_stream.cc nw/node/src/js_stream.cc
--- up/node/src/js_stream.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/js_stream.cc	2024-08-26 19:33:04.982595381 +0000
@@ -164,7 +164,7 @@
 
 void JSStream::ReadBuffer(const FunctionCallbackInfo<Value>& args) {
   JSStream* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
 
   ArrayBufferViewContents<char> buffer(args[0]);
   const char* data = buffer.data();
@@ -194,7 +194,7 @@
 
 void JSStream::EmitEOF(const FunctionCallbackInfo<Value>& args) {
   JSStream* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
 
   wrap->EmitRead(UV_EOF);
 }
diff -r -u --color up/node/src/js_udp_wrap.cc nw/node/src/js_udp_wrap.cc
--- up/node/src/js_udp_wrap.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/js_udp_wrap.cc	2024-08-26 19:33:04.982595381 +0000
@@ -137,12 +137,12 @@
 void JSUDPWrap::New(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   CHECK(args.IsConstructCall());
-  new JSUDPWrap(env, args.Holder());
+  new JSUDPWrap(env, args.This());
 }
 
 void JSUDPWrap::EmitReceived(const FunctionCallbackInfo<Value>& args) {
   JSUDPWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
   Environment* env = wrap->env();
 
   ArrayBufferViewContents<char> buffer(args[0]);
@@ -176,7 +176,7 @@
 
 void JSUDPWrap::OnSendDone(const FunctionCallbackInfo<Value>& args) {
   JSUDPWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
 
   CHECK(args[0]->IsObject());
   CHECK(args[1]->IsInt32());
@@ -189,7 +189,7 @@
 
 void JSUDPWrap::OnAfterBind(const FunctionCallbackInfo<Value>& args) {
   JSUDPWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
 
   wrap->listener()->OnAfterBind();
 }
diff -r -u --color up/node/src/large_pages/node_large_page.cc nw/node/src/large_pages/node_large_page.cc
--- up/node/src/large_pages/node_large_page.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/large_pages/node_large_page.cc	2024-08-26 19:33:04.982595381 +0000
@@ -99,8 +99,8 @@
 // This symbol must be declared weak because this file becomes part of all
 // Node.js targets (like node_mksnapshot, node_mkcodecache, and cctest) and
 // those files do not supply the symbol.
-extern char __attribute__((weak)) __node_text_start;
-extern char __start_lpstub;
+char __node_text_start;
+char __start_lpstub;
 }  // extern "C"
 #endif  // defined(__linux__) || defined(__FreeBSD__)
 
diff -r -u --color up/node/src/module_wrap.cc nw/node/src/module_wrap.cc
--- up/node/src/module_wrap.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/module_wrap.cc	2024-08-26 19:33:04.982595381 +0000
@@ -339,7 +339,7 @@
     bool* cache_rejected) {
   Isolate* isolate = realm->isolate();
   EscapableHandleScope scope(isolate);
-  ScriptOrigin origin(isolate,
+  ScriptOrigin origin(
                       url,
                       line_offset,
                       column_offset,
@@ -549,7 +549,6 @@
 
   ShouldNotAbortOnUncaughtScope no_abort_scope(realm->env());
   TryCatchScope try_catch(realm->env());
-  Isolate::SafeForTerminationScope safe_for_termination(isolate);
 
   bool timed_out = false;
   bool received_signal = false;
diff -r -u --color up/node/src/node.cc nw/node/src/node.cc
--- up/node/src/node.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/node.cc	2024-08-26 19:33:04.982595381 +0000
@@ -46,12 +46,18 @@
 #include "node_v8_platform-inl.h"
 #include "node_version.h"
 
+#include <iostream>
+
+#include <vector>
+#include "node_webkit.h"
+
 #if HAVE_OPENSSL
 #include "node_crypto.h"
 #endif
 
 #if defined(NODE_HAVE_I18N_SUPPORT)
 #include "node_i18n.h"
+#include <unicode/udata.h>
 #endif
 
 #if HAVE_INSPECTOR
@@ -130,6 +136,10 @@
 #include <tuple>
 #include <vector>
 
+extern "C" {
+NODE_EXTERN void* g_get_node_env();
+}
+
 namespace node {
 
 using v8::Array;
@@ -143,6 +153,15 @@
 using v8::V8;
 using v8::Value;
 
+NODE_EXTERN v8::Persistent<v8::Context> g_context;
+NODE_EXTERN v8::Persistent<v8::Context> g_dom_context;
+static UVRunFn g_nw_uv_run = nullptr;
+static NWTickCallback g_nw_tick_callback = nullptr;
+static const char* g_native_blob_path = nullptr;
+bool node_is_nwjs = false;
+
+NODE_EXTERN void OnMessage(v8::Local<v8::Message> message, v8::Local<v8::Value> error);
+
 namespace per_process {
 
 // node_dotenv.h
@@ -410,7 +429,7 @@
     return StartExecution(env, "internal/main/watch_mode");
   }
 
-  if (!first_argv.empty() && first_argv != "-") {
+  if ((!first_argv.empty() && first_argv != "-") || node_is_nwjs) {
     return StartExecution(env, "internal/main/run_main_module");
   }
 
@@ -801,6 +820,7 @@
   }
 #endif
 
+  if (!node_is_nwjs) {
   std::vector<char*> v8_args_as_char_ptr(v8_args.size());
   if (v8_args.size() > 0) {
     for (size_t i = 0; i < v8_args.size(); ++i)
@@ -809,13 +829,13 @@
     V8::SetFlagsFromCommandLine(&argc, v8_args_as_char_ptr.data(), true);
     v8_args_as_char_ptr.resize(argc);
   }
-
   // Anything that's still in v8_argv is not a V8 or a node option.
   for (size_t i = 1; i < v8_args_as_char_ptr.size(); i++)
     errors->push_back("bad option: " + std::string(v8_args_as_char_ptr[i]));
 
   if (v8_args_as_char_ptr.size() > 1)
     return ExitCode::kInvalidCommandLineArgument;
+  } //node nwjs
 
   return ExitCode::kNoFailure;
 }
@@ -846,11 +866,13 @@
   // Register built-in bindings
   binding::RegisterBuiltinBindings();
 
+  if (!node_is_nwjs) {
   // Make inherited handles noninheritable.
   if (!(flags & ProcessInitializationFlags::kEnableStdioInheritance) &&
       !(flags & ProcessInitializationFlags::kNoStdioInitialization)) {
     uv_disable_stdio_inheritance();
   }
+  } //node_is_nwjs
 
   // Cache the original command line to be
   // used in diagnostic reports.
@@ -859,13 +881,15 @@
   // Node provides a "v8.setFlagsFromString" method to dynamically change flags.
   // Hence do not freeze flags when initializing V8. In a browser setting, this
   // is security relevant, for Node it's less important.
-  V8::SetFlagsFromString("--no-freeze-flags-after-init");
+  if (!node_is_nwjs)
+    V8::SetFlagsFromString("--no-freeze-flags-after-init");
 
 #if defined(NODE_V8_OPTIONS)
   // Should come before the call to V8::SetFlagsFromCommandLine()
   // so the user can disable a flag --foo at run-time by passing
   // --no_foo from the command line.
-  V8::SetFlagsFromString(NODE_V8_OPTIONS, sizeof(NODE_V8_OPTIONS) - 1);
+  if (!node_is_nwjs)
+    V8::SetFlagsFromString(NODE_V8_OPTIONS, sizeof(NODE_V8_OPTIONS) - 1);
 #endif
 
   if (!!(flags & ProcessInitializationFlags::kGeneratePredictableSnapshot) ||
@@ -876,6 +900,7 @@
 
   // Specify this explicitly to avoid being affected by V8 changes to the
   // default value.
+  if (!node_is_nwjs)
   V8::SetFlagsFromString("--rehash-snapshot");
 
   HandleEnvOptions(per_process::cli_options->per_isolate->per_env);
@@ -934,7 +959,7 @@
   if (!per_process::cli_options->title.empty())
     uv_set_process_title(per_process::cli_options->title.c_str());
 
-#if defined(NODE_HAVE_I18N_SUPPORT)
+#if 0 //defined(NODE_HAVE_I18N_SUPPORT)
   if (!(flags & ProcessInitializationFlags::kNoICU)) {
     // If the parameter isn't given, use the env variable.
     if (per_process::cli_options->icu_data_dir.empty())
@@ -990,6 +1015,115 @@
   return ExitCode::kNoFailure;
 }
 
+#ifdef V8_USE_EXTERNAL_STARTUP_DATA
+// Helper class to load the startup data files from disk.
+//
+// This is meant as a convenience for stand-alone binaries like d8, cctest,
+// unittest. A V8 embedder would likely either handle startup data on their
+// own or just disable the feature if they don't want to handle it at all,
+// while tools like cctest need to work in either configuration. Hence this is
+// not meant for inclusion in the general v8 library.
+class StartupDataHandler {
+ public:
+  // Load startup data, and call the v8::V8::Set*DataBlob API functions.
+  //
+  // natives_blob and snapshot_blob will be loaded realitive to exec_path,
+  // which would usually be the equivalent of argv[0].
+  StartupDataHandler(const char* exec_path, const char* natives_blob,
+                     const char* snapshot_blob);
+  ~StartupDataHandler();
+
+ private:
+  static char* RelativePath(char** buffer, const char* exec_path,
+                            const char* name);
+
+  void LoadFromFiles(const char* natives_blob, const char* snapshot_blob);
+
+  void Load(const char* blob_file, v8::StartupData* startup_data,
+            void (*setter_fn)(v8::StartupData*));
+
+  v8::StartupData natives_;
+  v8::StartupData snapshot_;
+
+  // Disallow copy & assign.
+  StartupDataHandler(const StartupDataHandler& other);
+  void operator=(const StartupDataHandler& other);
+};
+
+StartupDataHandler::StartupDataHandler(const char* exec_path,
+                                       const char* natives_blob,
+                                       const char* snapshot_blob) {
+  // If we have (at least one) explicitly given blob, use those.
+  // If not, use the default blob locations next to the d8 binary.
+  if (natives_blob || snapshot_blob) {
+    LoadFromFiles(natives_blob, snapshot_blob);
+  } else {
+    char* natives;
+    char* snapshot;
+    LoadFromFiles(RelativePath(&natives, exec_path, "natives_blob.bin"),
+                  RelativePath(&snapshot, exec_path, "snapshot_blob.bin"));
+
+    free(natives);
+    free(snapshot);
+  }
+}
+
+
+StartupDataHandler::~StartupDataHandler() {
+  delete[] natives_.data;
+  delete[] snapshot_.data;
+}
+
+
+char* StartupDataHandler::RelativePath(char** buffer, const char* exec_path,
+                                       const char* name) {
+  const char* last_slash = strrchr(exec_path, '/');
+  if (last_slash) {
+    int after_slash = last_slash - exec_path + 1;
+    int name_length = static_cast<int>(strlen(name));
+    *buffer = reinterpret_cast<char*>(calloc(after_slash + name_length + 1, 1));
+    strncpy(*buffer, exec_path, after_slash);
+    strncat(*buffer, name, name_length);
+  } else {
+    *buffer = strdup(name);
+  }
+  return *buffer;
+}
+
+
+void StartupDataHandler::LoadFromFiles(const char* natives_blob,
+                                       const char* snapshot_blob) {
+  //Load(natives_blob, &natives_, v8::V8::SetNativesDataBlob);
+  Load(snapshot_blob, &snapshot_, v8::V8::SetSnapshotDataBlob);
+}
+
+
+void StartupDataHandler::Load(const char* blob_file,
+                              v8::StartupData* startup_data,
+                              void (*setter_fn)(v8::StartupData*)) {
+  startup_data->data = NULL;
+  startup_data->raw_size = 0;
+
+  if (!blob_file) return;
+
+  FILE* file = fopen(blob_file, "rb");
+  if (!file) return;
+
+  fseek(file, 0, SEEK_END);
+  startup_data->raw_size = ftell(file);
+  rewind(file);
+
+  startup_data->data = new char[startup_data->raw_size];
+  int read_size = static_cast<int>(fread(const_cast<char*>(startup_data->data),
+                                         1, startup_data->raw_size, file));
+  fclose(file);
+
+  if (startup_data->raw_size == read_size) (*setter_fn)(startup_data);
+}
+
+#endif  // V8_USE_EXTERNAL_STARTUP_DATA
+
+
 int InitializeNodeWithArgs(std::vector<std::string>* argv,
                            std::vector<std::string>* exec_argv,
                            std::vector<std::string>* errors,
@@ -1023,9 +1157,9 @@
     }
   }
 
-  if (!(flags & ProcessInitializationFlags::kNoUseLargePages) &&
-      (per_process::cli_options->use_largepages == "on" ||
-       per_process::cli_options->use_largepages == "silent")) {
+  if (false) { //!(flags & ProcessInitializationFlags::kNoUseLargePages) &&
+    //      (per_process::cli_options->use_largepages == "on" ||
+    //   per_process::cli_options->use_largepages == "silent")) {
     int lp_result = node::MapStaticCodeToLargePages();
     if (per_process::cli_options->use_largepages == "on" && lp_result != 0) {
       result->errors_.emplace_back(node::LargePagesError(lp_result));
@@ -1183,11 +1317,28 @@
 #endif  // HAVE_OPENSSL
   }
 
+  if (!node_is_nwjs) {
+#ifdef V8_USE_EXTERNAL_STARTUP_DATA
+  std::string argv0 = args[0];
+  //StartupDataHandler startup_data(argv[0], nullptr, nullptr);
+#if defined(__APPLE__)
+  V8::InitializeExternalStartupData(g_native_blob_path);
+#else
+  V8::InitializeExternalStartupData(argv0.c_str());
+#endif
+#endif
+  V8::InitializeICUDefaultLocation(argv0.c_str());
+  UErrorCode err = U_ZERO_ERROR;
+  void* icu_data = V8::RawICUData();
+  if (icu_data)
+    udata_setCommonData((uint8_t*)icu_data, &err);
+
   if (!(flags & ProcessInitializationFlags::kNoInitializeNodeV8Platform)) {
     per_process::v8_platform.Initialize(
         static_cast<int>(per_process::cli_options->v8_thread_pool_size));
     result->platform_ = per_process::v8_platform.Platform();
   }
+  } //node nwjs
 
   if (!(flags & ProcessInitializationFlags::kNoInitializeV8)) {
     V8::Initialize();
@@ -1232,7 +1383,7 @@
   }
 #endif  // NODE_USE_V8_WASM_TRAP_HANDLER
 
-  performance::performance_v8_start = PERFORMANCE_NOW();
+  //performance::performance_v8_start = PERFORMANCE_NOW();
   per_process::v8_initialized = true;
 
   return result;
@@ -1513,6 +1664,10 @@
   return 0;
 }
 
+NODE_EXTERN v8::Handle<v8::Value> CallNWTickCallback(Environment* env, const v8::Handle<v8::Value> ret) {
+  return (*g_nw_tick_callback)(env, ret);
+}
+
 }  // namespace node
 
 #if !HAVE_INSPECTOR
@@ -1520,3 +1675,474 @@
 
 NODE_BINDING_CONTEXT_AWARE_INTERNAL(inspector, Initialize)
 #endif  // !HAVE_INSPECTOR
+
+extern "C" {
+void wakeup_callback(uv_async_t* handle) {
+  // do nothing, just make libuv exit loop.
+}
+
+void idle_callback(uv_idle_t* handle) {
+  // do nothing, just make libuv exit loop.
+}
+
+void timer_callback(uv_timer_t* timer) {
+  // libuv would block unexpectedly with zero-timeout timer
+  // this is a workaround of libuv bug #574:
+  // https://github.com/joyent/libuv/issues/574
+  uv_idle_start(static_cast<uv_idle_t*>(timer->data), idle_callback);
+}
+
+void close_async_cb(uv_handle_t* handle) {
+  delete reinterpret_cast<uv_async_t*>(handle);
+  node::thread_ctx_st* tls_ctx = (node::thread_ctx_st*)uv_key_get(&node::thread_ctx_key);
+  if (tls_ctx)
+    tls_ctx->close_async_handle_done = 1;
+}
+
+void close_timer_cb(uv_handle_t* handle) {
+  delete reinterpret_cast<uv_timer_t*>(handle);
+}
+
+void close_quit_timer_cb(uv_handle_t* handle) {
+  node::thread_ctx_st* tls_ctx = (node::thread_ctx_st*)uv_key_get(&node::thread_ctx_key);
+  if (tls_ctx)
+    tls_ctx->close_quit_timer_done = 1;
+}
+
+void close_idle_cb(uv_handle_t* handle) {
+  delete reinterpret_cast<uv_idle_t*>(handle);
+}
+
+NODE_EXTERN int g_uv_run(void* loop, int mode) {
+  return uv_run((uv_loop_t*)loop, (uv_run_mode)mode);
+}
+
+NODE_EXTERN void g_set_uv_run(UVRunFn uv_run_fn) {
+  node::g_nw_uv_run = uv_run_fn;
+}
+
+NODE_EXTERN int g_node_start(int argc, char** argv) {
+  return node::Start(argc, argv);
+}
+
+NODE_EXTERN void g_set_blob_path(const char* path) {
+  node::g_native_blob_path = path;
+}
+
+NODE_EXTERN void g_msg_pump_nest_enter(msg_pump_context_t* ctx) {
+  ctx->loop = uv_loop_new();
+
+  //ctx->wakeup_events->push_back((uv_async_t*)ctx->wakeup_event);
+  ctx->wakeup_event = new uv_async_t;
+  uv_async_init((uv_loop_t*)ctx->loop, (uv_async_t*)ctx->wakeup_event, wakeup_callback);
+}
+
+NODE_EXTERN void g_msg_pump_pre_loop(msg_pump_context_t* ctx) {
+  ctx->idle_handle = new uv_idle_t;
+  uv_idle_init((uv_loop_t*)ctx->loop, (uv_idle_t*)ctx->idle_handle);
+
+  ctx->delay_timer = new uv_timer_t;
+  ((uv_timer_t*)ctx->delay_timer)->data = ctx->idle_handle;
+  uv_timer_init((uv_loop_t*)ctx->loop, (uv_timer_t*)ctx->delay_timer);
+}
+
+NODE_EXTERN void g_msg_pump_did_work(msg_pump_context_t* ctx) {
+  if (!node::thread_ctx_created) return;
+  node::thread_ctx_st* tls_ctx = (node::thread_ctx_st*)uv_key_get(&node::thread_ctx_key);
+  if (tls_ctx && tls_ctx->env) {
+    v8::Isolate* isolate = tls_ctx->env->isolate();
+    if (!isolate)
+      return;
+    v8::HandleScope handleScope(isolate);
+    v8::Context::Scope cscope(tls_ctx->env->context());
+    (*node::g_nw_uv_run)((uv_loop_t*)ctx->loop, UV_RUN_NOWAIT);
+    node::CallNWTickCallback(tls_ctx->env, v8::Undefined(isolate));
+  }
+}
+
+NODE_EXTERN void g_msg_pump_need_work(msg_pump_context_t* ctx) {
+  node::thread_ctx_st* tls_ctx = nullptr;
+  if (node::thread_ctx_created) {
+    tls_ctx = (node::thread_ctx_st*)uv_key_get(&node::thread_ctx_key);
+    if (tls_ctx && tls_ctx->env) {
+      tls_ctx->env->context()->Enter();
+    }
+  }
+  (*node::g_nw_uv_run)((uv_loop_t*)ctx->loop, UV_RUN_ONCE);
+  if (tls_ctx && tls_ctx->env) {
+    tls_ctx->env->context()->Exit();
+  }
+}
+
+NODE_EXTERN void g_msg_pump_delay_work(msg_pump_context_t* ctx, int sec) {
+  node::thread_ctx_st* tls_ctx = nullptr;
+  if (node::thread_ctx_created) {
+    tls_ctx = (node::thread_ctx_st*)uv_key_get(&node::thread_ctx_key);
+    if (tls_ctx && tls_ctx->env) {
+      tls_ctx->env->context()->Enter();
+    }
+  }
+  uv_timer_start((uv_timer_t*)ctx->delay_timer, timer_callback, sec, 0);
+  (*node::g_nw_uv_run)((uv_loop_t*)ctx->loop, UV_RUN_ONCE);
+  uv_idle_stop((uv_idle_t*)ctx->idle_handle);
+  uv_timer_stop((uv_timer_t*)ctx->delay_timer);
+  if (tls_ctx && tls_ctx->env) {
+    tls_ctx->env->context()->Exit();
+  }
+}
+
+NODE_EXTERN void g_msg_pump_nest_leave(msg_pump_context_t* ctx) {
+  uv_close((uv_handle_t*)(ctx->wakeup_event), close_async_cb);
+  // Delete external loop.
+  uv_loop_close((uv_loop_t*)ctx->loop);
+  free((uv_loop_t*)ctx->loop);
+  ctx->loop = nullptr;
+    // // Restore previous async handle.
+  //ctx->wakeup_event = ctx->wakeup_events->back();
+  //ctx->wakeup_events->pop_back();
+}
+
+NODE_EXTERN uv_loop_t* g_uv_default_loop() {
+  return uv_default_loop();
+}
+
+NODE_EXTERN void g_msg_pump_clean_ctx(msg_pump_context_t* ctx) {
+  uv_close((uv_handle_t*)ctx->idle_handle, close_idle_cb);
+  uv_run((uv_loop_t*)ctx->loop, UV_RUN_NOWAIT);
+  ctx->idle_handle = nullptr;
+
+  uv_close((uv_handle_t*)ctx->delay_timer, close_timer_cb);
+  uv_run((uv_loop_t*)ctx->loop, UV_RUN_NOWAIT);
+  ctx->delay_timer = nullptr;
+}
+
+NODE_EXTERN void g_msg_pump_sched_work(uv_async_t* wakeup_event) {
+#ifdef _WIN32
+  uv_async_send_nw(wakeup_event);
+#else
+  uv_async_send(wakeup_event);
+#endif
+}
+
+NODE_EXTERN void g_msg_pump_ctor(uv_async_t** wakeup_event, int worker_support) {
+  uv_init_nw(worker_support);
+  node::g_worker_support = worker_support;
+  *wakeup_event = new uv_async_t;
+  uv_async_init(uv_default_loop(), *wakeup_event, wakeup_callback);
+  node::g_nw_uv_run = (UVRunFn)uv_run;
+}
+
+NODE_EXTERN void g_msg_pump_dtor(uv_async_t** wakeup_event) {
+  node::thread_ctx_st* tls_ctx = nullptr;
+  tls_ctx = (node::thread_ctx_st*)uv_key_get(&node::thread_ctx_key);
+  if (tls_ctx)
+    tls_ctx->close_async_handle_done = 0;
+  uv_close(reinterpret_cast<uv_handle_t*>(*wakeup_event), close_async_cb);
+  while (tls_ctx && !tls_ctx->close_async_handle_done)
+    uv_run(uv_default_loop(), UV_RUN_NOWAIT);
+  uv_loop_close(uv_default_loop());
+  *wakeup_event = nullptr;
+  if (tls_ctx)
+    free(tls_ctx);
+  uv_key_set(&node::thread_ctx_key, NULL);
+}
+
+NODE_EXTERN bool g_is_node_initialized() {
+  return node::node_is_initialized;
+}
+
+NODE_EXTERN void g_call_tick_callback(node::Environment* env) {
+  if (!env->can_call_into_js())
+    return;
+  v8::HandleScope handle_scope(env->isolate());
+  v8::Context::Scope context_scope(env->context());
+
+  v8::Local<v8::Object> process = env->process_object();
+  node::InternalCallbackScope scope(env, process, {0, 0});
+}
+
+// copied beginning of Start() until v8::Initialize()
+NODE_EXTERN void g_setup_nwnode(int argc, char** argv, bool worker) {
+  node::per_process::node_start_time = static_cast<double>(uv_now(uv_default_loop()));
+  node::node_is_initialized = true;
+  node::node_is_nwjs = true;
+}
+
+static void walk_cb(uv_handle_t* handle, void* arg) {
+  node::thread_ctx_st* tls_ctx = (node::thread_ctx_st*)arg;
+  if (uv_is_active(handle))
+    tls_ctx->handle_counter++;  
+}
+
+static void quit_timer_cb(uv_timer_t* timer) {
+  node::thread_ctx_st* tls_ctx = (node::thread_ctx_st*)uv_key_get(&node::thread_ctx_key);
+  assert(tls_ctx);
+  tls_ctx->quit_flag = 1;
+  //std::cerr << "quit timer timeout";
+}
+
+NODE_EXTERN void g_stop_nw_instance() {
+  if (!node::g_worker_support)
+    return;
+  node::thread_ctx_st* tls_ctx = (node::thread_ctx_st*)uv_key_get(&node::thread_ctx_key);
+  if (!tls_ctx) //NWJS#6615
+    return;
+  bool more;
+  uv_timer_t quit_timer;
+  uv_loop_t* loop = tls_ctx->env->event_loop();
+  uv_timer_init(loop, &quit_timer);
+  uv_timer_start(&quit_timer, quit_timer_cb, 10000, 0);
+  do {
+    tls_ctx->handle_counter = 0;
+    uv_walk(loop, walk_cb, tls_ctx);
+    //std::cerr << "handles: " << tls_ctx->handle_counter;
+    // quit timer and async hanle for loop wakeup
+    if (tls_ctx->handle_counter <= 2)
+      more = false;
+    else
+    //uv_print_active_handles(tls_ctx->env->event_loop(), stderr);
+      more = uv_run(loop, UV_RUN_ONCE);
+    if (more == false) {
+      node::EmitBeforeExit(tls_ctx->env);
+
+      // Emit `beforeExit` if the loop became alive either after emitting
+      // event, or after running some callbacks.
+      more = uv_loop_alive(loop);
+      if (uv_run(loop, UV_RUN_NOWAIT) != 0)
+        more = true;
+      tls_ctx->handle_counter = 0;
+      uv_walk(loop, walk_cb, tls_ctx);
+      //std::cerr << "handles: " << tls_ctx->handle_counter;
+      if (tls_ctx->handle_counter <= 2)
+        more = false;
+    }
+  } while (more == true && !tls_ctx->quit_flag);
+  uv_timer_stop(&quit_timer);
+  tls_ctx->close_quit_timer_done = 0;
+  uv_close(reinterpret_cast<uv_handle_t*>(&quit_timer), close_quit_timer_cb);
+  while (!tls_ctx->close_quit_timer_done)
+    uv_run(loop, UV_RUN_NOWAIT);
+  struct node::node_module* mp, *mp2;
+  for (mp = tls_ctx->modlist_builtin; mp != nullptr;) {
+    mp2 = mp->nm_link;
+    free(mp);
+    mp = mp2;
+  }
+  for (mp = tls_ctx->modlist_linked; mp != nullptr;) {
+    mp2 = mp->nm_link;
+    free(mp);
+    mp = mp2;
+  }
+  node::NodePlatform* platform = (node::NodePlatform*)tls_ctx->env->isolate_data()->platform();
+  v8::Isolate* isolate = tls_ctx->env->isolate();
+  node::FreeEnvironment(tls_ctx->env);
+  platform->UnregisterIsolate(isolate);
+  delete platform;
+  tls_ctx->env = nullptr;
+
+  //std::cerr << "QUIT LOOP" << std::endl;
+}
+
+NODE_EXTERN void g_start_nw_instance(int argc, char *argv[], v8::Handle<v8::Context> context, void* icu_data) {
+
+  static bool node_init_called = false;
+  static std::vector<std::string> args;
+  static std::vector<std::string> exec_args;
+
+  UErrorCode err = U_ZERO_ERROR;
+  if (icu_data)
+    udata_setCommonData((uint8_t*)icu_data, &err);
+
+  v8::Isolate* isolate = v8::Isolate::GetCurrent();
+  v8::HandleScope handle_scope(isolate);
+  v8::Context::Scope context_scope(context);
+
+  argv = uv_setup_args(argc, argv);
+  if (!node_init_called) {
+    std::shared_ptr<node::InitializationResultImpl> result =
+      node::InitializeOncePerProcessInternal(
+					   std::vector<std::string>(argv, argv + argc),
+					   node::ProcessInitializationFlags::kNWJS);
+    args = result->args();
+    exec_args = result->exec_args();
+    node_init_called = true;
+    for (const std::string& error : result->errors()) {
+      node::FPrintF(stderr, "%s: %s\n", result->args().at(0), error);
+    }
+  }
+
+  if (!node::thread_ctx_created) {
+    node::thread_ctx_created = 1;
+    uv_key_create(&node::thread_ctx_key);
+  }
+  node::thread_ctx_st* tls_ctx = (node::thread_ctx_st*)uv_key_get(&node::thread_ctx_key);
+  if (!tls_ctx) {
+    tls_ctx = (node::thread_ctx_st*)malloc(sizeof(node::thread_ctx_st));
+    memset(tls_ctx, 0, sizeof(node::thread_ctx_st));
+    uv_key_set(&node::thread_ctx_key, tls_ctx);
+    node::binding::RegisterBuiltinBindings();
+  }
+  node::NodePlatform* platform = new node::NodePlatform(node::per_process::cli_options->v8_thread_pool_size, new v8::TracingController());
+  platform->RegisterIsolate(isolate, uv_default_loop());
+  node::IsolateData* isolate_data = node::CreateIsolateData(isolate, uv_default_loop(), platform);
+  node::NewContext(isolate, v8::Local<v8::ObjectTemplate>(), false);
+  tls_ctx->env = node::CreateEnvironment(isolate_data, context, args, exec_args);
+  isolate->SetFatalErrorHandler(node::OnFatalError);
+  isolate->AddMessageListener(node::errors::PerIsolateMessageListener);
+  //isolate->SetAutorunMicrotasks(false);
+#if 0
+  const char* path = argc > 1 ? argv[1] : nullptr;
+  StartInspector(tls_ctx->env, path, node::debug_options);
+#endif
+  {
+    node::InternalCallbackScope callback_scope(
+          tls_ctx->env,
+          v8::Object::New(isolate),
+          { 1, 0 },
+          node::InternalCallbackScope::kSkipAsyncHooks);
+    node::LoadEnvironment(tls_ctx->env, node::StartExecutionCallback{});
+  }
+}
+
+NODE_EXTERN void g_set_nw_tick_callback(NWTickCallback tick_callback) {
+  node::g_nw_tick_callback = tick_callback;
+}
+
+NODE_EXTERN void* g_get_node_env() {
+  if (!node::thread_ctx_created)
+    return nullptr;
+  node::thread_ctx_st* tls_ctx = (node::thread_ctx_st*)uv_key_get(&node::thread_ctx_key);
+  return tls_ctx->env;
+}
+
+NODE_EXTERN void g_get_node_context(v8::Local<v8::Context>* ret) {
+  *ret = v8::Local<v8::Context>::New(v8::Isolate::GetCurrent(), node::g_context);
+}
+
+NODE_EXTERN void g_set_node_context(v8::Isolate* isolate, v8::Local<v8::Context>* context) {
+  node::g_context.Reset(isolate, *context);
+}
+
+NODE_EXTERN void* g_get_current_env(v8::Handle<v8::Context> context) {
+  return node::Environment::GetCurrent(context);
+}
+
+NODE_EXTERN void g_emit_exit(node::Environment* env) {
+  node::EmitExit(env);
+}
+
+NODE_EXTERN void g_run_at_exit(node::Environment* env) {
+  node::RunAtExit(env);
+}
+
+NODE_EXTERN void g_promise_reject_callback(v8::PromiseRejectMessage* data) {
+  node::PromiseRejectCallback(*data);
+}
+
+NODE_EXTERN void g_uv_init_nw(int worker) {
+  uv_init_nw(worker);
+}
+
+#ifdef __APPLE__
+
+void UvNoOp(uv_async_t* handle) {
+}
+
+NODE_EXTERN bool g_nw_enter_dom() {
+  if (!node::thread_ctx_created)
+    return false;
+  node::thread_ctx_st* tls_ctx = (node::thread_ctx_st*)uv_key_get(&node::thread_ctx_key);
+  if (tls_ctx && tls_ctx->env) {
+    v8::Isolate* isolate = tls_ctx->env->isolate();
+    v8::HandleScope handleScope(isolate);
+    v8::Local<v8::Context> context = isolate->GetEnteredOrMicrotaskContext();
+    if (context == tls_ctx->env->context()) {
+      context->Exit();
+      return true;
+    }
+  }
+  return false;
+}
+
+NODE_EXTERN void g_nw_leave_dom(bool reenter) {
+  if (!node::thread_ctx_created)
+    return;
+  node::thread_ctx_st* tls_ctx = (node::thread_ctx_st*)uv_key_get(&node::thread_ctx_key);
+  if (reenter && tls_ctx && tls_ctx->env) {
+    v8::Isolate* isolate = tls_ctx->env->isolate();
+    v8::HandleScope handleScope(isolate);
+    tls_ctx->env->context()->Enter();
+  }
+}
+
+NODE_EXTERN void g_msg_pump_ctor_osx(msg_pump_context_t* ctx, void* EmbedThreadRunner, void* kevent_hook, void* data, int worker_support) {
+  uv_init_nw(worker_support);
+  node::g_worker_support = worker_support;
+  // Add dummy handle for libuv, otherwise libuv would quit when there is
+  // nothing to do.
+  ctx->dummy_uv_handle = new uv_async_t;
+  uv_async_init(uv_default_loop(), (uv_async_t*)ctx->dummy_uv_handle, UvNoOp);
+
+  // Start worker that will interrupt main loop when having uv events.
+  ctx->embed_sem = new uv_sem_t;
+  uv_sem_init((uv_sem_t*)ctx->embed_sem, 0);
+  ctx->embed_thread = new uv_thread_t;
+  uv_thread_create((uv_thread_t*)ctx->embed_thread, (uv_thread_cb)EmbedThreadRunner, data);
+
+  uv_loop_t* uvloop = uv_default_loop();
+  uvloop->keventfunc = kevent_hook;
+
+  ctx->loop = uvloop;
+
+  // Execute loop for once.
+  uv_run(uv_default_loop(), UV_RUN_NOWAIT);
+  node::g_nw_uv_run = (UVRunFn)uv_run;
+}
+
+NODE_EXTERN void g_msg_pump_dtor_osx(msg_pump_context_t* ctx) {
+  uv_thread_join((uv_thread_t*)ctx->embed_thread);
+
+  delete (uv_async_t*)ctx->dummy_uv_handle;
+  ctx->dummy_uv_handle = nullptr;
+
+  delete (uv_sem_t*)ctx->embed_sem;
+  ctx->embed_sem = nullptr;
+
+  delete (uv_thread_t*)ctx->embed_thread;
+  ctx->embed_thread = nullptr;
+}
+
+NODE_EXTERN int g_nw_uvrun_nowait() {
+  return (*node::g_nw_uv_run)(uv_default_loop(), UV_RUN_NOWAIT);
+}
+
+NODE_EXTERN int g_uv_runloop_once() {
+  if (node::thread_ctx_created) {
+    node::thread_ctx_st* tls_ctx = (node::thread_ctx_st*)uv_key_get(&node::thread_ctx_key);
+    if (tls_ctx && tls_ctx->env) {
+      v8::Isolate* isolate = tls_ctx->env->isolate();
+      v8::HandleScope handleScope(isolate);
+      v8::Context::Scope cscope(tls_ctx->env->context());
+      return (*node::g_nw_uv_run)(uv_default_loop(), UV_RUN_ONCE);
+    }
+  }
+  return (*node::g_nw_uv_run)(uv_default_loop(), UV_RUN_ONCE);
+}
+
+NODE_EXTERN int g_uv_backend_timeout() {
+  return  uv_backend_timeout(uv_default_loop());
+}
+
+NODE_EXTERN void g_uv_sem_post(msg_pump_context_t* ctx) {
+  uv_sem_post((uv_sem_t*)ctx->embed_sem);
+}
+
+NODE_EXTERN int g_uv_backend_fd() {
+  return uv_backend_fd(uv_default_loop());
+}
+
+NODE_EXTERN void g_uv_sem_wait(msg_pump_context_t* ctx) {
+  uv_sem_wait((uv_sem_t*)ctx->embed_sem);
+}
+#endif
+}
diff -r -u --color up/node/src/node.h nw/node/src/node.h
--- up/node/src/node.h	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/node.h	2024-08-26 19:33:04.982595381 +0000
@@ -269,6 +269,8 @@
   // Initialize the process for predictable snapshot generation.
   kGeneratePredictableSnapshot = 1 << 14,
 
+  kNWJS = //disable all except OpenSSL and CLI options
+      ((1 << 14) - 1) ^ (kNoInitOpenSSL | kDisableCLIOptions),
   // Emulate the behavior of InitializeNodeWithArgs() when passing
   // a flags argument to the InitializeOncePerProcess() replacement
   // function.
@@ -594,7 +596,7 @@
 NODE_EXTERN v8::Local<v8::Context> NewContext(
     v8::Isolate* isolate,
     v8::Local<v8::ObjectTemplate> object_template =
-        v8::Local<v8::ObjectTemplate>());
+    v8::Local<v8::ObjectTemplate>(), bool create = true);
 
 // Runs Node.js-specific tweaks on an already constructed context
 // Return value indicates success of operation
@@ -1236,6 +1238,13 @@
     }                                                                 \
   }
 
+#define NODE_MODULE_REF(modname)                \
+  extern void _node_ref_ ## modname();
+
+#define NODE_MODULE_REF2(modname)                                      \
+  _node_ref_ ## modname();
+
+
 #define NODE_MODULE_CONTEXT_AWARE_X(modname, regfunc, priv, flags)    \
   extern "C" {                                                        \
     static node::node_module _module =                                \
@@ -1253,6 +1262,9 @@
     NODE_C_CTOR(_register_ ## modname) {                              \
       node_module_register(&_module);                                 \
     }                                                                 \
+  }                                                                   \
+  void _node_ref_ ## modname() { \
+    node_module_register(&_module); \
   }
 
 // Usage: `NODE_MODULE(NODE_GYP_MODULE_NAME, InitializerFunction)`
@@ -1548,24 +1560,14 @@
                            bool reset_handler = false);
 #endif  // _WIN32
 
-// Configure the layout of the JavaScript object with a cppgc::GarbageCollected
-// instance so that when the JavaScript object is reachable, the garbage
-// collected instance would have its Trace() method invoked per the cppgc
-// contract. To make it work, the process must have called
-// cppgc::InitializeProcess() before, which is usually the case for addons
-// loaded by the stand-alone Node.js executable. Embedders of Node.js can use
-// either need to call it themselves or make sure that
-// ProcessInitializationFlags::kNoInitializeCppgc is *not* set for cppgc to
-// work.
-// If the CppHeap is owned by Node.js, which is usually the case for addon,
-// the object must be created with at least two internal fields available,
-// and the first two internal fields would be configured by Node.js.
-// This may be superseded by a V8 API in the future, see
-// https://bugs.chromium.org/p/v8/issues/detail?id=13960. Until then this
-// serves as a helper for Node.js isolates.
-NODE_EXTERN void SetCppgcReference(v8::Isolate* isolate,
-                                   v8::Local<v8::Object> object,
-                                   void* wrappable);
+// This is kept as a compatibility layer for addons to wrap cppgc-managed
+// objects on Node.js versions without v8::Object::Wrap(). Addons created to
+// work with only Node.js versions with v8::Object::Wrap() should use that
+// instead.
+NODE_DEPRECATED("Use v8::Object::Wrap()",
+                NODE_EXTERN void SetCppgcReference(v8::Isolate* isolate,
+                                                   v8::Local<v8::Object> object,
+                                                   void* wrappable));
 
 }  // namespace node
 
diff -r -u --color up/node/src/node_binding.cc nw/node/src/node_binding.cc
--- up/node/src/node_binding.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/node_binding.cc	2024-08-26 19:33:04.982595381 +0000
@@ -1,3 +1,4 @@
+#include "uv.h"
 #include "node_binding.h"
 #include <atomic>
 #include "env-inl.h"
@@ -254,21 +255,40 @@
 static node_module* modlist_linked;
 static thread_local node_module* thread_local_modpending;
 
+uv_key_t thread_ctx_key;
+int thread_ctx_created = 0;
+int g_worker_support = 0;
+
 // This is set by node::Init() which is used by embedders
 bool node_is_initialized = false;
 
 extern "C" void node_module_register(void* m) {
-  struct node_module* mp = reinterpret_cast<struct node_module*>(m);
+  struct node_module* mp;
+  if (g_worker_support) {
+    mp = (struct node_module*)malloc(sizeof(struct node_module));
+    memcpy(mp, m, sizeof(struct node_module));
+  } else
+    mp = reinterpret_cast<struct node_module*>(m);
+  if (!thread_ctx_created) {
+    thread_ctx_created = 1;
+    uv_key_create(&thread_ctx_key);
+  }
+  thread_ctx_st* tls_ctx = (struct thread_ctx_st*)uv_key_get(&thread_ctx_key);
+  if (!tls_ctx) {
+    tls_ctx = (struct thread_ctx_st*)malloc(sizeof(struct thread_ctx_st));
+    memset(tls_ctx, 0, sizeof(struct thread_ctx_st));
+    uv_key_set(&thread_ctx_key, tls_ctx);
+  }
 
   if (mp->nm_flags & NM_F_INTERNAL) {
-    mp->nm_link = modlist_internal;
-    modlist_internal = mp;
+    mp->nm_link = tls_ctx->modlist_internal;
+    tls_ctx->modlist_internal = mp;
   } else if (!node_is_initialized) {
     // "Linked" modules are included as part of the node project.
     // Like builtins they are registered *before* node::Init runs.
     mp->nm_flags = NM_F_LINKED;
-    mp->nm_link = modlist_linked;
-    modlist_linked = mp;
+    mp->nm_link = tls_ctx->modlist_linked;
+    tls_ctx->modlist_linked = mp;
   } else {
     thread_local_modpending = mp;
   }
@@ -437,6 +457,7 @@
   auto context = env->context();
 
   CHECK_NULL(thread_local_modpending);
+  thread_ctx_st* tls_ctx = (struct thread_ctx_st*)uv_key_get(&thread_ctx_key);
 
   if (args.Length() < 2) {
     return THROW_ERR_MISSING_ARGS(
@@ -505,7 +526,9 @@
         return true;
       } else {
         mp = dlib->GetSavedModuleFromGlobalHandleMap();
-        if (mp == nullptr || mp->nm_context_register_func == nullptr) {
+        //NWJS: the checking of context aware module is not needed
+        //since this is supported in NW worker
+        if (mp == nullptr) { // || mp->nm_context_register_func == nullptr) {
           dlib->Close();
           THROW_ERR_DLOPEN_FAILED(
               env, "Module did not self-register: '%s'.", *filename);
@@ -545,6 +568,7 @@
 
     // Do not keep the lock while running userland addon loading code.
     Mutex::ScopedUnlock unlock(lock);
+
     if (mp->nm_context_register_func != nullptr) {
       mp->nm_context_register_func(exports, module, context, mp->nm_priv);
     } else if (mp->nm_register_func != nullptr) {
@@ -632,7 +656,8 @@
   node::Utf8Value module_v(isolate, module);
   Local<Object> exports;
 
-  node_module* mod = FindModule(modlist_internal, *module_v, NM_F_INTERNAL);
+  thread_ctx_st* tls_ctx = (struct thread_ctx_st*)uv_key_get(&thread_ctx_key);
+  node_module* mod = FindModule(tls_ctx->modlist_internal, *module_v, NM_F_INTERNAL);
   if (mod != nullptr) {
     exports = InitInternalBinding(realm, mod);
     realm->internal_bindings.insert(mod);
diff -r -u --color up/node/src/node_binding.h nw/node/src/node_binding.h
--- up/node/src/node_binding.h	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/node_binding.h	2024-08-26 19:33:04.982595381 +0000
@@ -102,6 +102,22 @@
 // Globals per process
 // This is set by node::Init() which is used by embedders
 extern bool node_is_initialized;
+extern int g_worker_support;
+extern int thread_ctx_created;
+extern uv_key_t thread_ctx_key;
+
+struct thread_ctx_st {
+  node::Environment* env;
+  node::node_module* modpending;
+  node::node_module* modlist_builtin;
+  node::node_module* modlist_linked;
+  node::node_module* modlist_addon;
+  node::node_module* modlist_internal;
+  int handle_counter;
+  int quit_flag;
+  int close_quit_timer_done;
+  int close_async_handle_done;
+};
 
 namespace binding {
 
diff -r -u --color up/node/src/node_blob.cc nw/node/src/node_blob.cc
--- up/node/src/node_blob.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/node_blob.cc	2024-08-26 19:33:04.982595381 +0000
@@ -247,7 +247,7 @@
 void Blob::GetReader(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   Blob* blob;
-  ASSIGN_OR_RETURN_UNWRAP(&blob, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&blob, args.This());
 
   BaseObjectPtr<Blob::Reader> reader =
       Blob::Reader::Create(env, BaseObjectPtr<Blob>(blob));
@@ -257,7 +257,7 @@
 void Blob::ToSlice(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   Blob* blob;
-  ASSIGN_OR_RETURN_UNWRAP(&blob, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&blob, args.This());
   CHECK(args[0]->IsUint32());
   CHECK(args[1]->IsUint32());
   size_t start = args[0].As<Uint32>()->Value();
@@ -326,7 +326,7 @@
 void Blob::Reader::Pull(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   Blob::Reader* reader;
-  ASSIGN_OR_RETURN_UNWRAP(&reader, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&reader, args.This());
 
   CHECK(args[0]->IsFunction());
   Local<Function> fn = args[0].As<Function>();
diff -r -u --color up/node/src/node_buffer.cc nw/node/src/node_buffer.cc
--- up/node/src/node_buffer.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/node_buffer.cc	2024-08-26 19:33:04.982595381 +0000
@@ -123,7 +123,7 @@
       ArrayBuffer::NewBackingStore(data, length, [](void*, size_t, void* arg) {
         static_cast<CallbackInfo*>(arg)->OnBackingStoreFree();
       }, self);
-  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
+  Local<ArrayBuffer> ab = ArrayBuffer::NewNode(env->isolate(), std::move(bs));
 
   // V8 simply ignores the BackingStore deleter callback if data == nullptr,
   // but our API contract requires it being called.
@@ -1188,7 +1188,7 @@
                                      sizeof(*zero_fill_field),
                                      [](void*, size_t, void*) {},
                                      nullptr);
-    ab = ArrayBuffer::New(env->isolate(), std::move(backing));
+    ab = ArrayBuffer::NewNode(env->isolate(), std::move(backing));
   }
 
   ab->SetPrivate(
diff -r -u --color up/node/src/node_builtins.cc nw/node/src/node_builtins.cc
--- up/node/src/node_builtins.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/node_builtins.cc	2024-08-26 19:33:04.986595380 +0000
@@ -11,7 +11,6 @@
 namespace builtins {
 
 using v8::Context;
-using v8::DEFAULT;
 using v8::EscapableHandleScope;
 using v8::Function;
 using v8::FunctionCallbackInfo;
@@ -265,7 +264,7 @@
   std::string filename_s = std::string("node:") + id;
   Local<String> filename =
       OneByteString(isolate, filename_s.c_str(), filename_s.size());
-  ScriptOrigin origin(isolate, filename, 0, 0, true);
+  ScriptOrigin origin(filename, 0, 0, true);
 
   BuiltinCodeCacheData cached_data{};
   {
@@ -281,7 +280,7 @@
     }
   }
 
-  const bool has_cache = cached_data.data != nullptr;
+  const bool has_cache = false; //cached_data.data != nullptr;
   ScriptCompiler::CompileOptions options =
       has_cache ? ScriptCompiler::kConsumeCodeCache
                 : ScriptCompiler::kNoCompileOptions;
@@ -348,6 +347,7 @@
                                                                : "is accepted");
   }
 
+#if 0
   if (result == Result::kWithoutCache && optional_realm != nullptr &&
       !optional_realm->env()->isolate_data()->is_building_snapshot()) {
     // We failed to accept this cache, maybe because it was rejected, maybe
@@ -358,6 +358,7 @@
     // space (which is what isolates pending to be serialized have).
     SaveCodeCache(id, fun);
   }
+#endif
 
   return scope.Escape(fun);
 }
@@ -710,7 +711,6 @@
                                 nullptr,
                                 Local<Value>(),
                                 None,
-                                DEFAULT,
                                 SideEffectType::kHasNoSideEffect);
 
   target->SetNativeDataProperty(FIXED_ONE_BYTE_STRING(isolate, "builtinIds"),
@@ -718,7 +718,6 @@
                                 nullptr,
                                 Local<Value>(),
                                 None,
-                                DEFAULT,
                                 SideEffectType::kHasNoSideEffect);
 
   target->SetNativeDataProperty(
@@ -727,7 +726,6 @@
       nullptr,
       Local<Value>(),
       None,
-      DEFAULT,
       SideEffectType::kHasNoSideEffect);
 
   target->SetNativeDataProperty(FIXED_ONE_BYTE_STRING(isolate, "natives"),
@@ -735,7 +733,6 @@
                                 nullptr,
                                 Local<Value>(),
                                 None,
-                                DEFAULT,
                                 SideEffectType::kHasNoSideEffect);
 
   SetMethod(isolate, target, "getCacheUsage", BuiltinLoader::GetCacheUsage);
diff -r -u --color up/node/src/node_contextify.cc nw/node/src/node_contextify.cc
--- up/node/src/node_contextify.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/node_contextify.cc	2024-08-26 19:33:04.986595380 +0000
@@ -36,6 +36,7 @@
 #include "util-inl.h"
 
 namespace node {
+extern bool node_is_nwjs;
 namespace contextify {
 
 using errors::TryCatchScope;
@@ -264,6 +265,12 @@
   // the context from its constructor.
   v8_context->SetEmbedderData(ContextEmbedderIndex::kSandboxObject,
                               sandbox_obj);
+  if (node_is_nwjs) {
+    void* data = env->context()->GetAlignedPointerFromEmbedderData(2); //v8ContextPerContextDataIndex
+    if (!((uintptr_t)data & 1))
+      v8_context->SetAlignedPointerInEmbedderData(2, data);
+    v8_context->SetAlignedPointerInEmbedderData(50, (void*)0x08110800);
+  }
 
   // Delegate the code generation validation to
   // node::ModifyCodeGenerationFromStrings.
@@ -865,6 +872,7 @@
   ContextifyScript* contextify_script =
       new ContextifyScript(env, args.This());
 
+#if 0
   if (*TRACE_EVENT_API_GET_CATEGORY_GROUP_ENABLED(
           TRACING_CATEGORY_NODE2(vm, script)) != 0) {
     Utf8Value fn(isolate, filename);
@@ -873,6 +881,7 @@
                        "filename",
                        TRACE_STR_COPY(*fn));
   }
+#endif
 
   ScriptCompiler::CachedData* cached_data = nullptr;
   if (!cached_data_buf.IsEmpty()) {
@@ -886,7 +895,7 @@
   host_defined_options->Set(
       isolate, loader::HostDefinedOptions::kID, id_symbol);
 
-  ScriptOrigin origin(isolate,
+  ScriptOrigin origin(
                       filename,
                       line_offset,                          // line offset
                       column_offset,                        // column offset
@@ -1006,7 +1015,7 @@
                                      Local<String> filename,
                                      Local<String> content,
                                      std::vector<Local<String>>* parameters) {
-  ScriptOrigin script_origin(context->GetIsolate(), filename, 0, 0, true);
+  ScriptOrigin script_origin(filename, 0, 0, true);
   ScriptCompiler::Source script_source(content, script_origin);
 
   return ScriptCompiler::CompileFunction(context,
@@ -1027,7 +1036,7 @@
     const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   ContextifyScript* wrapped_script;
-  ASSIGN_OR_RETURN_UNWRAP(&wrapped_script, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&wrapped_script, args.This());
   Local<UnboundScript> unbound_script =
       PersistentToLocal::Default(env->isolate(), wrapped_script->script_);
   std::unique_ptr<ScriptCompiler::CachedData> cached_data(
@@ -1047,7 +1056,7 @@
   Environment* env = Environment::GetCurrent(args);
 
   ContextifyScript* wrapped_script;
-  ASSIGN_OR_RETURN_UNWRAP(&wrapped_script, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&wrapped_script, args.This());
 
   CHECK_EQ(args.Length(), 5);
   CHECK(args[0]->IsObject() || args[0]->IsNull());
@@ -1108,7 +1117,7 @@
 
   if (!env->can_call_into_js())
     return false;
-  if (!ContextifyScript::InstanceOf(env, args.Holder())) {
+  if (!ContextifyScript::InstanceOf(env, args.This())) {
     THROW_ERR_INVALID_THIS(
         env,
         "Script methods can only be called on script instances.");
@@ -1116,9 +1125,8 @@
   }
 
   TryCatchScope try_catch(env);
-  Isolate::SafeForTerminationScope safe_for_termination(env->isolate());
   ContextifyScript* wrapped_script;
-  ASSIGN_OR_RETURN_UNWRAP(&wrapped_script, args.Holder(), false);
+  ASSIGN_OR_RETURN_UNWRAP(&wrapped_script, args.This(), false);
   Local<UnboundScript> unbound_script =
       PersistentToLocal::Default(env->isolate(), wrapped_script->script_);
   Local<Script> script = unbound_script->BindToCurrentContext();
@@ -1270,7 +1278,7 @@
   Local<PrimitiveArray> host_defined_options =
       loader::ModuleWrap::GetHostDefinedOptions(isolate, id_symbol);
 
-  ScriptOrigin origin(isolate,
+  ScriptOrigin origin(
                       filename,
                       line_offset,     // line offset
                       column_offset,   // column offset
@@ -1452,7 +1460,7 @@
   Local<Symbol> symbol = env->vm_dynamic_import_default_internal();
   Local<PrimitiveArray> hdo =
       loader::ModuleWrap::GetHostDefinedOptions(isolate, symbol);
-  ScriptOrigin origin(isolate,
+  ScriptOrigin origin(
                       filename,
                       0,               // line offset
                       0,               // column offset
diff -r -u --color up/node/src/node_dir.cc nw/node/src/node_dir.cc
--- up/node/src/node_dir.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/node_dir.cc	2024-08-26 19:33:04.986595380 +0000
@@ -187,7 +187,7 @@
   CHECK_GE(argc, 1);
 
   DirHandle* dir;
-  ASSIGN_OR_RETURN_UNWRAP(&dir, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&dir, args.This());
 
   dir->closing_ = false;
   dir->closed_ = true;
@@ -288,7 +288,7 @@
   const enum encoding encoding = ParseEncoding(isolate, args[0], UTF8);
 
   DirHandle* dir;
-  ASSIGN_OR_RETURN_UNWRAP(&dir, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&dir, args.This());
 
   CHECK(args[1]->IsNumber());
   uint64_t buffer_size = static_cast<uint64_t>(args[1].As<Number>()->Value());
diff -r -u --color up/node/src/node_errors.cc nw/node/src/node_errors.cc
--- up/node/src/node_errors.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/node_errors.cc	2024-08-26 19:33:04.986595380 +0000
@@ -36,6 +36,8 @@
 using v8::Undefined;
 using v8::Value;
 
+extern bool node_is_nwjs;
+
 bool IsExceptionDecorated(Environment* env, Local<Value> er) {
   if (!er.IsEmpty() && er->IsObject()) {
     Local<Object> err_obj = er.As<Object>();
@@ -1195,9 +1197,12 @@
     // error is supposed to be thrown at this point.
     // Since we don't have access to Environment here, there is not
     // much we can do, so we just print whatever is useful and crash.
+#if 0
     PrintToStderrAndFlush(
         FormatCaughtException(isolate, context, error, message));
     ABORT();
+#endif
+    return;
   }
 
   // Invoke process._fatalException() to give user a chance to handle it.
@@ -1205,16 +1210,17 @@
   // monkey-patchable.
   Local<Object> process_object = env->process_object();
   Local<String> fatal_exception_string = env->fatal_exception_string();
-  Local<Value> fatal_exception_function =
+  Local<Value> fatal_exception_function_value =
       process_object->Get(env->context(),
                           fatal_exception_string).ToLocalChecked();
   // If the exception happens before process._fatalException is attached
   // during bootstrap, or if the user has patched it incorrectly, exit
   // the current Node.js instance.
-  if (!fatal_exception_function->IsFunction()) {
+  int exit_code = 0;
+  if (!fatal_exception_function_value->IsFunction()) {
     ReportFatalException(
         env, error, message, EnhanceFatalException::kDontEnhance);
-    env->Exit(ExitCode::kInvalidFatalExceptionMonkeyPatching);
+    exit_code = (int)ExitCode::kInvalidFatalExceptionMonkeyPatching;
     return;
   }
 
@@ -1232,7 +1238,7 @@
     Local<Value> argv[2] = { error,
                              Boolean::New(env->isolate(), from_promise) };
 
-    maybe_handled = fatal_exception_function.As<Function>()->Call(
+    maybe_handled = fatal_exception_function_value.As<Function>()->Call(
         env->context(), process_object, arraysize(argv), argv);
   }
 
@@ -1261,7 +1267,10 @@
 
   // If the global uncaught exception handler sets process.exitCode,
   // exit with that code. Otherwise, exit with `ExitCode::kGenericUserError`.
-  env->Exit(env->exit_code(ExitCode::kGenericUserError));
+  exit_code = (int)env->exit_code(ExitCode::kGenericUserError);
+  if (!node_is_nwjs && exit_code) {
+    exit(exit_code);
+  }
 }
 
 void TriggerUncaughtException(Isolate* isolate, const v8::TryCatch& try_catch) {
diff -r -u --color up/node/src/node_external_reference.h nw/node/src/node_external_reference.h
--- up/node/src/node_external_reference.h	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/node_external_reference.h	2024-08-26 19:33:04.986595380 +0000
@@ -63,8 +63,6 @@
   V(CFunctionWithBool)                                                         \
   V(const v8::CFunctionInfo*)                                                  \
   V(v8::FunctionCallback)                                                      \
-  V(v8::AccessorGetterCallback)                                                \
-  V(v8::AccessorSetterCallback)                                                \
   V(v8::AccessorNameGetterCallback)                                            \
   V(v8::AccessorNameSetterCallback)                                            \
   V(v8::NamedPropertyGetterCallback)                                           \
diff -r -u --color up/node/src/node_file.cc nw/node/src/node_file.cc
--- up/node/src/node_file.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/node_file.cc	2024-08-26 19:33:04.986595380 +0000
@@ -502,7 +502,7 @@
 
 void FileHandle::Close(const FunctionCallbackInfo<Value>& args) {
   FileHandle* fd;
-  ASSIGN_OR_RETURN_UNWRAP(&fd, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&fd, args.This());
   Local<Promise> ret;
   if (!fd->ClosePromise().ToLocal(&ret)) return;
   args.GetReturnValue().Set(ret);
@@ -511,7 +511,7 @@
 
 void FileHandle::ReleaseFD(const FunctionCallbackInfo<Value>& args) {
   FileHandle* fd;
-  ASSIGN_OR_RETURN_UNWRAP(&fd, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&fd, args.This());
   fd->Release();
 }
 
@@ -977,9 +977,9 @@
     THROW_IF_INSUFFICIENT_PERMISSIONS(
         env, permission::PermissionScope::kFileSystemRead, path.ToStringView());
     FSReqWrapSync req_wrap_sync("access", *path);
-    FS_SYNC_TRACE_BEGIN(access);
+    //FS_SYNC_TRACE_BEGIN(access);
     SyncCallAndThrowOnError(env, &req_wrap_sync, uv_fs_access, *path, mode);
-    FS_SYNC_TRACE_END(access);
+    //FS_SYNC_TRACE_END(access);
   }
 }
 
diff -r -u --color up/node/src/node_http2.cc nw/node/src/node_http2.cc
--- up/node/src/node_http2.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/node_http2.cc	2024-08-26 19:33:04.986595380 +0000
@@ -730,6 +730,7 @@
 
 void Http2Stream::EmitStatistics() {
   CHECK_NOT_NULL(session());
+#if 0
   if (LIKELY(!HasHttp2Observer(env())))
     return;
 
@@ -747,9 +748,11 @@
     if (HasHttp2Observer(env))
       entry->Notify(env);
   });
+#endif
 }
 
 void Http2Session::EmitStatistics() {
+#if 0
   if (LIKELY(!HasHttp2Observer(env())))
     return;
 
@@ -767,6 +770,7 @@
     if (HasHttp2Observer(env))
       entry->Notify(env);
   });
+#endif
 }
 
 // Closes the session and frees the associated resources
@@ -2107,7 +2111,7 @@
 // https://github.com/nodejs/node/issues/35475
 void Http2Session::Receive(const FunctionCallbackInfo<Value>& args) {
   Http2Session* session;
-  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&session, args.This());
   CHECK(args[0]->IsObject());
 
   ArrayBufferViewContents<char> buffer(args[0]);
@@ -2700,7 +2704,7 @@
 void Http2Session::SetNextStreamID(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   Http2Session* session;
-  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&session, args.This());
   int32_t id = args[0]->Int32Value(env->context()).ToChecked();
   if (nghttp2_session_set_next_stream_id(session->session(), id) < 0) {
     Debug(session, "failed to set next stream id to %d", id);
@@ -2717,7 +2721,7 @@
     const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   Http2Session* session;
-  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&session, args.This());
 
   int32_t window_size = args[0]->Int32Value(env->context()).ToChecked();
 
@@ -2735,7 +2739,7 @@
 template <get_setting fn, bool local>
 void Http2Session::RefreshSettings(const FunctionCallbackInfo<Value>& args) {
   Http2Session* session;
-  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&session, args.This());
   Http2Settings::Update(session, fn, local);
   Debug(session, "settings refreshed for session");
 }
@@ -2745,7 +2749,7 @@
 // TypedArray so those can be read in JS land.
 void Http2Session::RefreshState(const FunctionCallbackInfo<Value>& args) {
   Http2Session* session;
-  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&session, args.This());
   Debug(session, "refreshing state");
 
   AliasedFloat64Array& buffer = session->http2_state()->session_state_buffer;
@@ -2789,7 +2793,7 @@
 // Binds the Http2Session with a StreamBase used for i/o
 void Http2Session::Consume(const FunctionCallbackInfo<Value>& args) {
   Http2Session* session;
-  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&session, args.This());
   CHECK(args[0]->IsObject());
   session->Consume(args[0].As<Object>());
 }
@@ -2797,7 +2801,7 @@
 // Destroys the Http2Session instance and renders it unusable
 void Http2Session::Destroy(const FunctionCallbackInfo<Value>& args) {
   Http2Session* session;
-  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&session, args.This());
   Debug(session, "destroying session");
   Environment* env = Environment::GetCurrent(args);
   Local<Context> context = env->context();
@@ -2810,7 +2814,7 @@
 // or the Http2Stream object.
 void Http2Session::Request(const FunctionCallbackInfo<Value>& args) {
   Http2Session* session;
-  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&session, args.This());
   Environment* env = session->env();
 
   Local<Array> headers = args[0].As<Array>();
@@ -2861,7 +2865,7 @@
   Environment* env = Environment::GetCurrent(args);
   Local<Context> context = env->context();
   Http2Session* session;
-  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&session, args.This());
 
   uint32_t code = args[0]->Uint32Value(context).ToChecked();
   int32_t lastStreamID = args[1]->Int32Value(context).ToChecked();
@@ -2881,7 +2885,7 @@
   Isolate* isolate = env->isolate();
   HandleScope scope(isolate);
   Http2Session* session;
-  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&session, args.This());
 
   uint32_t length = session->chunks_sent_since_last_write_;
 
@@ -2899,7 +2903,7 @@
   Environment* env = Environment::GetCurrent(args);
   Local<Context> context = env->context();
   Http2Stream* stream;
-  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&stream, args.This());
   uint32_t code = args[0]->Uint32Value(context).ToChecked();
   Debug(stream, "sending rst_stream with code %d", code);
   stream->SubmitRstStream(code);
@@ -2910,7 +2914,7 @@
 void Http2Stream::Respond(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   Http2Stream* stream;
-  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&stream, args.This());
 
   Local<Array> headers = args[0].As<Array>();
   int32_t options = args[1]->Int32Value(env->context()).ToChecked();
@@ -2927,7 +2931,7 @@
 void Http2Stream::Info(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   Http2Stream* stream;
-  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&stream, args.This());
 
   Local<Array> headers = args[0].As<Array>();
 
@@ -2938,7 +2942,7 @@
 void Http2Stream::Trailers(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   Http2Stream* stream;
-  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&stream, args.This());
 
   Local<Array> headers = args[0].As<Array>();
 
@@ -2949,14 +2953,14 @@
 // Grab the numeric id of the Http2Stream
 void Http2Stream::GetID(const FunctionCallbackInfo<Value>& args) {
   Http2Stream* stream;
-  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&stream, args.This());
   args.GetReturnValue().Set(stream->id());
 }
 
 // Destroy the Http2Stream, rendering it no longer usable
 void Http2Stream::Destroy(const FunctionCallbackInfo<Value>& args) {
   Http2Stream* stream;
-  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&stream, args.This());
   Debug(stream, "destroying stream");
   stream->Destroy();
 }
@@ -2965,7 +2969,7 @@
 void Http2Stream::PushPromise(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   Http2Stream* parent;
-  ASSIGN_OR_RETURN_UNWRAP(&parent, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&parent, args.This());
 
   Local<Array> headers = args[0].As<Array>();
   int32_t options = args[1]->Int32Value(env->context()).ToChecked();
@@ -2991,7 +2995,7 @@
 void Http2Stream::Priority(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   Http2Stream* stream;
-  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&stream, args.This());
 
   CHECK_EQ(stream->SubmitPriority(
       Http2Priority(env, args[0], args[1], args[2]),
@@ -3004,7 +3008,7 @@
 // TypedArray so that the state can be read by JS.
 void Http2Stream::RefreshState(const FunctionCallbackInfo<Value>& args) {
   Http2Stream* stream;
-  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&stream, args.This());
 
   Debug(stream, "refreshing state");
 
@@ -3061,7 +3065,7 @@
 void Http2Session::AltSvc(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   Http2Session* session;
-  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&session, args.This());
 
   int32_t id = args[0]->Int32Value(env->context()).ToChecked();
 
@@ -3092,7 +3096,7 @@
   Environment* env = Environment::GetCurrent(args);
   Local<Context> context = env->context();
   Http2Session* session;
-  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&session, args.This());
 
   Local<String> origin_string = args[0].As<String>();
   size_t count = args[1]->Int32Value(context).ToChecked();
@@ -3103,7 +3107,7 @@
 // Submits a PING frame to be sent to the connected peer.
 void Http2Session::Ping(const FunctionCallbackInfo<Value>& args) {
   Http2Session* session;
-  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&session, args.This());
 
   // A PING frame may have exactly 8 bytes of payload data. If not provided,
   // then the current hrtime will be used as the payload.
@@ -3121,7 +3125,7 @@
 // Submits a SETTINGS frame for the Http2Session
 void Http2Session::Settings(const FunctionCallbackInfo<Value>& args) {
   Http2Session* session;
-  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&session, args.This());
   CHECK(args[0]->IsFunction());
   args.GetReturnValue().Set(session->AddSettings(args[0].As<Function>()));
 }
diff -r -u --color up/node/src/node_http_parser.cc nw/node/src/node_http_parser.cc
--- up/node/src/node_http_parser.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/node_http_parser.cc	2024-08-26 19:33:04.986595380 +0000
@@ -563,7 +563,7 @@
 
   static void Close(const FunctionCallbackInfo<Value>& args) {
     Parser* parser;
-    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());
+    ASSIGN_OR_RETURN_UNWRAP(&parser, args.This());
 
     delete parser;
   }
@@ -571,7 +571,7 @@
 
   static void Free(const FunctionCallbackInfo<Value>& args) {
     Parser* parser;
-    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());
+    ASSIGN_OR_RETURN_UNWRAP(&parser, args.This());
 
     // Since the Parser destructor isn't going to run the destroy() callbacks
     // it needs to be triggered manually.
@@ -581,7 +581,7 @@
 
   static void Remove(const FunctionCallbackInfo<Value>& args) {
     Parser* parser;
-    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());
+    ASSIGN_OR_RETURN_UNWRAP(&parser, args.This());
 
     if (parser->connectionsList_ != nullptr) {
       parser->connectionsList_->Pop(parser);
@@ -605,7 +605,7 @@
   // var bytesParsed = parser->execute(buffer);
   static void Execute(const FunctionCallbackInfo<Value>& args) {
     Parser* parser;
-    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());
+    ASSIGN_OR_RETURN_UNWRAP(&parser, args.This());
 
     ArrayBufferViewContents<char> buffer(args[0]);
 
@@ -618,7 +618,7 @@
 
   static void Finish(const FunctionCallbackInfo<Value>& args) {
     Parser* parser;
-    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());
+    ASSIGN_OR_RETURN_UNWRAP(&parser, args.This());
 
     Local<Value> ret = parser->Execute(nullptr, 0);
 
@@ -661,7 +661,7 @@
 
     CHECK(type == HTTP_REQUEST || type == HTTP_RESPONSE);
     Parser* parser;
-    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());
+    ASSIGN_OR_RETURN_UNWRAP(&parser, args.This());
     // Should always be called from the same context.
     CHECK_EQ(env, parser->env());
 
@@ -695,7 +695,7 @@
   static void Pause(const FunctionCallbackInfo<Value>& args) {
     Environment* env = Environment::GetCurrent(args);
     Parser* parser;
-    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());
+    ASSIGN_OR_RETURN_UNWRAP(&parser, args.This());
     // Should always be called from the same context.
     CHECK_EQ(env, parser->env());
 
@@ -709,7 +709,7 @@
 
   static void Consume(const FunctionCallbackInfo<Value>& args) {
     Parser* parser;
-    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());
+    ASSIGN_OR_RETURN_UNWRAP(&parser, args.This());
     CHECK(args[0]->IsObject());
     StreamBase* stream = StreamBase::FromObject(args[0].As<Object>());
     CHECK_NOT_NULL(stream);
@@ -719,7 +719,7 @@
 
   static void Unconsume(const FunctionCallbackInfo<Value>& args) {
     Parser* parser;
-    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());
+    ASSIGN_OR_RETURN_UNWRAP(&parser, args.This());
 
     // Already unconsumed
     if (parser->stream_ == nullptr)
@@ -731,7 +731,7 @@
 
   static void GetCurrentBuffer(const FunctionCallbackInfo<Value>& args) {
     Parser* parser;
-    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());
+    ASSIGN_OR_RETURN_UNWRAP(&parser, args.This());
 
     Local<Object> ret = Buffer::Copy(
         parser->env(),
@@ -743,7 +743,7 @@
 
   static void Duration(const FunctionCallbackInfo<Value>& args) {
     Parser* parser;
-    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());
+    ASSIGN_OR_RETURN_UNWRAP(&parser, args.This());
 
     if (parser->last_message_start_ == 0) {
       args.GetReturnValue().Set(0);
@@ -756,7 +756,7 @@
 
   static void HeadersCompleted(const FunctionCallbackInfo<Value>& args) {
     Parser* parser;
-    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());
+    ASSIGN_OR_RETURN_UNWRAP(&parser, args.This());
 
     args.GetReturnValue().Set(parser->headers_completed_);
   }
@@ -1087,7 +1087,7 @@
 
   ConnectionsList* list;
 
-  ASSIGN_OR_RETURN_UNWRAP(&list, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&list, args.This());
 
   std::vector<Local<Value>> result;
   result.reserve(list->all_connections_.size());
@@ -1104,7 +1104,7 @@
 
   ConnectionsList* list;
 
-  ASSIGN_OR_RETURN_UNWRAP(&list, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&list, args.This());
 
   std::vector<Local<Value>> result;
   result.reserve(list->all_connections_.size());
@@ -1123,7 +1123,7 @@
 
   ConnectionsList* list;
 
-  ASSIGN_OR_RETURN_UNWRAP(&list, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&list, args.This());
 
   std::vector<Local<Value>> result;
   result.reserve(list->active_connections_.size());
@@ -1140,7 +1140,7 @@
 
   ConnectionsList* list;
 
-  ASSIGN_OR_RETURN_UNWRAP(&list, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&list, args.This());
   CHECK(args[0]->IsNumber());
   CHECK(args[1]->IsNumber());
   uint64_t headers_timeout =
diff -r -u --color up/node/src/node_internals.h nw/node/src/node_internals.h
--- up/node/src/node_internals.h	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/node_internals.h	2024-08-26 19:33:04.990595379 +0000
@@ -55,6 +55,8 @@
 // Forward declaration
 class Environment;
 
+NODE_EXTERN v8::Handle<v8::Value> CallTickCallback(Environment* env, const v8::Handle<v8::Value> ret);
+
 // Convert a struct sockaddr to a { address: '1.2.3.4', port: 1234 } JS object.
 // Sets address and port properties on the info object and returns it.
 // If |info| is omitted, a new object is returned.
@@ -66,9 +68,8 @@
 template <typename T, int (*F)(const typename T::HandleType*, sockaddr*, int*)>
 void GetSockOrPeerName(const v8::FunctionCallbackInfo<v8::Value>& args) {
   T* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap,
-                          args.Holder(),
-                          args.GetReturnValue().Set(UV_EBADF));
+  ASSIGN_OR_RETURN_UNWRAP(
+      &wrap, args.This(), args.GetReturnValue().Set(UV_EBADF));
   CHECK(args[0]->IsObject());
   sockaddr_storage storage;
   int addrlen = sizeof(storage);
@@ -124,6 +125,7 @@
   void* AllocateUninitialized(size_t size) override;
   void Free(void* data, size_t size) override;
   void* Reallocate(void* data, size_t old_size, size_t size) override;
+  void Free(void* data, size_t size, AllocationMode mode) override;
   virtual void RegisterPointer(void* data, size_t size) {
     total_mem_usage_.fetch_add(size, std::memory_order_relaxed);
   }
diff -r -u --color up/node/src/node_main_instance.cc nw/node/src/node_main_instance.cc
--- up/node/src/node_main_instance.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/node_main_instance.cc	2024-08-26 19:33:04.990595379 +0000
@@ -30,6 +30,8 @@
 using v8::Local;
 using v8::Locker;
 
+extern bool node_is_nwjs;
+
 NodeMainInstance::NodeMainInstance(const SnapshotData* snapshot_data,
                                    uv_loop_t* event_loop,
                                    MultiIsolatePlatform* platform,
@@ -43,6 +45,8 @@
       isolate_data_(),
       isolate_params_(std::make_unique<Isolate::CreateParams>()),
       snapshot_data_(snapshot_data) {
+  if (node_is_nwjs)
+    array_buffer_allocator_.reset();
   isolate_params_->array_buffer_allocator = array_buffer_allocator_.get();
 
   isolate_ =
diff -r -u --color up/node/src/node_messaging.cc nw/node/src/node_messaging.cc
--- up/node/src/node_messaging.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/node_messaging.cc	2024-08-26 19:33:04.990595379 +0000
@@ -301,6 +301,14 @@
   SerializerDelegate(Environment* env, Local<Context> context, Message* m)
       : env_(env), context_(context), msg_(m) {}
 
+  void* ReallocateBufferMemory(void* old_buffer, size_t size, size_t* actual_size) override {
+    *actual_size = size;
+    return realloc(old_buffer, size);
+  }
+
+  void FreeBufferMemory(void* buffer) override {
+    free(buffer);
+  }
   void ThrowDataCloneError(Local<String> message) override {
     ThrowDataCloneException(context_, message);
   }
diff -r -u --color up/node/src/node_metadata.cc nw/node/src/node_metadata.cc
--- up/node/src/node_metadata.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/node_metadata.cc	2024-08-26 19:33:04.990595379 +0000
@@ -29,7 +29,8 @@
 #endif
 #endif  // HAVE_OPENSSL
 
-#ifdef OPENSSL_INFO_QUIC
+#if 0
+//#ifdef OPENSSL_INFO_QUIC
 #include <ngtcp2/version.h>
 #include <nghttp3/version.h>
 #endif
@@ -124,7 +125,7 @@
   unicode = U_UNICODE_VERSION;
 #endif  // NODE_HAVE_I18N_SUPPORT
 
-#ifdef OPENSSL_INFO_QUIC
+#if 0 //def OPENSSL_INFO_QUIC
   ngtcp2 = NGTCP2_VERSION;
   nghttp3 = NGHTTP3_VERSION;
 #endif
diff -r -u --color up/node/src/node_options.cc nw/node/src/node_options.cc
--- up/node/src/node_options.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/node_options.cc	2024-08-26 19:33:04.990595379 +0000
@@ -1057,8 +1057,8 @@
             &PerProcessOptions::trace_sigint,
             kAllowedInEnvvar);
 
-  Insert(iop, &PerProcessOptions::get_per_isolate_options);
-
+  //Insert(iop, &PerProcessOptions::get_per_isolate_options);
+#if 0
   AddOption("--node-memory-debug",
             "Run with extra debug checks for memory leaks in Node.js itself",
             NoOp{},
@@ -1081,6 +1081,7 @@
       "performance.",
       &PerProcessOptions::disable_wasm_trap_handler,
       kAllowedInEnvvar);
+#endif
 }
 
 inline std::string RemoveBrackets(const std::string& host) {
diff -r -u --color up/node/src/node_perf.cc nw/node/src/node_perf.cc
--- up/node/src/node_perf.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/node_perf.cc	2024-08-26 19:33:04.990595379 +0000
@@ -121,10 +121,12 @@
 
 void PerformanceState::Mark(PerformanceMilestone milestone, uint64_t ts) {
   this->milestones[milestone] = static_cast<double>(ts);
+#if 0
   TRACE_EVENT_INSTANT_WITH_TIMESTAMP0(
       TRACING_CATEGORY_NODE1(bootstrap),
       GetPerformanceMilestoneName(milestone),
       TRACE_EVENT_SCOPE_THREAD, ts / 1000);
+#endif
 }
 
 void SetupPerformanceObservers(const FunctionCallbackInfo<Value>& args) {
@@ -222,6 +224,7 @@
 
 static void InstallGarbageCollectionTracking(
     const FunctionCallbackInfo<Value>& args) {
+#if 0
   Environment* env = Environment::GetCurrent(args);
   // Reset current_gc_type to 0
   env->performance_state()->current_gc_type = 0;
@@ -230,6 +233,7 @@
   env->isolate()->AddGCEpilogueCallback(MarkGarbageCollectionEnd,
                                         static_cast<void*>(env));
   env->AddCleanupHook(GarbageCollectionCleanupHook, env);
+#endif
 }
 
 static void RemoveGarbageCollectionTracking(
diff -r -u --color up/node/src/node_platform.cc nw/node/src/node_platform.cc
--- up/node/src/node_platform.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/node_platform.cc	2024-08-26 19:33:04.990595379 +0000
@@ -245,11 +245,13 @@
   platform_data->FlushForegroundTasksInternal();
 }
 
-void PerIsolatePlatformData::PostIdleTask(std::unique_ptr<v8::IdleTask> task) {
+void PerIsolatePlatformData::PostIdleTaskImpl(
+    std::unique_ptr<v8::IdleTask> task, const v8::SourceLocation& location) {
   UNREACHABLE();
 }
 
-void PerIsolatePlatformData::PostTask(std::unique_ptr<Task> task) {
+void PerIsolatePlatformData::PostTaskImpl(std::unique_ptr<Task> task,
+                                          const v8::SourceLocation& location) {
   if (flush_tasks_ == nullptr) {
     // V8 may post tasks during Isolate disposal. In that case, the only
     // sensible path forward is to discard the task.
@@ -259,8 +261,10 @@
   uv_async_send(flush_tasks_);
 }
 
-void PerIsolatePlatformData::PostDelayedTask(
-    std::unique_ptr<Task> task, double delay_in_seconds) {
+void PerIsolatePlatformData::PostDelayedTaskImpl(
+    std::unique_ptr<Task> task,
+    double delay_in_seconds,
+    const v8::SourceLocation& location) {
   if (flush_tasks_ == nullptr) {
     // V8 may post tasks during Isolate disposal. In that case, the only
     // sensible path forward is to discard the task.
@@ -274,14 +278,16 @@
   uv_async_send(flush_tasks_);
 }
 
-void PerIsolatePlatformData::PostNonNestableTask(std::unique_ptr<Task> task) {
-  PostTask(std::move(task));
+void PerIsolatePlatformData::PostNonNestableTaskImpl(
+    std::unique_ptr<Task> task, const v8::SourceLocation& location) {
+  PostTaskImpl(std::move(task), location);
 }
 
-void PerIsolatePlatformData::PostNonNestableDelayedTask(
+void PerIsolatePlatformData::PostNonNestableDelayedTaskImpl(
     std::unique_ptr<Task> task,
-    double delay_in_seconds) {
-  PostDelayedTask(std::move(task), delay_in_seconds);
+    double delay_in_seconds,
+    const v8::SourceLocation& location) {
+  PostDelayedTaskImpl(std::move(task), delay_in_seconds, location);
 }
 
 PerIsolatePlatformData::~PerIsolatePlatformData() {
@@ -345,8 +351,8 @@
   // TODO(addaleax): It's a bit icky that we use global state here, but we can't
   // really do anything about it unless V8 starts exposing a way to access the
   // current v8::Platform instance.
-  SetTracingController(tracing_controller_);
-  DCHECK_EQ(GetTracingController(), tracing_controller_);
+  //SetTracingController(tracing_controller_);
+  //DCHECK_EQ(GetTracingController(), tracing_controller_);
 
   thread_pool_size = GetActualThreadPoolSize(thread_pool_size);
   worker_thread_task_runner_ =
diff -r -u --color up/node/src/node_platform.h nw/node/src/node_platform.h
--- up/node/src/node_platform.h	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/node_platform.h	2024-08-26 19:33:04.990595379 +0000
@@ -3,10 +3,10 @@
 
 #if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS
 
+#include <functional>
 #include <queue>
 #include <unordered_map>
 #include <vector>
-#include <functional>
 
 #include "libplatform/libplatform.h"
 #include "node.h"
@@ -50,27 +50,20 @@
 };
 
 // This acts as the foreground task runner for a given Isolate.
-class PerIsolatePlatformData :
-    public IsolatePlatformDelegate,
-    public v8::TaskRunner,
-    public std::enable_shared_from_this<PerIsolatePlatformData> {
+class PerIsolatePlatformData
+    : public IsolatePlatformDelegate,
+      public v8::TaskRunner,
+      public std::enable_shared_from_this<PerIsolatePlatformData> {
  public:
   PerIsolatePlatformData(v8::Isolate* isolate, uv_loop_t* loop);
   ~PerIsolatePlatformData() override;
 
   std::shared_ptr<v8::TaskRunner> GetForegroundTaskRunner() override;
-  void PostTask(std::unique_ptr<v8::Task> task) override;
-  void PostIdleTask(std::unique_ptr<v8::IdleTask> task) override;
-  void PostDelayedTask(std::unique_ptr<v8::Task> task,
-                       double delay_in_seconds) override;
   bool IdleTasksEnabled() override { return false; }
 
   // Non-nestable tasks are treated like regular tasks.
   bool NonNestableTasksEnabled() const override { return true; }
   bool NonNestableDelayedTasksEnabled() const override { return true; }
-  void PostNonNestableTask(std::unique_ptr<v8::Task> task) override;
-  void PostNonNestableDelayedTask(std::unique_ptr<v8::Task> task,
-                                  double delay_in_seconds) override;
 
   void AddShutdownCallback(void (*callback)(void*), void* data);
   void Shutdown();
@@ -83,6 +76,21 @@
   const uv_loop_t* event_loop() const { return loop_; }
 
  private:
+  // v8::TaskRunner implementation.
+  void PostTaskImpl(std::unique_ptr<v8::Task> task,
+                    const v8::SourceLocation& location) override;
+  void PostDelayedTaskImpl(std::unique_ptr<v8::Task> task,
+                           double delay_in_seconds,
+                           const v8::SourceLocation& location) override;
+  void PostIdleTaskImpl(std::unique_ptr<v8::IdleTask> task,
+                        const v8::SourceLocation& location) override;
+  void PostNonNestableTaskImpl(std::unique_ptr<v8::Task> task,
+                               const v8::SourceLocation& location) override;
+  void PostNonNestableDelayedTaskImpl(
+      std::unique_ptr<v8::Task> task,
+      double delay_in_seconds,
+      const v8::SourceLocation& location) override;
+
   void DeleteFromScheduledTasks(DelayedTask* task);
   void DecreaseHandleCount();
 
@@ -107,7 +115,7 @@
   TaskQueue<DelayedTask> foreground_delayed_tasks_;
 
   // Use a custom deleter because libuv needs to close the handle first.
-  typedef std::unique_ptr<DelayedTask, void(*)(DelayedTask*)>
+  typedef std::unique_ptr<DelayedTask, void (*)(DelayedTask*)>
       DelayedTaskPointer;
   std::vector<DelayedTaskPointer> scheduled_delayed_tasks_;
 };
@@ -118,8 +126,7 @@
   explicit WorkerThreadsTaskRunner(int thread_pool_size);
 
   void PostTask(std::unique_ptr<v8::Task> task);
-  void PostDelayedTask(std::unique_ptr<v8::Task> task,
-                       double delay_in_seconds);
+  void PostDelayedTask(std::unique_ptr<v8::Task> task, double delay_in_seconds);
 
   void BlockingDrain();
   void Shutdown();
@@ -171,7 +178,8 @@
 
   void UnregisterIsolate(v8::Isolate* isolate) override;
   void AddIsolateFinishedCallback(v8::Isolate* isolate,
-                                  void (*callback)(void*), void* data) override;
+                                  void (*callback)(void*),
+                                  void* data) override;
 
   std::shared_ptr<v8::TaskRunner> GetForegroundTaskRunner(
       v8::Isolate* isolate) override;
@@ -184,8 +192,8 @@
   std::shared_ptr<PerIsolatePlatformData> ForNodeIsolate(v8::Isolate* isolate);
 
   Mutex per_isolate_mutex_;
-  using DelegatePair = std::pair<
-    IsolatePlatformDelegate*, std::shared_ptr<PerIsolatePlatformData>>;
+  using DelegatePair = std::pair<IsolatePlatformDelegate*,
+                                 std::shared_ptr<PerIsolatePlatformData>>;
   std::unordered_map<v8::Isolate*, DelegatePair> per_isolate_;
 
   v8::TracingController* tracing_controller_;
diff -r -u --color up/node/src/node_process.h nw/node/src/node_process.h
--- up/node/src/node_process.h	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/node_process.h	2024-08-26 19:33:04.990595379 +0000
@@ -44,7 +44,7 @@
                                               const char* warning,
                                               const char* deprecation_code);
 
-v8::MaybeLocal<v8::Object> CreateProcessObject(Realm* env);
+v8::MaybeLocal<v8::Object> CreateProcessObject(Realm* env, bool node_is_nwjs);
 void PatchProcessObject(const v8::FunctionCallbackInfo<v8::Value>& args);
 
 namespace process {
diff -r -u --color up/node/src/node_process_methods.cc nw/node/src/node_process_methods.cc
--- up/node/src/node_process_methods.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/node_process_methods.cc	2024-08-26 19:33:04.990595379 +0000
@@ -584,11 +584,11 @@
 }
 
 void BindingData::SlowBigInt(const FunctionCallbackInfo<Value>& args) {
-  BigIntImpl(FromJSObject<BindingData>(args.Holder()));
+  BigIntImpl(FromJSObject<BindingData>(args.This()));
 }
 
 void BindingData::SlowNumber(const v8::FunctionCallbackInfo<v8::Value>& args) {
-  NumberImpl(FromJSObject<BindingData>(args.Holder()));
+  NumberImpl(FromJSObject<BindingData>(args.This()));
 }
 
 bool BindingData::PrepareForSerialization(Local<Context> context,
diff -r -u --color up/node/src/node_process_object.cc nw/node/src/node_process_object.cc
--- up/node/src/node_process_object.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/node_process_object.cc	2024-08-26 19:33:04.990595379 +0000
@@ -13,7 +13,6 @@
 
 namespace node {
 using v8::Context;
-using v8::DEFAULT;
 using v8::EscapableHandleScope;
 using v8::Function;
 using v8::FunctionCallbackInfo;
@@ -78,7 +77,7 @@
   info.GetReturnValue().Set(uv_os_getppid());
 }
 
-MaybeLocal<Object> CreateProcessObject(Realm* realm) {
+MaybeLocal<Object> CreateProcessObject(Realm* realm, bool node_is_nwjs) {
   Isolate* isolate = realm->isolate();
   EscapableHandleScope scope(isolate);
   Local<Context> context = realm->context();
@@ -93,6 +92,8 @@
   }
 
   // process[exit_info_private_symbol]
+  if (node_is_nwjs)
+    READONLY_PROPERTY(process, "__nwjs", Integer::New(realm->env()->isolate(), 1));
   if (process
           ->SetPrivate(context,
                        realm->env()->exit_info_private_symbol(),
@@ -183,13 +184,12 @@
 
   // process.title
   CHECK(process
-            ->SetAccessor(
+            ->SetNativeDataProperty(
                 context,
                 FIXED_ONE_BYTE_STRING(isolate, "title"),
                 ProcessTitleGetter,
                 env->owns_process_state() ? ProcessTitleSetter : nullptr,
                 Local<Value>(),
-                DEFAULT,
                 None,
                 SideEffectType::kHasNoSideEffect)
             .FromJust());
@@ -208,9 +208,15 @@
   READONLY_PROPERTY(process, "pid",
                     Integer::New(isolate, uv_os_getpid()));
 
-  CHECK(process->SetAccessor(context,
-                             FIXED_ONE_BYTE_STRING(isolate, "ppid"),
-                             GetParentProcessId).FromJust());
+  CHECK(process
+            ->SetNativeDataProperty(context,
+                                    FIXED_ONE_BYTE_STRING(isolate, "ppid"),
+                                    GetParentProcessId,
+                                    nullptr,
+                                    Local<Value>(),
+                                    None,
+                                    SideEffectType::kHasNoSideEffect)
+            .FromJust());
 
   // --security-revert flags
 #define V(code, _, __)                                                        \
@@ -235,11 +241,14 @@
 
   // process.debugPort
   CHECK(process
-            ->SetAccessor(context,
-                          FIXED_ONE_BYTE_STRING(isolate, "debugPort"),
-                          DebugPortGetter,
-                          env->owns_process_state() ? DebugPortSetter : nullptr,
-                          Local<Value>())
+            ->SetNativeDataProperty(
+                context,
+                FIXED_ONE_BYTE_STRING(isolate, "debugPort"),
+                DebugPortGetter,
+                env->owns_process_state() ? DebugPortSetter : nullptr,
+                Local<Value>(),
+                None,
+                SideEffectType::kHasNoSideEffect)
             .FromJust());
 }
 
diff -r -u --color up/node/src/node_realm.cc nw/node/src/node_realm.cc
--- up/node/src/node_realm.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/node_realm.cc	2024-08-26 19:33:04.990595379 +0000
@@ -18,8 +18,8 @@
 using v8::String;
 using v8::Value;
 
-Realm::Realm(Environment* env, v8::Local<v8::Context> context, Kind kind)
-    : env_(env), isolate_(context->GetIsolate()), kind_(kind) {
+Realm::Realm(Environment* env, v8::Local<v8::Context> context, Kind kind, bool nwjs)
+    : nwjs_(nwjs), env_(env), isolate_(context->GetIsolate()), kind_(kind) {
   context_.Reset(isolate_, context);
   env->AssignToContext(context, this, ContextInfo(""));
 }
@@ -79,7 +79,7 @@
   // process. Distinguish them and create process object only in the principal
   // realm.
   Local<Object> process_object =
-      node::CreateProcessObject(this).FromMaybe(Local<Object>());
+      node::CreateProcessObject(this, nwjs_).FromMaybe(Local<Object>());
   set_process_object(process_object);
 }
 
@@ -295,8 +295,8 @@
 
 PrincipalRealm::PrincipalRealm(Environment* env,
                                v8::Local<v8::Context> context,
-                               const RealmSerializeInfo* realm_info)
-    : Realm(env, context, kPrincipal) {
+                               const RealmSerializeInfo* realm_info, bool nwjs)
+  : Realm(env, context, kPrincipal, nwjs) {
   // Create properties if not deserializing from snapshot.
   // Or the properties are deserialized with DeserializeProperties() when the
   // env drained the deserialize requests.
diff -r -u --color up/node/src/node_realm.h nw/node/src/node_realm.h
--- up/node/src/node_realm.h	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/node_realm.h	2024-08-26 19:33:04.990595379 +0000
@@ -55,7 +55,7 @@
   template <typename T>
   static inline Realm* GetCurrent(const v8::PropertyCallbackInfo<T>& info);
 
-  Realm(Environment* env, v8::Local<v8::Context> context, Kind kind);
+  Realm(Environment* env, v8::Local<v8::Context> context, Kind kind, bool nwjs = false);
 
   Realm(const Realm&) = delete;
   Realm& operator=(const Realm&) = delete;
@@ -132,6 +132,7 @@
 
   virtual v8::MaybeLocal<v8::Value> BootstrapRealm() = 0;
 
+  bool nwjs_ = false;
   Environment* env_;
   // Shorthand for isolate pointer.
   v8::Isolate* isolate_;
@@ -161,7 +162,7 @@
  public:
   PrincipalRealm(Environment* env,
                  v8::Local<v8::Context> context,
-                 const RealmSerializeInfo* realm_info);
+                 const RealmSerializeInfo* realm_info, bool nodejs);
   ~PrincipalRealm();
 
   SET_MEMORY_INFO_NAME(PrincipalRealm)
diff -r -u --color up/node/src/node_serdes.cc nw/node/src/node_serdes.cc
--- up/node/src/node_serdes.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/node_serdes.cc	2024-08-26 19:33:04.994595378 +0000
@@ -180,13 +180,13 @@
 
 void SerializerContext::WriteHeader(const FunctionCallbackInfo<Value>& args) {
   SerializerContext* ctx;
-  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.This());
   ctx->serializer_.WriteHeader();
 }
 
 void SerializerContext::WriteValue(const FunctionCallbackInfo<Value>& args) {
   SerializerContext* ctx;
-  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.This());
   Maybe<bool> ret =
       ctx->serializer_.WriteValue(ctx->env()->context(), args[0]);
 
@@ -196,7 +196,7 @@
 void SerializerContext::SetTreatArrayBufferViewsAsHostObjects(
     const FunctionCallbackInfo<Value>& args) {
   SerializerContext* ctx;
-  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.This());
 
   bool value = args[0]->BooleanValue(ctx->env()->isolate());
   ctx->serializer_.SetTreatArrayBufferViewsAsHostObjects(value);
@@ -204,7 +204,7 @@
 
 void SerializerContext::ReleaseBuffer(const FunctionCallbackInfo<Value>& args) {
   SerializerContext* ctx;
-  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.This());
 
   // Note: Both ValueSerializer and this Buffer::New() variant use malloc()
   // as the underlying allocator.
@@ -221,7 +221,7 @@
 void SerializerContext::TransferArrayBuffer(
     const FunctionCallbackInfo<Value>& args) {
   SerializerContext* ctx;
-  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.This());
 
   Maybe<uint32_t> id = args[0]->Uint32Value(ctx->env()->context());
   if (id.IsNothing()) return;
@@ -237,7 +237,7 @@
 
 void SerializerContext::WriteUint32(const FunctionCallbackInfo<Value>& args) {
   SerializerContext* ctx;
-  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.This());
 
   Maybe<uint32_t> value = args[0]->Uint32Value(ctx->env()->context());
   if (value.IsNothing()) return;
@@ -247,7 +247,7 @@
 
 void SerializerContext::WriteUint64(const FunctionCallbackInfo<Value>& args) {
   SerializerContext* ctx;
-  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.This());
 
   Maybe<uint32_t> arg0 = args[0]->Uint32Value(ctx->env()->context());
   Maybe<uint32_t> arg1 = args[1]->Uint32Value(ctx->env()->context());
@@ -261,7 +261,7 @@
 
 void SerializerContext::WriteDouble(const FunctionCallbackInfo<Value>& args) {
   SerializerContext* ctx;
-  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.This());
 
   Maybe<double> value = args[0]->NumberValue(ctx->env()->context());
   if (value.IsNothing()) return;
@@ -271,7 +271,7 @@
 
 void SerializerContext::WriteRawBytes(const FunctionCallbackInfo<Value>& args) {
   SerializerContext* ctx;
-  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.This());
 
   if (!args[0]->IsArrayBufferView()) {
     return node::THROW_ERR_INVALID_ARG_TYPE(
@@ -339,7 +339,7 @@
 
 void DeserializerContext::ReadHeader(const FunctionCallbackInfo<Value>& args) {
   DeserializerContext* ctx;
-  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.This());
 
   Maybe<bool> ret = ctx->deserializer_.ReadHeader(ctx->env()->context());
 
@@ -348,7 +348,7 @@
 
 void DeserializerContext::ReadValue(const FunctionCallbackInfo<Value>& args) {
   DeserializerContext* ctx;
-  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.This());
 
   MaybeLocal<Value> ret = ctx->deserializer_.ReadValue(ctx->env()->context());
 
@@ -358,7 +358,7 @@
 void DeserializerContext::TransferArrayBuffer(
     const FunctionCallbackInfo<Value>& args) {
   DeserializerContext* ctx;
-  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.This());
 
   Maybe<uint32_t> id = args[0]->Uint32Value(ctx->env()->context());
   if (id.IsNothing()) return;
@@ -382,14 +382,14 @@
 void DeserializerContext::GetWireFormatVersion(
     const FunctionCallbackInfo<Value>& args) {
   DeserializerContext* ctx;
-  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.This());
 
   args.GetReturnValue().Set(ctx->deserializer_.GetWireFormatVersion());
 }
 
 void DeserializerContext::ReadUint32(const FunctionCallbackInfo<Value>& args) {
   DeserializerContext* ctx;
-  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.This());
 
   uint32_t value;
   bool ok = ctx->deserializer_.ReadUint32(&value);
@@ -399,7 +399,7 @@
 
 void DeserializerContext::ReadUint64(const FunctionCallbackInfo<Value>& args) {
   DeserializerContext* ctx;
-  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.This());
 
   uint64_t value;
   bool ok = ctx->deserializer_.ReadUint64(&value);
@@ -419,7 +419,7 @@
 
 void DeserializerContext::ReadDouble(const FunctionCallbackInfo<Value>& args) {
   DeserializerContext* ctx;
-  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.This());
 
   double value;
   bool ok = ctx->deserializer_.ReadDouble(&value);
@@ -430,7 +430,7 @@
 void DeserializerContext::ReadRawBytes(
     const FunctionCallbackInfo<Value>& args) {
   DeserializerContext* ctx;
-  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.This());
 
   Maybe<int64_t> length_arg = args[0]->IntegerValue(ctx->env()->context());
   if (length_arg.IsNothing()) return;
diff -r -u --color up/node/src/node_sockaddr.cc nw/node/src/node_sockaddr.cc
--- up/node/src/node_sockaddr.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/node_sockaddr.cc	2024-08-26 19:33:04.994595378 +0000
@@ -594,7 +594,7 @@
     const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   SocketAddressBlockListWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
 
   CHECK(SocketAddressBase::HasInstance(env, args[0]));
   SocketAddressBase* addr;
@@ -609,7 +609,7 @@
     const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   SocketAddressBlockListWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
 
   CHECK(SocketAddressBase::HasInstance(env, args[0]));
   CHECK(SocketAddressBase::HasInstance(env, args[1]));
@@ -634,7 +634,7 @@
     const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   SocketAddressBlockListWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
 
   CHECK(SocketAddressBase::HasInstance(env, args[0]));
   CHECK(args[1]->IsInt32());
@@ -660,7 +660,7 @@
     const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   SocketAddressBlockListWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
 
   CHECK(SocketAddressBase::HasInstance(env, args[0]));
   SocketAddressBase* addr;
@@ -673,7 +673,7 @@
     const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   SocketAddressBlockListWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
   Local<Array> rules;
   if (wrap->blocklist_->ListRules(env).ToLocal(&rules))
     args.GetReturnValue().Set(rules);
@@ -814,7 +814,7 @@
   Local<Object> detail = args[0].As<Object>();
 
   SocketAddressBase* base;
-  ASSIGN_OR_RETURN_UNWRAP(&base, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&base, args.This());
 
   Local<Value> address;
   if (!ToV8Value(env->context(), base->address_->address()).ToLocal(&address))
@@ -840,14 +840,14 @@
 
 void SocketAddressBase::GetFlowLabel(const FunctionCallbackInfo<Value>& args) {
   SocketAddressBase* base;
-  ASSIGN_OR_RETURN_UNWRAP(&base, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&base, args.This());
   args.GetReturnValue().Set(base->address_->flow_label());
 }
 
 void SocketAddressBase::LegacyDetail(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   SocketAddressBase* base;
-  ASSIGN_OR_RETURN_UNWRAP(&base, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&base, args.This());
   Local<Object> address;
   if (!base->address_->ToJS(env).ToLocal(&address)) return;
   args.GetReturnValue().Set(address);
diff -r -u --color up/node/src/node_stat_watcher.cc nw/node/src/node_stat_watcher.cc
--- up/node/src/node_stat_watcher.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/node_stat_watcher.cc	2024-08-26 19:33:04.994595378 +0000
@@ -107,7 +107,7 @@
   CHECK_EQ(args.Length(), 2);
 
   StatWatcher* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
   CHECK(!uv_is_active(wrap->GetHandle()));
 
   node::Utf8Value path(args.GetIsolate(), args[0]);
diff -r -u --color up/node/src/node_trace_events.cc nw/node/src/node_trace_events.cc
--- up/node/src/node_trace_events.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/node_trace_events.cc	2024-08-26 19:33:04.994595378 +0000
@@ -76,8 +76,9 @@
 }
 
 void NodeCategorySet::Enable(const FunctionCallbackInfo<Value>& args) {
+#if 0
   NodeCategorySet* category_set;
-  ASSIGN_OR_RETURN_UNWRAP(&category_set, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&category_set, args.This());
   CHECK_NOT_NULL(category_set);
   const auto& categories = category_set->GetCategories();
   if (!category_set->enabled_ && !categories.empty()) {
@@ -87,20 +88,27 @@
     GetTracingAgentWriter()->Enable(categories);
     category_set->enabled_ = true;
   }
+#endif
+}
+
+void Dummy(const FunctionCallbackInfo<Value>& args) {
 }
 
 void NodeCategorySet::Disable(const FunctionCallbackInfo<Value>& args) {
+#if 0
   NodeCategorySet* category_set;
-  ASSIGN_OR_RETURN_UNWRAP(&category_set, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&category_set, args.This());
   CHECK_NOT_NULL(category_set);
   const auto& categories = category_set->GetCategories();
   if (category_set->enabled_ && !categories.empty()) {
     GetTracingAgentWriter()->Disable(categories);
     category_set->enabled_ = false;
   }
+#endif
 }
 
 void GetEnabledCategories(const FunctionCallbackInfo<Value>& args) {
+#if 0
   Environment* env = Environment::GetCurrent(args);
   std::string categories =
       GetTracingAgentWriter()->agent()->GetEnabledCategories();
@@ -111,6 +119,7 @@
                           NewStringType::kNormal,
                           categories.size()).ToLocalChecked());
   }
+#endif
 }
 
 static void SetTraceCategoryStateUpdateHandler(
@@ -154,6 +163,7 @@
                   .Check();
   target->Set(context, trace,
               binding->Get(context, trace).ToLocalChecked()).Check();
+  SetMethod(context, target, "trace", Dummy);
 }
 
 void NodeCategorySet::RegisterExternalReferences(
diff -r -u --color up/node/src/node_types.cc nw/node/src/node_types.cc
--- up/node/src/node_types.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/node_types.cc	2024-08-26 19:33:04.994595378 +0000
@@ -38,7 +38,6 @@
   V(Proxy)                                                                    \
   V(ModuleNamespaceObject)                                                    \
 
-
 #define V(type) \
   static void Is##type(const FunctionCallbackInfo<Value>& args) {             \
     args.GetReturnValue().Set(args[0]->Is##type());                           \
diff -r -u --color up/node/src/node_v8.cc nw/node/src/node_v8.cc
--- up/node/src/node_v8.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/node_v8.cc	2024-08-26 19:33:04.994595378 +0000
@@ -369,7 +369,7 @@
 void GCProfiler::Start(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   GCProfiler* profiler;
-  ASSIGN_OR_RETURN_UNWRAP(&profiler, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&profiler, args.This());
   if (profiler->state != GCProfiler::GCProfilerState::kInitialized) {
     return;
   }
@@ -394,7 +394,7 @@
 void GCProfiler::Stop(const FunctionCallbackInfo<v8::Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   GCProfiler* profiler;
-  ASSIGN_OR_RETURN_UNWRAP(&profiler, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&profiler, args.This());
   if (profiler->state != GCProfiler::GCProfilerState::kStarted) {
     return;
   }
diff -r -u --color up/node/src/node_v8_platform-inl.h nw/node/src/node_v8_platform-inl.h
--- up/node/src/node_v8_platform-inl.h	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/node_v8_platform-inl.h	2024-08-26 19:33:04.994595378 +0000
@@ -18,6 +18,7 @@
 
 namespace node {
 
+#if 0
 // Ensures that __metadata trace events are only emitted
 // when tracing is enabled.
 class NodeTraceStateObserver
@@ -80,6 +81,7 @@
  private:
   v8::TracingController* controller_;
 };
+#endif
 
 struct V8Platform {
   bool initialized_ = false;
@@ -88,6 +90,7 @@
   inline void Initialize(int thread_pool_size) {
     CHECK(!initialized_);
     initialized_ = true;
+#if 0
     tracing_agent_ = std::make_unique<tracing::Agent>();
     node::tracing::TraceEventHelper::SetAgent(tracing_agent_.get());
     node::tracing::TracingController* controller =
@@ -103,6 +106,10 @@
     // Tracing must be initialized before platform threads are created.
     platform_ = new NodePlatform(thread_pool_size, controller);
     v8::V8::InitializePlatform(platform_);
+#endif
+    tracing_agent_.reset(nullptr);
+    platform_ = new NodePlatform(thread_pool_size, new v8::TracingController());
+    v8::V8::InitializePlatform(platform_);
   }
   // Make sure V8Platform don not call into Libuv threadpool,
   // see DefaultProcessExitHandlerInternal in environment.cc
@@ -110,7 +117,7 @@
     if (!initialized_)
       return;
     initialized_ = false;
-    node::tracing::TraceEventHelper::SetAgent(nullptr);
+    //node::tracing::TraceEventHelper::SetAgent(nullptr);
     StopTracingAgent();
     platform_->Shutdown();
     delete platform_;
@@ -119,7 +126,7 @@
     // stopped.
     tracing_agent_.reset(nullptr);
     // The observer remove itself in OnTraceEnabled
-    trace_state_observer_.reset(nullptr);
+    //trace_state_observer_.reset(nullptr);
   }
 
   inline void DrainVMTasks(v8::Isolate* isolate) {
@@ -127,6 +134,7 @@
   }
 
   inline void StartTracingAgent() {
+#if 0
     constexpr auto convert_to_set =
         [](std::vector<std::string_view> categories) -> std::set<std::string> {
       std::set<std::string> out;
@@ -149,9 +157,10 @@
                   per_process::cli_options->trace_event_file_pattern)),
           tracing::Agent::kUseDefaultCategories);
     }
+#endif
   }
 
-  inline void StopTracingAgent() { tracing_file_writer_.reset(); }
+  inline void StopTracingAgent() {} // tracing_file_writer_.reset(); }
 
   inline tracing::AgentWriterHandle* GetTracingAgentWriter() {
     return &tracing_file_writer_;
@@ -159,7 +168,7 @@
 
   inline NodePlatform* Platform() { return platform_; }
 
-  std::unique_ptr<NodeTraceStateObserver> trace_state_observer_;
+  //std::unique_ptr<NodeTraceStateObserver> trace_state_observer_;
   std::unique_ptr<tracing::Agent> tracing_agent_;
   tracing::AgentWriterHandle tracing_file_writer_;
   NodePlatform* platform_;
diff -r -u --color up/node/src/node_wasm_web_api.cc nw/node/src/node_wasm_web_api.cc
--- up/node/src/node_wasm_web_api.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/node_wasm_web_api.cc	2024-08-26 19:33:04.994595378 +0000
@@ -81,7 +81,7 @@
 
 void WasmStreamingObject::SetURL(const FunctionCallbackInfo<Value>& args) {
   WasmStreamingObject* obj;
-  ASSIGN_OR_RETURN_UNWRAP(&obj, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&obj, args.This());
   CHECK(obj->streaming_);
 
   CHECK_EQ(args.Length(), 1);
@@ -92,7 +92,7 @@
 
 void WasmStreamingObject::Push(const FunctionCallbackInfo<Value>& args) {
   WasmStreamingObject* obj;
-  ASSIGN_OR_RETURN_UNWRAP(&obj, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&obj, args.This());
   CHECK(obj->streaming_);
 
   CHECK_EQ(args.Length(), 1);
@@ -128,7 +128,7 @@
 
 void WasmStreamingObject::Finish(const FunctionCallbackInfo<Value>& args) {
   WasmStreamingObject* obj;
-  ASSIGN_OR_RETURN_UNWRAP(&obj, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&obj, args.This());
   CHECK(obj->streaming_);
 
   CHECK_EQ(args.Length(), 0);
@@ -137,7 +137,7 @@
 
 void WasmStreamingObject::Abort(const FunctionCallbackInfo<Value>& args) {
   WasmStreamingObject* obj;
-  ASSIGN_OR_RETURN_UNWRAP(&obj, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&obj, args.This());
   CHECK(obj->streaming_);
 
   CHECK_EQ(args.Length(), 1);
diff -r -u --color up/node/src/node_watchdog.cc nw/node/src/node_watchdog.cc
--- up/node/src/node_watchdog.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/node_watchdog.cc	2024-08-26 19:33:04.994595378 +0000
@@ -147,7 +147,7 @@
 
 void TraceSigintWatchdog::Start(const FunctionCallbackInfo<Value>& args) {
   TraceSigintWatchdog* watchdog;
-  ASSIGN_OR_RETURN_UNWRAP(&watchdog, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&watchdog, args.This());
   Mutex::ScopedLock lock(SigintWatchdogHelper::GetInstanceActionMutex());
   // Register this watchdog with the global SIGINT/Ctrl+C listener.
   SigintWatchdogHelper::GetInstance()->Register(watchdog);
@@ -158,7 +158,7 @@
 
 void TraceSigintWatchdog::Stop(const FunctionCallbackInfo<Value>& args) {
   TraceSigintWatchdog* watchdog;
-  ASSIGN_OR_RETURN_UNWRAP(&watchdog, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&watchdog, args.This());
   Mutex::ScopedLock lock(SigintWatchdogHelper::GetInstanceActionMutex());
   SigintWatchdogHelper::GetInstance()->Unregister(watchdog);
   SigintWatchdogHelper::GetInstance()->Stop();
Only in nw/node/src: node_webkit.h
diff -r -u --color up/node/src/node_worker.cc nw/node/src/node_worker.cc
--- up/node/src/node_worker.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/node_worker.cc	2024-08-26 19:33:04.998595376 +0000
@@ -178,7 +178,7 @@
     isolate->AddNearHeapLimitCallback(Worker::NearHeapLimit, w);
 
     {
-      Locker locker(isolate);
+      //Locker locker(isolate);
       Isolate::Scope isolate_scope(isolate);
       // V8 computes its stack limit the first time a `Locker` is used based on
       // --stack-size. Reset it to the correct value.
@@ -290,13 +290,15 @@
 
   Debug(this, "Creating isolate for worker with id %llu", thread_id_.id);
 
+  v8::SetTLSPlatform(platform_);
+
   WorkerThreadData data(this);
   if (isolate_ == nullptr) return;
   CHECK(data.loop_is_usable());
 
   Debug(this, "Starting worker with id %llu", thread_id_.id);
   {
-    Locker locker(isolate_);
+    //Locker locker(isolate_);
     Isolate::Scope isolate_scope(isolate_);
     SealHandleScope outer_seal(isolate_);
 
@@ -356,6 +358,10 @@
       }
 
       if (is_stopped()) return;
+      node::thread_ctx_st* tls_ctx = (node::thread_ctx_st*)malloc(sizeof(node::thread_ctx_st));
+      memset(tls_ctx, 0, sizeof(node::thread_ctx_st));
+      uv_key_set(&node::thread_ctx_key, tls_ctx);
+      node::binding::RegisterBuiltinBindings();
       CHECK(!context.IsEmpty());
       Context::Scope context_scope(context);
       {
diff -r -u --color up/node/src/node_zlib.cc nw/node/src/node_zlib.cc
--- up/node/src/node_zlib.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/node_zlib.cc	2024-08-26 19:33:04.998595376 +0000
@@ -288,7 +288,7 @@
 
   static void Close(const FunctionCallbackInfo<Value>& args) {
     CompressionStream* ctx;
-    ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());
+    ASSIGN_OR_RETURN_UNWRAP(&ctx, args.This());
     ctx->Close();
   }
 
@@ -339,7 +339,7 @@
     out = Buffer::Data(out_buf) + out_off;
 
     CompressionStream* ctx;
-    ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());
+    ASSIGN_OR_RETURN_UNWRAP(&ctx, args.This());
 
     ctx->Write<async>(flush, in, in_len, out, out_len);
   }
@@ -453,7 +453,7 @@
 
   static void Reset(const FunctionCallbackInfo<Value> &args) {
     CompressionStream* wrap;
-    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
 
     AllocScope alloc_scope(wrap);
     const CompressionError err = wrap->context()->ResetStream();
@@ -585,7 +585,7 @@
       " dictionary)");
 
     ZlibStream* wrap;
-    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
 
     Local<Context> context = args.GetIsolate()->GetCurrentContext();
 
@@ -633,7 +633,7 @@
   static void Params(const FunctionCallbackInfo<Value>& args) {
     CHECK(args.Length() == 2 && "params(level, strategy)");
     ZlibStream* wrap;
-    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
     Local<Context> context = args.GetIsolate()->GetCurrentContext();
     int level;
     if (!args[0]->Int32Value(context).To(&level)) return;
@@ -676,7 +676,7 @@
 
   static void Init(const FunctionCallbackInfo<Value>& args) {
     BrotliCompressionStream* wrap;
-    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
     CHECK(args.Length() == 3 && "init(params, writeResult, writeCallback)");
 
     CHECK(args[1]->IsUint32Array());
diff -r -u --color up/node/src/pipe_wrap.cc nw/node/src/pipe_wrap.cc
--- up/node/src/pipe_wrap.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/pipe_wrap.cc	2024-08-26 19:33:04.998595376 +0000
@@ -160,7 +160,7 @@
 
 void PipeWrap::Bind(const FunctionCallbackInfo<Value>& args) {
   PipeWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
   node::Utf8Value name(args.GetIsolate(), args[0]);
   int err = uv_pipe_bind2(&wrap->handle_, *name, name.length(), 0);
   args.GetReturnValue().Set(err);
@@ -169,7 +169,7 @@
 #ifdef _WIN32
 void PipeWrap::SetPendingInstances(const FunctionCallbackInfo<Value>& args) {
   PipeWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
   CHECK(args[0]->IsInt32());
   int instances = args[0].As<Int32>()->Value();
   uv_pipe_pending_instances(&wrap->handle_, instances);
@@ -178,7 +178,7 @@
 
 void PipeWrap::Fchmod(const v8::FunctionCallbackInfo<v8::Value>& args) {
   PipeWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
   CHECK(args[0]->IsInt32());
   int mode = args[0].As<Int32>()->Value();
   int err = uv_pipe_chmod(&wrap->handle_, mode);
@@ -187,7 +187,7 @@
 
 void PipeWrap::Listen(const FunctionCallbackInfo<Value>& args) {
   PipeWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
   Environment* env = wrap->env();
   int backlog;
   if (!args[0]->Int32Value(env->context()).To(&backlog)) return;
@@ -200,7 +200,7 @@
   Environment* env = Environment::GetCurrent(args);
 
   PipeWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
 
   int fd;
   if (!args[0]->Int32Value(env->context()).To(&fd)) return;
@@ -215,7 +215,7 @@
   Environment* env = Environment::GetCurrent(args);
 
   PipeWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
 
   CHECK(args[0]->IsObject());
   CHECK(args[1]->IsString());
diff -r -u --color up/node/src/process_wrap.cc nw/node/src/process_wrap.cc
--- up/node/src/process_wrap.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/process_wrap.cc	2024-08-26 19:33:04.998595376 +0000
@@ -154,7 +154,7 @@
     Environment* env = Environment::GetCurrent(args);
     Local<Context> context = env->context();
     ProcessWrap* wrap;
-    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
     THROW_IF_INSUFFICIENT_PERMISSIONS(
         env, permission::PermissionScope::kChildProcess, "");
     int err = 0;
@@ -310,7 +310,7 @@
   static void Kill(const FunctionCallbackInfo<Value>& args) {
     Environment* env = Environment::GetCurrent(args);
     ProcessWrap* wrap;
-    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
     int signal = args[0]->Int32Value(env->context()).FromJust();
     int err = uv_process_kill(&wrap->process_, signal);
     args.GetReturnValue().Set(err);
diff -r -u --color up/node/src/quic/endpoint.cc nw/node/src/quic/endpoint.cc
--- up/node/src/quic/endpoint.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/quic/endpoint.cc	2024-08-26 19:33:04.998595376 +0000
@@ -1690,7 +1690,7 @@
 void Endpoint::DoConnect(const FunctionCallbackInfo<Value>& args) {
   auto env = Environment::GetCurrent(args);
   Endpoint* endpoint;
-  ASSIGN_OR_RETURN_UNWRAP(&endpoint, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&endpoint, args.This());
 
   // args[0] is a SocketAddress
   // args[1] is a Session OptionsObject (see session.cc)
@@ -1723,7 +1723,7 @@
 
 void Endpoint::DoListen(const FunctionCallbackInfo<Value>& args) {
   Endpoint* endpoint;
-  ASSIGN_OR_RETURN_UNWRAP(&endpoint, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&endpoint, args.This());
   auto env = Environment::GetCurrent(args);
 
   Session::Options options;
@@ -1734,20 +1734,20 @@
 
 void Endpoint::MarkBusy(const FunctionCallbackInfo<Value>& args) {
   Endpoint* endpoint;
-  ASSIGN_OR_RETURN_UNWRAP(&endpoint, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&endpoint, args.This());
   endpoint->MarkAsBusy(args[0]->IsTrue());
 }
 
 void Endpoint::DoCloseGracefully(const FunctionCallbackInfo<Value>& args) {
   Endpoint* endpoint;
-  ASSIGN_OR_RETURN_UNWRAP(&endpoint, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&endpoint, args.This());
   endpoint->CloseGracefully();
 }
 
 void Endpoint::LocalAddress(const FunctionCallbackInfo<Value>& args) {
   auto env = Environment::GetCurrent(args);
   Endpoint* endpoint;
-  ASSIGN_OR_RETURN_UNWRAP(&endpoint, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&endpoint, args.This());
   if (endpoint->is_closed() || !endpoint->udp_.is_bound()) return;
   auto addr = SocketAddressBase::Create(
       env, std::make_shared<SocketAddress>(endpoint->local_address()));
@@ -1756,7 +1756,7 @@
 
 void Endpoint::Ref(const FunctionCallbackInfo<Value>& args) {
   Endpoint* endpoint;
-  ASSIGN_OR_RETURN_UNWRAP(&endpoint, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&endpoint, args.This());
   auto env = Environment::GetCurrent(args);
   if (args[0]->BooleanValue(env->isolate())) {
     endpoint->udp_.Ref();
diff -r -u --color up/node/src/quic/session.cc nw/node/src/quic/session.cc
--- up/node/src/quic/session.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/quic/session.cc	2024-08-26 19:33:04.998595376 +0000
@@ -1753,14 +1753,14 @@
 
   static void DoDestroy(const FunctionCallbackInfo<Value>& args) {
     Session* session;
-    ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
+    ASSIGN_OR_RETURN_UNWRAP(&session, args.This());
     session->Destroy();
   }
 
   static void GetRemoteAddress(const FunctionCallbackInfo<Value>& args) {
     auto env = Environment::GetCurrent(args);
     Session* session;
-    ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
+    ASSIGN_OR_RETURN_UNWRAP(&session, args.This());
     auto address = session->remote_address();
     args.GetReturnValue().Set(
         SocketAddressBase::Create(env, std::make_shared<SocketAddress>(address))
@@ -1770,7 +1770,7 @@
   static void GetCertificate(const FunctionCallbackInfo<Value>& args) {
     auto env = Environment::GetCurrent(args);
     Session* session;
-    ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
+    ASSIGN_OR_RETURN_UNWRAP(&session, args.This());
     Local<Value> ret;
     if (session->tls_session().cert(env).ToLocal(&ret))
       args.GetReturnValue().Set(ret);
@@ -1779,7 +1779,7 @@
   static void GetEphemeralKeyInfo(const FunctionCallbackInfo<Value>& args) {
     auto env = Environment::GetCurrent(args);
     Session* session;
-    ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
+    ASSIGN_OR_RETURN_UNWRAP(&session, args.This());
     Local<Object> ret;
     if (!session->is_server() &&
         session->tls_session().ephemeral_key(env).ToLocal(&ret))
@@ -1789,7 +1789,7 @@
   static void GetPeerCertificate(const FunctionCallbackInfo<Value>& args) {
     auto env = Environment::GetCurrent(args);
     Session* session;
-    ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
+    ASSIGN_OR_RETURN_UNWRAP(&session, args.This());
     Local<Value> ret;
     if (session->tls_session().peer_cert(env).ToLocal(&ret))
       args.GetReturnValue().Set(ret);
@@ -1797,20 +1797,20 @@
 
   static void GracefulClose(const FunctionCallbackInfo<Value>& args) {
     Session* session;
-    ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
+    ASSIGN_OR_RETURN_UNWRAP(&session, args.This());
     session->Close(Session::CloseMethod::GRACEFUL);
   }
 
   static void SilentClose(const FunctionCallbackInfo<Value>& args) {
     // This is exposed for testing purposes only!
     Session* session;
-    ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
+    ASSIGN_OR_RETURN_UNWRAP(&session, args.This());
     session->Close(Session::CloseMethod::SILENT);
   }
 
   static void UpdateKey(const FunctionCallbackInfo<Value>& args) {
     Session* session;
-    ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
+    ASSIGN_OR_RETURN_UNWRAP(&session, args.This());
     // Initiating a key update may fail if it is done too early (either
     // before the TLS handshake has been confirmed or while a previous
     // key update is being processed). When it fails, InitiateKeyUpdate()
@@ -1821,7 +1821,7 @@
 
   static void DoOpenStream(const FunctionCallbackInfo<Value>& args) {
     Session* session;
-    ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
+    ASSIGN_OR_RETURN_UNWRAP(&session, args.This());
     DCHECK(args[0]->IsUint32());
     auto direction = static_cast<Direction>(args[0].As<Uint32>()->Value());
     BaseObjectPtr<Stream> stream = session->OpenStream(direction);
@@ -1832,7 +1832,7 @@
   static void DoSendDatagram(const FunctionCallbackInfo<Value>& args) {
     auto env = Environment::GetCurrent(args);
     Session* session;
-    ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
+    ASSIGN_OR_RETURN_UNWRAP(&session, args.This());
     DCHECK(args[0]->IsArrayBufferView());
     args.GetReturnValue().Set(BigInt::New(
         env->isolate(),
diff -r -u --color up/node/src/quic/streams.cc nw/node/src/quic/streams.cc
--- up/node/src/quic/streams.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/quic/streams.cc	2024-08-26 19:33:04.998595376 +0000
@@ -128,14 +128,14 @@
     std::shared_ptr<DataQueue> dataqueue;
     if (GetDataQueueFromSource(env, args[0]).To(&dataqueue)) {
       Stream* stream;
-      ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());
+      ASSIGN_OR_RETURN_UNWRAP(&stream, args.This());
       stream->set_outbound(std::move(dataqueue));
     }
   }
 
   static void Destroy(const FunctionCallbackInfo<Value>& args) {
     Stream* stream;
-    ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());
+    ASSIGN_OR_RETURN_UNWRAP(&stream, args.This());
     if (args.Length() > 1) {
       CHECK(args[0]->IsBigInt());
       bool unused = false;
@@ -148,7 +148,7 @@
 
   static void SendHeaders(const FunctionCallbackInfo<Value>& args) {
     Stream* stream;
-    ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());
+    ASSIGN_OR_RETURN_UNWRAP(&stream, args.This());
     CHECK(args[0]->IsUint32());  // Kind
     CHECK(args[1]->IsArray());   // Headers
     CHECK(args[2]->IsUint32());  // Flags
@@ -169,7 +169,7 @@
   // that has already been received is still readable.
   static void StopSending(const FunctionCallbackInfo<Value>& args) {
     Stream* stream;
-    ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());
+    ASSIGN_OR_RETURN_UNWRAP(&stream, args.This());
     uint64_t code = NGTCP2_APP_NOERROR;
     CHECK_IMPLIES(!args[0]->IsUndefined(), args[0]->IsBigInt());
     if (!args[0]->IsUndefined()) {
@@ -189,7 +189,7 @@
   // outbound queue will be dropped. The stream may still be readable.
   static void ResetStream(const FunctionCallbackInfo<Value>& args) {
     Stream* stream;
-    ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());
+    ASSIGN_OR_RETURN_UNWRAP(&stream, args.This());
     uint64_t code = NGTCP2_APP_NOERROR;
     CHECK_IMPLIES(!args[0]->IsUndefined(), args[0]->IsBigInt());
     if (!args[0]->IsUndefined()) {
@@ -210,7 +210,7 @@
 
   static void SetPriority(const FunctionCallbackInfo<Value>& args) {
     Stream* stream;
-    ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());
+    ASSIGN_OR_RETURN_UNWRAP(&stream, args.This());
     CHECK(args[0]->IsUint32());  // Priority
     CHECK(args[1]->IsUint32());  // Priority flag
 
@@ -224,14 +224,14 @@
 
   static void GetPriority(const FunctionCallbackInfo<Value>& args) {
     Stream* stream;
-    ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());
+    ASSIGN_OR_RETURN_UNWRAP(&stream, args.This());
     auto priority = stream->session().application().GetStreamPriority(*stream);
     args.GetReturnValue().Set(static_cast<uint32_t>(priority));
   }
 
   static void GetReader(const FunctionCallbackInfo<Value>& args) {
     Stream* stream;
-    ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());
+    ASSIGN_OR_RETURN_UNWRAP(&stream, args.This());
     BaseObjectPtr<Blob::Reader> reader = stream->get_reader();
     if (reader) return args.GetReturnValue().Set(reader->object());
     THROW_ERR_INVALID_STATE(Environment::GetCurrent(args),
Only in nw/node/src/res: node-nw.rc
diff -r -u --color up/node/src/signal_wrap.cc nw/node/src/signal_wrap.cc
--- up/node/src/signal_wrap.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/signal_wrap.cc	2024-08-26 19:33:05.002595376 +0000
@@ -104,7 +104,7 @@
 
   static void Start(const FunctionCallbackInfo<Value>& args) {
     SignalWrap* wrap;
-    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
     Environment* env = wrap->env();
     int signum;
     if (!args[0]->Int32Value(env->context()).To(&signum)) return;
@@ -142,7 +142,7 @@
 
   static void Stop(const FunctionCallbackInfo<Value>& args) {
     SignalWrap* wrap;
-    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
 
     if (wrap->active_)  {
       wrap->active_ = false;
diff -r -u --color up/node/src/stream_base.cc nw/node/src/stream_base.cc
--- up/node/src/stream_base.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/stream_base.cc	2024-08-26 19:33:05.002595376 +0000
@@ -492,6 +492,29 @@
   return GetAsyncWrap()->object();
 }
 
+void StreamBase::AddAccessor(v8::Isolate* isolate,
+                             v8::Local<v8::Signature> signature,
+                             enum v8::PropertyAttribute attributes,
+                             v8::Local<v8::FunctionTemplate> t,
+                             JSMethodFunction* getter,
+                             JSMethodFunction* setter,
+                             v8::Local<v8::String> string) {
+  Local<FunctionTemplate> getter_templ =
+      NewFunctionTemplate(isolate,
+                          getter,
+                          signature,
+                          ConstructorBehavior::kThrow,
+                          SideEffectType::kHasNoSideEffect);
+  Local<FunctionTemplate> setter_templ =
+      NewFunctionTemplate(isolate,
+                          setter,
+                          signature,
+                          ConstructorBehavior::kThrow,
+                          SideEffectType::kHasSideEffect);
+  t->PrototypeTemplate()->SetAccessorProperty(
+      string, getter_templ, setter_templ, attributes);
+}
+
 void StreamBase::AddMethod(Isolate* isolate,
                            Local<Signature> signature,
                            enum PropertyAttribute attributes,
@@ -561,11 +584,14 @@
                  JSMethod<&StreamBase::WriteString<LATIN1>>);
   t->PrototypeTemplate()->Set(FIXED_ONE_BYTE_STRING(isolate, "isStreamBase"),
                               True(isolate));
-  t->PrototypeTemplate()->SetAccessor(
-      FIXED_ONE_BYTE_STRING(isolate, "onread"),
-      BaseObject::InternalFieldGet<StreamBase::kOnReadFunctionField>,
-      BaseObject::InternalFieldSet<StreamBase::kOnReadFunctionField,
-                                   &Value::IsFunction>);
+  AddAccessor(isolate,
+              sig,
+              static_cast<PropertyAttribute>(DontDelete | DontEnum),
+              t,
+              BaseObject::InternalFieldGet<StreamBase::kOnReadFunctionField>,
+              BaseObject::InternalFieldSet<StreamBase::kOnReadFunctionField,
+                                           &Value::IsFunction>,
+              FIXED_ONE_BYTE_STRING(isolate, "onread"));
 }
 
 void StreamBase::RegisterExternalReferences(
@@ -632,7 +658,7 @@
 
 template <int (StreamBase::*Method)(const FunctionCallbackInfo<Value>& args)>
 void StreamBase::JSMethod(const FunctionCallbackInfo<Value>& args) {
-  StreamBase* wrap = StreamBase::FromObject(args.Holder().As<Object>());
+  StreamBase* wrap = StreamBase::FromObject(args.This().As<Object>());
   if (wrap == nullptr) return;
 
   if (!wrap->IsAlive()) return args.GetReturnValue().Set(UV_EINVAL);
diff -r -u --color up/node/src/stream_base.h nw/node/src/stream_base.h
--- up/node/src/stream_base.h	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/stream_base.h	2024-08-26 19:33:05.002595376 +0000
@@ -413,6 +413,13 @@
   EmitToJSStreamListener default_listener_;
 
   void SetWriteResult(const StreamWriteResult& res);
+  static void AddAccessor(v8::Isolate* isolate,
+                          v8::Local<v8::Signature> sig,
+                          enum v8::PropertyAttribute attributes,
+                          v8::Local<v8::FunctionTemplate> t,
+                          JSMethodFunction* getter,
+                          JSMethodFunction* setter,
+                          v8::Local<v8::String> str);
   static void AddMethod(v8::Isolate* isolate,
                         v8::Local<v8::Signature> sig,
                         enum v8::PropertyAttribute attributes,
diff -r -u --color up/node/src/stream_pipe.cc nw/node/src/stream_pipe.cc
--- up/node/src/stream_pipe.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/stream_pipe.cc	2024-08-26 19:33:05.002595376 +0000
@@ -284,26 +284,26 @@
 
 void StreamPipe::Start(const FunctionCallbackInfo<Value>& args) {
   StreamPipe* pipe;
-  ASSIGN_OR_RETURN_UNWRAP(&pipe, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&pipe, args.This());
   pipe->is_closed_ = false;
   pipe->writable_listener_.OnStreamWantsWrite(65536);
 }
 
 void StreamPipe::Unpipe(const FunctionCallbackInfo<Value>& args) {
   StreamPipe* pipe;
-  ASSIGN_OR_RETURN_UNWRAP(&pipe, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&pipe, args.This());
   pipe->Unpipe();
 }
 
 void StreamPipe::IsClosed(const FunctionCallbackInfo<Value>& args) {
   StreamPipe* pipe;
-  ASSIGN_OR_RETURN_UNWRAP(&pipe, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&pipe, args.This());
   args.GetReturnValue().Set(pipe->is_closed_);
 }
 
 void StreamPipe::PendingWrites(const FunctionCallbackInfo<Value>& args) {
   StreamPipe* pipe;
-  ASSIGN_OR_RETURN_UNWRAP(&pipe, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&pipe, args.This());
   args.GetReturnValue().Set(pipe->pending_writes_);
 }
 
diff -r -u --color up/node/src/stream_wrap.cc nw/node/src/stream_wrap.cc
--- up/node/src/stream_wrap.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/stream_wrap.cc	2024-08-26 19:33:05.002595376 +0000
@@ -311,7 +311,7 @@
 
 void LibuvStreamWrap::SetBlocking(const FunctionCallbackInfo<Value>& args) {
   LibuvStreamWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
+  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());
 
   CHECK_GT(args.Length(), 0);
   if (!wrap->IsAlive())
diff -r -u --color up/node/src/tcp_wrap.cc nw/node/src/tcp_wrap.cc
--- up/node/src/tcp_wrap.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/tcp_wrap.cc	2024-08-26 19:33:05.002595376 +0000
@@ -184,9 +184,8 @@
 
 void TCPWrap::SetNoDelay(const FunctionCallbackInfo<Value>& args) {
   TCPWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap,
-                          args.Holder(),
-                          args.GetReturnValue().Set(UV_EBADF));
+  ASSIGN_OR_RETURN_UNWRAP(
+      &wrap, args.This(), args.GetReturnValue().Set(UV_EBADF));
   int enable = static_cast<int>(args[0]->IsTrue());
   int err = uv_tcp_nodelay(&wrap->handle_, enable);
   args.GetReturnValue().Set(err);
@@ -195,9 +194,8 @@
 
 void TCPWrap::SetKeepAlive(const FunctionCallbackInfo<Value>& args) {
   TCPWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap,
-                          args.Holder(),
-                          args.GetReturnValue().Set(UV_EBADF));
+  ASSIGN_OR_RETURN_UNWRAP(
+      &wrap, args.This(), args.GetReturnValue().Set(UV_EBADF));
   Environment* env = wrap->env();
   int enable;
   if (!args[0]->Int32Value(env->context()).To(&enable)) return;
@@ -210,9 +208,8 @@
 #ifdef _WIN32
 void TCPWrap::SetSimultaneousAccepts(const FunctionCallbackInfo<Value>& args) {
   TCPWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap,
-                          args.Holder(),
-                          args.GetReturnValue().Set(UV_EBADF));
+  ASSIGN_OR_RETURN_UNWRAP(
+      &wrap, args.This(), args.GetReturnValue().Set(UV_EBADF));
   bool enable = args[0]->IsTrue();
   int err = uv_tcp_simultaneous_accepts(&wrap->handle_, enable);
   args.GetReturnValue().Set(err);
@@ -222,9 +219,8 @@
 
 void TCPWrap::Open(const FunctionCallbackInfo<Value>& args) {
   TCPWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap,
-                          args.Holder(),
-                          args.GetReturnValue().Set(UV_EBADF));
+  ASSIGN_OR_RETURN_UNWRAP(
+      &wrap, args.This(), args.GetReturnValue().Set(UV_EBADF));
   int64_t val;
   if (!args[0]->IntegerValue(args.GetIsolate()->GetCurrentContext()).To(&val))
     return;
@@ -243,9 +239,8 @@
     int family,
     std::function<int(const char* ip_address, int port, T* addr)> uv_ip_addr) {
   TCPWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap,
-                          args.Holder(),
-                          args.GetReturnValue().Set(UV_EBADF));
+  ASSIGN_OR_RETURN_UNWRAP(
+      &wrap, args.This(), args.GetReturnValue().Set(UV_EBADF));
   Environment* env = wrap->env();
   node::Utf8Value ip_address(env->isolate(), args[0]);
   int port;
@@ -279,9 +274,8 @@
 
 void TCPWrap::Listen(const FunctionCallbackInfo<Value>& args) {
   TCPWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap,
-                          args.Holder(),
-                          args.GetReturnValue().Set(UV_EBADF));
+  ASSIGN_OR_RETURN_UNWRAP(
+      &wrap, args.This(), args.GetReturnValue().Set(UV_EBADF));
   Environment* env = wrap->env();
   int backlog;
   if (!args[0]->Int32Value(env->context()).To(&backlog)) return;
@@ -320,9 +314,8 @@
   Environment* env = Environment::GetCurrent(args);
 
   TCPWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap,
-                          args.Holder(),
-                          args.GetReturnValue().Set(UV_EBADF));
+  ASSIGN_OR_RETURN_UNWRAP(
+      &wrap, args.This(), args.GetReturnValue().Set(UV_EBADF));
 
   CHECK(args[0]->IsObject());
   CHECK(args[1]->IsString());
@@ -361,7 +354,7 @@
 void TCPWrap::Reset(const FunctionCallbackInfo<Value>& args) {
   TCPWrap* wrap;
   ASSIGN_OR_RETURN_UNWRAP(
-      &wrap, args.Holder(), args.GetReturnValue().Set(UV_EBADF));
+      &wrap, args.This(), args.GetReturnValue().Set(UV_EBADF));
 
   int err = wrap->Reset(args[0]);
 
diff -r -u --color up/node/src/tracing/agent.h nw/node/src/tracing/agent.h
--- up/node/src/tracing/agent.h	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/tracing/agent.h	2024-08-26 19:33:05.002595376 +0000
@@ -84,7 +84,7 @@
 class Agent {
  public:
   Agent();
-  ~Agent();
+  ~Agent() {}
 
   TracingController* GetTracingController() {
     TracingController* controller = tracing_controller_.get();
@@ -156,8 +156,8 @@
 };
 
 void AgentWriterHandle::reset() {
-  if (agent_ != nullptr)
-    agent_->Disconnect(id_);
+  //if (agent_ != nullptr)
+  //  agent_->Disconnect(id_);
   agent_ = nullptr;
 }
 
diff -r -u --color up/node/src/tracing/trace_event.h nw/node/src/tracing/trace_event.h
--- up/node/src/tracing/trace_event.h	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/tracing/trace_event.h	2024-08-26 19:33:05.002595376 +0000
@@ -5,6 +5,9 @@
 #ifndef SRC_TRACING_TRACE_EVENT_H_
 #define SRC_TRACING_TRACE_EVENT_H_
 
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wunused-value"
+
 #include "v8-platform.h"
 #include "tracing/agent.h"
 #include "trace_event_common.h"
@@ -69,8 +72,7 @@
 // for best performance when tracing is disabled.
 // const uint8_t*
 //     TRACE_EVENT_API_GET_CATEGORY_GROUP_ENABLED(const char* category_group)
-#define TRACE_EVENT_API_GET_CATEGORY_GROUP_ENABLED              \
-  node::tracing::TraceEventHelper::GetCategoryGroupEnabled
+#define TRACE_EVENT_API_GET_CATEGORY_GROUP_ENABLED 
 
 // Get the number of times traces have been recorded. This is used to implement
 // the TRACE_EVENT_IS_NEW_TRACE facility.
@@ -90,7 +92,7 @@
 //                    const uint8_t* arg_types,
 //                    const uint64_t* arg_values,
 //                    unsigned int flags)
-#define TRACE_EVENT_API_ADD_TRACE_EVENT node::tracing::AddTraceEventImpl
+#define TRACE_EVENT_API_ADD_TRACE_EVENT //node::tracing::AddTraceEventImpl
 
 // Add a trace event to the platform tracing system.
 // uint64_t TRACE_EVENT_API_ADD_TRACE_EVENT_WITH_TIMESTAMP(
@@ -106,18 +108,15 @@
 //                    const uint64_t* arg_values,
 //                    unsigned int flags,
 //                    int64_t timestamp)
-#define TRACE_EVENT_API_ADD_TRACE_EVENT_WITH_TIMESTAMP \
-  node::tracing::AddTraceEventWithTimestampImpl
+#define TRACE_EVENT_API_ADD_TRACE_EVENT_WITH_TIMESTAMP
+  //  node::tracing::AddTraceEventWithTimestampImpl
 
 // Set the duration field of a COMPLETE trace event.
 // void TRACE_EVENT_API_UPDATE_TRACE_EVENT_DURATION(
 //     const uint8_t* category_group_enabled,
 //     const char* name,
 //     uint64_t id)
-#define TRACE_EVENT_API_UPDATE_TRACE_EVENT_DURATION                           \
-  if (auto controller =                                                       \
-         node::tracing::TraceEventHelper::GetTracingController())             \
-      controller->UpdateTraceEventDuration
+#define TRACE_EVENT_API_UPDATE_TRACE_EVENT_DURATION  
 
 // Adds a metadata event to the trace log. The |AppendValueAsTraceFormat| method
 // on the convertable value will be called at flush time.
@@ -152,8 +151,9 @@
 // configuration for each isolate,
 // https://code.google.com/p/v8/issues/detail?id=4563
 #define INTERNAL_TRACE_EVENT_GET_CATEGORY_INFO_CUSTOM_VARIABLES(             \
-    category_group, atomic, category_group_enabled)                          \
-  category_group_enabled =                                                   \
+    category_group, atomic, category_group_enabled)
+#if 0
+category_group_enabled =                                                \
       reinterpret_cast<const uint8_t*>(TRACE_EVENT_API_ATOMIC_LOAD(atomic)); \
   if (!category_group_enabled) {                                             \
     category_group_enabled =                                                 \
@@ -162,6 +162,7 @@
         atomic, reinterpret_cast<TRACE_EVENT_API_ATOMIC_WORD_VALUE>(         \
                     category_group_enabled));                                \
   }
+#endif
 
 #define INTERNAL_TRACE_EVENT_GET_CATEGORY_INFO(category_group)             \
   static TRACE_EVENT_API_ATOMIC_WORD INTERNAL_TRACE_EVENT_UID(atomic) {0}; \
@@ -172,7 +173,8 @@
 
 // Implementation detail: internal macro to create static category and add
 // event if the category is enabled.
-#define INTERNAL_TRACE_EVENT_ADD(phase, category_group, name, flags, ...)    \
+#define INTERNAL_TRACE_EVENT_ADD(phase, category_group, name, flags, ...)
+#if 0
   do {                                                                       \
     INTERNAL_TRACE_EVENT_GET_CATEGORY_INFO(category_group);                  \
     if (INTERNAL_TRACE_EVENT_CATEGORY_GROUP_ENABLED_FOR_RECORDING_MODE()) {  \
@@ -182,7 +184,7 @@
           node::tracing::kNoId, flags, ##__VA_ARGS__);                       \
     }                                                                        \
   } while (0)
-
+#endif
 // Implementation detail: internal macro to create static category and add begin
 // event if the category is enabled. Also adds the end event when the scope
 // ends.
@@ -221,7 +223,8 @@
 // Implementation detail: internal macro to create static category and add
 // event if the category is enabled.
 #define INTERNAL_TRACE_EVENT_ADD_WITH_ID(phase, category_group, name, id,      \
-                                         flags, ...)                           \
+                                         flags, ...)                           
+#if 0
   do {                                                                         \
     INTERNAL_TRACE_EVENT_GET_CATEGORY_INFO(category_group);                    \
     if (INTERNAL_TRACE_EVENT_CATEGORY_GROUP_ENABLED_FOR_RECORDING_MODE()) {    \
@@ -234,6 +237,7 @@
           node::tracing::kNoId, trace_event_flags, ##__VA_ARGS__);             \
     }                                                                          \
   } while (0)
+#endif
 
 // Adds a trace event with a given timestamp.
 #define INTERNAL_TRACE_EVENT_ADD_WITH_TIMESTAMP(phase, category_group, name, \
@@ -455,6 +459,7 @@
   const char* str_;
 };
 
+#if 0
 static inline uint64_t AddTraceEventImpl(
     char phase, const uint8_t* category_group_enabled, const char* name,
     const char* scope, uint64_t id, uint64_t bind_id, int32_t num_args,
@@ -500,6 +505,7 @@
       phase, category_group_enabled, name, scope, id, bind_id, num_args,
       arg_names, arg_types, arg_values, arg_convertables, flags, timestamp);
 }
+#endif
 
 static V8_INLINE void AddMetadataEventImpl(
     const uint8_t* category_group_enabled, const char* name, int32_t num_args,
@@ -717,4 +723,6 @@
 }  // namespace tracing
 }  // namespace node
 
+#pragma clang diagnostic pop
+
 #endif  // SRC_TRACING_TRACE_EVENT_H_
diff -r -u --color up/node/src/tracing/trace_event_common.h nw/node/src/tracing/trace_event_common.h
--- up/node/src/tracing/trace_event_common.h	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/tracing/trace_event_common.h	2024-08-26 19:33:05.002595376 +0000
@@ -382,10 +382,7 @@
   INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_MARK, category_group, name, \
                            TRACE_EVENT_FLAG_COPY)
 
-#define TRACE_EVENT_COPY_MARK_WITH_TIMESTAMP(category_group, name, timestamp) \
-  INTERNAL_TRACE_EVENT_ADD_WITH_TIMESTAMP(                                    \
-      TRACE_EVENT_PHASE_MARK, category_group, name, timestamp,                \
-      TRACE_EVENT_FLAG_COPY)
+#define TRACE_EVENT_COPY_MARK_WITH_TIMESTAMP(category_group, name, timestamp)
 
 // Similar to TRACE_EVENT_ENDx but with a custom |at| timestamp provided.
 // - |id| is used to match the _BEGIN event with the _END event.
@@ -726,6 +723,8 @@
   INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_NESTABLE_ASYNC_BEGIN, \
                                    category_group, name, id,               \
                                    TRACE_EVENT_FLAG_NONE)
+#undef TRACE_EVENT_NESTABLE_ASYNC_BEGIN0
+#define TRACE_EVENT_NESTABLE_ASYNC_BEGIN0(category_group, name, id)
 #define TRACE_EVENT_NESTABLE_ASYNC_BEGIN1(category_group, name, id, arg1_name, \
                                           arg1_val)                            \
   INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_NESTABLE_ASYNC_BEGIN,     \
@@ -743,6 +742,8 @@
   INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_NESTABLE_ASYNC_END, \
                                    category_group, name, id,             \
                                    TRACE_EVENT_FLAG_NONE)
+#undef TRACE_EVENT_NESTABLE_ASYNC_END0
+#define TRACE_EVENT_NESTABLE_ASYNC_END0(category_group, name, id)
 // Records a single NESTABLE_ASYNC_END event called "name" immediately, with 1
 // associated argument. If the category is not enabled, then this does nothing.
 #define TRACE_EVENT_NESTABLE_ASYNC_END1(category_group, name, id, arg1_name, \
@@ -813,15 +814,9 @@
       TRACE_EVENT_PHASE_NESTABLE_ASYNC_INSTANT, category_group, name, id, \
       TRACE_EVENT_API_CURRENT_THREAD_ID, timestamp, TRACE_EVENT_FLAG_NONE)
 #define TRACE_EVENT_COPY_NESTABLE_ASYNC_BEGIN_WITH_TIMESTAMP0(          \
-    category_group, name, id, timestamp)                                \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                   \
-      TRACE_EVENT_PHASE_NESTABLE_ASYNC_BEGIN, category_group, name, id, \
-      TRACE_EVENT_API_CURRENT_THREAD_ID, timestamp, TRACE_EVENT_FLAG_COPY)
+    category_group, name, id, timestamp)
 #define TRACE_EVENT_COPY_NESTABLE_ASYNC_END_WITH_TIMESTAMP0(          \
-    category_group, name, id, timestamp)                              \
-  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                 \
-      TRACE_EVENT_PHASE_NESTABLE_ASYNC_END, category_group, name, id, \
-      TRACE_EVENT_API_CURRENT_THREAD_ID, timestamp, TRACE_EVENT_FLAG_COPY)
+    category_group, name, id, timestamp)                              
 
 // Records a single FLOW_BEGIN event called "name" immediately, with 0, 1 or 2
 // associated arguments. If the category is not enabled, then this
@@ -933,8 +928,8 @@
 
 // TRACE_EVENT_METADATA* events are information related to other
 // injected events, not events in their own right.
-#define TRACE_EVENT_METADATA1(category_group, name, arg1_name, arg1_val) \
-  INTERNAL_TRACE_EVENT_METADATA_ADD(category_group, name, arg1_name, arg1_val)
+#define TRACE_EVENT_METADATA1(category_group, name, arg1_name, arg1_val) 
+//  INTERNAL_TRACE_EVENT_METADATA_ADD(category_group, name, arg1_name, arg1_val)
 
 // Records a clock sync event.
 #define TRACE_EVENT_CLOCK_SYNC_RECEIVER(sync_id)                               \
diff -r -u --color up/node/src/tty_wrap.cc nw/node/src/tty_wrap.cc
--- up/node/src/tty_wrap.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/tty_wrap.cc	2024-08-26 19:33:05.002595376 +0000
@@ -91,9 +91,8 @@
   Environment* env = Environment::GetCurrent(args);
 
   TTYWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap,
-                          args.Holder(),
-                          args.GetReturnValue().Set(UV_EBADF));
+  ASSIGN_OR_RETURN_UNWRAP(
+      &wrap, args.This(), args.GetReturnValue().Set(UV_EBADF));
   CHECK(args[0]->IsArray());
 
   int width, height;
@@ -111,9 +110,8 @@
 
 void TTYWrap::SetRawMode(const FunctionCallbackInfo<Value>& args) {
   TTYWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap,
-                          args.Holder(),
-                          args.GetReturnValue().Set(UV_EBADF));
+  ASSIGN_OR_RETURN_UNWRAP(
+      &wrap, args.This(), args.GetReturnValue().Set(UV_EBADF));
   int err = uv_tty_set_mode(&wrap->handle_, args[0]->IsTrue());
   args.GetReturnValue().Set(err);
 }
diff -r -u --color up/node/src/udp_wrap.cc nw/node/src/udp_wrap.cc
--- up/node/src/udp_wrap.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/udp_wrap.cc	2024-08-26 19:33:05.002595376 +0000
@@ -56,7 +56,7 @@
 namespace {
 template <int (*fn)(uv_udp_t*, int)>
 void SetLibuvInt32(const FunctionCallbackInfo<Value>& args) {
-  UDPWrap* wrap = Unwrap<UDPWrap>(args.Holder());
+  UDPWrap* wrap = Unwrap<UDPWrap>(args.This());
   if (wrap == nullptr) {
     args.GetReturnValue().Set(UV_EBADF);
     return;
@@ -298,9 +298,8 @@
 
 void UDPWrap::DoBind(const FunctionCallbackInfo<Value>& args, int family) {
   UDPWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap,
-                          args.Holder(),
-                          args.GetReturnValue().Set(UV_EBADF));
+  ASSIGN_OR_RETURN_UNWRAP(
+      &wrap, args.This(), args.GetReturnValue().Set(UV_EBADF));
 
   // bind(ip, port, flags)
   CHECK_EQ(args.Length(), 3);
@@ -328,9 +327,8 @@
 
 void UDPWrap::DoConnect(const FunctionCallbackInfo<Value>& args, int family) {
   UDPWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap,
-                          args.Holder(),
-                          args.GetReturnValue().Set(UV_EBADF));
+  ASSIGN_OR_RETURN_UNWRAP(
+      &wrap, args.This(), args.GetReturnValue().Set(UV_EBADF));
 
   CHECK_EQ(args.Length(), 2);
 
@@ -352,9 +350,8 @@
 
 void UDPWrap::Open(const FunctionCallbackInfo<Value>& args) {
   UDPWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap,
-                          args.Holder(),
-                          args.GetReturnValue().Set(UV_EBADF));
+  ASSIGN_OR_RETURN_UNWRAP(
+      &wrap, args.This(), args.GetReturnValue().Set(UV_EBADF));
   CHECK(args[0]->IsNumber());
   int fd = static_cast<int>(args[0].As<Integer>()->Value());
   int err = uv_udp_open(&wrap->handle_, fd);
@@ -376,9 +373,8 @@
 void UDPWrap::BufferSize(const FunctionCallbackInfo<Value>& args) {
   Environment* env = Environment::GetCurrent(args);
   UDPWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap,
-                          args.Holder(),
-                          args.GetReturnValue().Set(UV_EBADF));
+  ASSIGN_OR_RETURN_UNWRAP(
+      &wrap, args.This(), args.GetReturnValue().Set(UV_EBADF));
 
   CHECK(args[0]->IsUint32());
   CHECK(args[1]->IsBoolean());
@@ -421,9 +417,8 @@
 
 void UDPWrap::Disconnect(const FunctionCallbackInfo<Value>& args) {
   UDPWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap,
-                          args.Holder(),
-                          args.GetReturnValue().Set(UV_EBADF));
+  ASSIGN_OR_RETURN_UNWRAP(
+      &wrap, args.This(), args.GetReturnValue().Set(UV_EBADF));
 
   CHECK_EQ(args.Length(), 0);
 
@@ -434,9 +429,8 @@
 
 void UDPWrap::SetMulticastInterface(const FunctionCallbackInfo<Value>& args) {
   UDPWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap,
-                          args.Holder(),
-                          args.GetReturnValue().Set(UV_EBADF));
+  ASSIGN_OR_RETURN_UNWRAP(
+      &wrap, args.This(), args.GetReturnValue().Set(UV_EBADF));
 
   CHECK_EQ(args.Length(), 1);
   CHECK(args[0]->IsString());
@@ -452,9 +446,8 @@
 void UDPWrap::SetMembership(const FunctionCallbackInfo<Value>& args,
                             uv_membership membership) {
   UDPWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap,
-                          args.Holder(),
-                          args.GetReturnValue().Set(UV_EBADF));
+  ASSIGN_OR_RETURN_UNWRAP(
+      &wrap, args.This(), args.GetReturnValue().Set(UV_EBADF));
 
   CHECK_EQ(args.Length(), 2);
 
@@ -486,9 +479,8 @@
 void UDPWrap::SetSourceMembership(const FunctionCallbackInfo<Value>& args,
                                   uv_membership membership) {
   UDPWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap,
-                          args.Holder(),
-                          args.GetReturnValue().Set(UV_EBADF));
+  ASSIGN_OR_RETURN_UNWRAP(
+      &wrap, args.This(), args.GetReturnValue().Set(UV_EBADF));
 
   CHECK_EQ(args.Length(), 3);
 
@@ -526,9 +518,8 @@
   Environment* env = Environment::GetCurrent(args);
 
   UDPWrap* wrap;
-  ASSIGN_OR_RETURN_UNWRAP(&wrap,
-                          args.Holder(),
-                          args.GetReturnValue().Set(UV_EBADF));
+  ASSIGN_OR_RETURN_UNWRAP(
+      &wrap, args.This(), args.GetReturnValue().Set(UV_EBADF));
 
   CHECK(args.Length() == 4 || args.Length() == 6);
   CHECK(args[0]->IsObject());
@@ -678,7 +669,7 @@
 }
 
 void UDPWrapBase::RecvStart(const FunctionCallbackInfo<Value>& args) {
-  UDPWrapBase* wrap = UDPWrapBase::FromObject(args.Holder());
+  UDPWrapBase* wrap = UDPWrapBase::FromObject(args.This());
   args.GetReturnValue().Set(wrap == nullptr ? UV_EBADF : wrap->RecvStart());
 }
 
@@ -693,7 +684,7 @@
 
 
 void UDPWrapBase::RecvStop(const FunctionCallbackInfo<Value>& args) {
-  UDPWrapBase* wrap = UDPWrapBase::FromObject(args.Holder());
+  UDPWrapBase* wrap = UDPWrapBase::FromObject(args.This());
   args.GetReturnValue().Set(wrap == nullptr ? UV_EBADF : wrap->RecvStop());
 }
 
@@ -828,7 +819,7 @@
 void UDPWrap::GetSendQueueSize(const FunctionCallbackInfo<Value>& args) {
   UDPWrap* wrap;
   ASSIGN_OR_RETURN_UNWRAP(
-      &wrap, args.Holder(), args.GetReturnValue().Set(UV_EBADF));
+      &wrap, args.This(), args.GetReturnValue().Set(UV_EBADF));
 
   size_t size = uv_udp_get_send_queue_size(&wrap->handle_);
   args.GetReturnValue().Set(static_cast<double>(size));
@@ -837,7 +828,7 @@
 void UDPWrap::GetSendQueueCount(const FunctionCallbackInfo<Value>& args) {
   UDPWrap* wrap;
   ASSIGN_OR_RETURN_UNWRAP(
-      &wrap, args.Holder(), args.GetReturnValue().Set(UV_EBADF));
+      &wrap, args.This(), args.GetReturnValue().Set(UV_EBADF));
 
   size_t count = uv_udp_get_send_queue_count(&wrap->handle_);
   args.GetReturnValue().Set(static_cast<double>(count));
diff -r -u --color up/node/src/util.cc nw/node/src/util.cc
--- up/node/src/util.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/src/util.cc	2024-08-26 19:33:05.006595375 +0000
@@ -701,11 +701,13 @@
 
 Local<String> UnionBytes::ToStringChecked(Isolate* isolate) const {
   if (is_one_byte()) {
-    return String::NewExternalOneByte(isolate, one_byte_resource_)
-        .ToLocalChecked();
+    return v8::String::NewFromOneByte(isolate, (const uint8_t *)one_byte_resource_->data(),
+				      v8::NewStringType::kNormal,
+				      one_byte_resource_->length()).ToLocalChecked();
   } else {
-    return String::NewExternalTwoByte(isolate, two_byte_resource_)
-        .ToLocalChecked();
+    return v8::String::NewFromTwoByte(isolate, two_byte_resource_->data(),
+				      v8::NewStringType::kNormal,
+				      two_byte_resource_->length()).ToLocalChecked();
   }
 }
 
diff -r -u --color up/node/test/addons/cppgc-object/binding.cc nw/node/test/addons/cppgc-object/binding.cc
--- up/node/test/addons/cppgc-object/binding.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/test/addons/cppgc-object/binding.cc	2024-08-26 19:33:05.006595375 +0000
@@ -1,8 +1,10 @@
+#include <assert.h>
 #include <cppgc/allocation.h>
 #include <cppgc/garbage-collected.h>
 #include <cppgc/heap.h>
 #include <node.h>
 #include <v8-cppgc.h>
+#include <v8-sandbox.h>
 #include <v8.h>
 #include <algorithm>
 
@@ -15,8 +17,10 @@
   static void New(const v8::FunctionCallbackInfo<v8::Value>& args) {
     v8::Isolate* isolate = args.GetIsolate();
     v8::Local<v8::Object> js_object = args.This();
-    CppGCed* gc_object = cppgc::MakeGarbageCollected<CppGCed>(
-        isolate->GetCppHeap()->GetAllocationHandle());
+    auto* heap = isolate->GetCppHeap();
+    assert(heap != nullptr);
+    CppGCed* gc_object =
+        cppgc::MakeGarbageCollected<CppGCed>(heap->GetAllocationHandle());
     node::SetCppgcReference(isolate, js_object, gc_object);
     args.GetReturnValue().Set(js_object);
   }
@@ -24,12 +28,6 @@
   static v8::Local<v8::Function> GetConstructor(
       v8::Local<v8::Context> context) {
     auto ft = v8::FunctionTemplate::New(context->GetIsolate(), New);
-    auto ot = ft->InstanceTemplate();
-    v8::WrapperDescriptor descriptor =
-        context->GetIsolate()->GetCppHeap()->wrapper_descriptor();
-    uint16_t required_size = std::max(descriptor.wrappable_instance_index,
-                                      descriptor.wrappable_type_index);
-    ot->SetInternalFieldCount(required_size + 1);
     return ft->GetFunction(context).ToLocalChecked();
   }
 
diff -r -u --color up/node/test/cctest/test_cppgc.cc nw/node/test/cctest/test_cppgc.cc
--- up/node/test/cctest/test_cppgc.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/test/cctest/test_cppgc.cc	2024-08-26 19:33:05.018595371 +0000
@@ -3,16 +3,12 @@
 #include <cppgc/heap.h>
 #include <node.h>
 #include <v8-cppgc.h>
+#include <v8-sandbox.h>
 #include <v8.h>
 #include "node_test_fixture.h"
 
 // This tests that Node.js can work with an existing CppHeap.
 
-// Mimic the Blink layout.
-static int kWrappableTypeIndex = 0;
-static int kWrappableInstanceIndex = 1;
-static uint16_t kEmbedderID = 0x1;
-
 // Mimic a class that does not know about Node.js.
 class CppGCed : public cppgc::GarbageCollected<CppGCed> {
  public:
@@ -23,12 +19,11 @@
   static void New(const v8::FunctionCallbackInfo<v8::Value>& args) {
     v8::Isolate* isolate = args.GetIsolate();
     v8::Local<v8::Object> js_object = args.This();
-    CppGCed* gc_object = cppgc::MakeGarbageCollected<CppGCed>(
-        isolate->GetCppHeap()->GetAllocationHandle());
-    js_object->SetAlignedPointerInInternalField(kWrappableTypeIndex,
-                                                &kEmbedderID);
-    js_object->SetAlignedPointerInInternalField(kWrappableInstanceIndex,
-                                                gc_object);
+    auto* heap = isolate->GetCppHeap();
+    CHECK_NOT_NULL(heap);
+    CppGCed* gc_object =
+        cppgc::MakeGarbageCollected<CppGCed>(heap->GetAllocationHandle());
+    node::SetCppgcReference(isolate, js_object, gc_object);
     kConstructCount++;
     args.GetReturnValue().Set(js_object);
   }
@@ -36,8 +31,6 @@
   static v8::Local<v8::Function> GetConstructor(
       v8::Local<v8::Context> context) {
     auto ft = v8::FunctionTemplate::New(context->GetIsolate(), New);
-    auto ot = ft->InstanceTemplate();
-    ot->SetInternalFieldCount(2);
     return ft->GetFunction(context).ToLocalChecked();
   }
 
@@ -58,12 +51,12 @@
 
   // Create and attach the CppHeap before we set up the IsolateData so that
   // it recognizes the existing heap.
-  std::unique_ptr<v8::CppHeap> cpp_heap = v8::CppHeap::Create(
-      platform.get(),
-      v8::CppHeapCreateParams(
-          {},
-          v8::WrapperDescriptor(
-              kWrappableTypeIndex, kWrappableInstanceIndex, kEmbedderID)));
+  std::unique_ptr<v8::CppHeap> cpp_heap =
+      v8::CppHeap::Create(platform.get(), v8::CppHeapCreateParams{{}});
+
+  // TODO(joyeecheung): pass it into v8::Isolate::CreateParams and let V8
+  // own it when we can keep the isolate registered/task runner discoverable
+  // during isolate disposal.
   isolate->AttachCppHeap(cpp_heap.get());
 
   // Try creating Context + IsolateData + Environment.
diff -r -u --color up/node/test/parallel/test-timers-unref.js nw/node/test/parallel/test-timers-unref.js
--- up/node/test/parallel/test-timers-unref.js	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/test/parallel/test-timers-unref.js	2024-08-26 19:33:05.414595259 +0000
@@ -72,7 +72,7 @@
     setInterval(() => timeout.unref(), SHORT_TIME);
 }
 
-// Should not assert on args.Holder()->InternalFieldCount() > 0.
+// Should not assert on args.This()->InternalFieldCount() > 0.
 // See https://github.com/nodejs/node-v0.x-archive/issues/4261.
 {
   const t = setInterval(() => {}, 1);
diff -r -u --color up/node/test/parallel/test-worker-unsupported-things.js nw/node/test/parallel/test-worker-unsupported-things.js
--- up/node/test/parallel/test-worker-unsupported-things.js	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/test/parallel/test-worker-unsupported-things.js	2024-08-26 19:33:05.442595250 +0000
@@ -14,14 +14,16 @@
 } else {
   {
     const before = process.title;
-    process.title += ' in worker';
-    assert.strictEqual(process.title, before);
+    const after = before + ' in worker';
+    process.title = after;
+    assert.strictEqual(process.title, after);
   }
 
   {
     const before = process.debugPort;
-    process.debugPort++;
-    assert.strictEqual(process.debugPort, before);
+    const after = before + 1;
+    process.debugPort = after;
+    assert.strictEqual(process.debugPort, after);
   }
 
   {
diff -r -u --color up/node/tools/gyp/pylib/gyp/generator/ninja.py nw/node/tools/gyp/pylib/gyp/generator/ninja.py
--- up/node/tools/gyp/pylib/gyp/generator/ninja.py	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/tools/gyp/pylib/gyp/generator/ninja.py	2024-08-26 19:33:05.478595240 +0000
@@ -90,8 +90,12 @@
         # cl.exe replaces literal # characters with = in preprocessor definitions for
         # some reason. Octal-encode to work around that.
         d = d.replace("#", "\\%03o" % ord("#"))
-    return QuoteShellArgument(ninja_syntax.escape("-D" + d), flavor)
-
+    ret = QuoteShellArgument(ninja_syntax.escape("-D" + d), flavor)
+    if flavor == "win" :
+        if re.match(r".*MODULESDIR.*", ret) :
+            ret = ret.replace("\\", "\\\\")
+            ret = ret.replace("\\\\\"", "\\\"")
+    return ret
 
 def AddArch(output, arch):
     """Adds an arch string to an output path."""
diff -r -u --color up/node/tools/js2c.cc nw/node/tools/js2c.cc
--- up/node/tools/js2c.cc	2024-05-15 06:45:30.000000000 +0000
+++ nw/node/tools/js2c.cc	2024-08-26 19:33:05.494595236 +0000
@@ -345,7 +345,9 @@
   return WriteFileSync(out, dest.c_str());
 }
 
-std::string GetFileId(const std::string& filename) {
+std::string GetFileId(const std::string& fn) {
+  std::string filename = fn;
+  std::replace(filename.begin(), filename.end(), '\\', '/');
   size_t end = filename.size();
   size_t start = 0;
   std::string prefix;
@@ -374,7 +376,7 @@
   size_t length = result.size();
 
   for (size_t i = 0; i < length; ++i) {
-    if (result[i] == '.' || result[i] == '-' || result[i] == '/') {
+    if (result[i] == '.' || result[i] == '-' || result[i] == '/' || result[i] == '\\') {
       result[i] = '_';
     }
   }
