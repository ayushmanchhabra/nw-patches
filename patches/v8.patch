Only in nw/v8: .git
diff -r -u --color up/v8/BUILD.gn nw/v8/BUILD.gn
--- up/v8/BUILD.gn	2024-03-25 17:43:57.000000000 +0000
+++ nw/v8/BUILD.gn	2024-04-11 17:51:36.757696524 +0000
@@ -57,7 +57,7 @@
   v8_deprecation_warnings = true
 
   # Enable compiler warnings when using V8_DEPRECATE_SOON apis.
-  v8_imminent_deprecation_warnings = true
+  v8_imminent_deprecation_warnings = false
 
   # Embeds the given script into the snapshot.
   v8_embed_script = ""
@@ -335,7 +335,7 @@
 
   # Enable the experimental V8 sandbox.
   # Sets -DV8_ENABLE_SANDBOX.
-  v8_enable_sandbox = ""
+  v8_enable_sandbox = false
 
   # Expose the memory corruption API to JavaScript. Useful for testing the sandbox.
   # WARNING This will expose builtins that (by design) cause memory corruption.
@@ -364,7 +364,7 @@
   v8_enable_map_packing = false
 
   # Allow for JS promise hooks (instead of just C++).
-  v8_enable_javascript_promise_hooks = false
+  v8_enable_javascript_promise_hooks = true
 
   # Allow embedder data to be saved on continuations. Used to support
   # TaskAttribution and `scheduler.yield()`.
@@ -385,7 +385,7 @@
   # Enable legacy mode for ScriptOrModule's lifetime. By default it's a
   # temporary object, if enabled it will be kept alive by the parent Script.
   # This is only used by nodejs.
-  v8_scriptormodule_legacy_lifetime = false
+  v8_scriptormodule_legacy_lifetime = true
 
   # Enables pointer compression for 8GB heaps.
   # Sets -DV8_COMPRESS_POINTERS_8GB.
@@ -749,7 +749,7 @@
 
 config("internal_config") {
   defines = []
-
+  cflags = []
   # Only targets in this file and its subdirs can depend on this.
   visibility = [ "./*" ]
 
@@ -762,7 +762,8 @@
 
   if (is_component_build) {
     defines += [ "BUILDING_V8_SHARED_PRIVATE" ]
-  } else if (v8_expose_public_symbols) {
+  } #else if (v8_expose_public_symbols) {
+  if (true) {
     defines += [ "BUILDING_V8_SHARED" ]
   }
 
@@ -771,6 +772,10 @@
       libs = [ "atomic" ]
     }
   }
+
+  if (is_win) {
+    cflags += [ "/Zc:dllexportInlines-" ]
+  }
 }
 
 # Should be applied to all targets that write trace events.
@@ -787,14 +792,14 @@
 # This config should be applied to code using the libplatform.
 config("libplatform_config") {
   include_dirs = [ "include" ]
-  if (is_component_build) {
+  if (false) {
     defines = [ "USING_V8_PLATFORM_SHARED" ]
   }
 }
 
 # This config should be applied to code using the libbase.
 config("libbase_config") {
-  if (is_component_build) {
+  if (false) {
     defines = [ "USING_V8_BASE_SHARED" ]
   }
   libs = []
@@ -836,7 +841,10 @@
     defines += [
       "USING_V8_SHARED",
       "USING_V8_SHARED_PRIVATE",
+      "V8_SHARED", "USING_V8_PLATFORM_SHARED"
     ]
+  } else {
+    defines += [ "V8_SHARED" ]
   }
 
   if (current_cpu == "riscv64" || current_cpu == "riscv32") {
@@ -2802,6 +2810,8 @@
   visibility = [
     ":*",
     "test/cctest:*",
+    "//tools/v8_context_snapshot:*",
+    "//chrome:*",
   ]
 
   allow_circular_includes_from = [ ":torque_generated_initializers" ]
@@ -6236,7 +6246,8 @@
   ]
 }
 
-v8_component("v8_libbase") {
+v8_static_lib("v8_libbase") {
+
   sources = [
     "src/base/abort-mode.cc",
     "src/base/abort-mode.h",
@@ -6375,7 +6386,7 @@
 
   defines = []
 
-  if (is_component_build) {
+  if (false) {
     defines = [ "BUILDING_V8_BASE_SHARED" ]
   }
 
@@ -6535,7 +6546,7 @@
   }
 }
 
-v8_component("v8_libplatform") {
+v8_static_lib("v8_libplatform") {
   sources = [
     "//base/trace_event/common/trace_event_common.h",
     "include/libplatform/libplatform-export.h",
@@ -6568,7 +6579,7 @@
 
   configs = [ ":internal_config_base" ]
 
-  if (is_component_build) {
+  if (true) {
     defines = [ "BUILDING_V8_PLATFORM_SHARED" ]
   }
 
@@ -7010,6 +7021,25 @@
 ###############################################################################
 # Executables
 #
+v8_executable("nwjc") {
+
+    sources = [
+      "src/nwjc.cc",
+    ]
+
+    configs = [
+      ":internal_config",
+    ]
+
+    deps = [
+      ":v8_base",
+      ":v8_libplatform",
+      ":v8_libbase",
+      ":v8_snapshot",
+      ":v8_initializers",
+      "//build/win:default_exe_manifest",
+    ]
+}
 
 if (current_toolchain == v8_generator_toolchain) {
   v8_executable("bytecode_builtins_list_generator") {
diff -r -u --color up/v8/gni/v8.gni nw/v8/gni/v8.gni
--- up/v8/gni/v8.gni	2024-03-25 17:43:57.000000000 +0000
+++ nw/v8/gni/v8.gni	2024-04-11 17:51:36.757696524 +0000
@@ -179,7 +179,7 @@
 # If chromium is configured to use the perfetto client library, v8 should also
 # use perfetto for tracing.
 if (build_with_chromium && use_perfetto_client_library) {
-  v8_use_perfetto = true
+  v8_use_perfetto = false
 }
 
 # Includes profiles to optimize builtins if
@@ -321,6 +321,15 @@
   }
 }
 
+template("v8_static_lib") {
+  static_library(target_name) {
+    forward_variables_from(invoker, "*", [ "configs" ])
+    configs += invoker.configs
+    configs -= v8_remove_configs
+    configs += v8_add_configs
+  }
+}
+
 template("v8_executable") {
   if (is_ios) {
     import("//build/config/ios/rules.gni")
Only in nw/v8: gypfiles
diff -r -u --color up/v8/include/libplatform/libplatform.h nw/v8/include/libplatform/libplatform.h
--- up/v8/include/libplatform/libplatform.h	2024-03-25 17:43:57.000000000 +0000
+++ nw/v8/include/libplatform/libplatform.h	2024-04-11 17:51:36.761696531 +0000
@@ -41,7 +41,7 @@
  * multiple task queues executed by threads different system-level priorities
  * (where available) to schedule tasks.
  */
-V8_PLATFORM_EXPORT std::unique_ptr<v8::Platform> NewDefaultPlatform(
+V8_EXPORT std::unique_ptr<v8::Platform> NewDefaultPlatform(
     int thread_pool_size = 0,
     IdleTaskSupport idle_task_support = IdleTaskSupport::kDisabled,
     InProcessStackDumping in_process_stack_dumping =
@@ -80,7 +80,8 @@
  * the |behavior| parameter, this call does not block if no task is pending. The
  * |platform| has to be created using |NewDefaultPlatform|.
  */
-V8_PLATFORM_EXPORT bool PumpMessageLoop(
+
+V8_EXPORT bool PumpMessageLoop(
     v8::Platform* platform, v8::Isolate* isolate,
     MessageLoopBehavior behavior = MessageLoopBehavior::kDoNotWait);
 
@@ -91,7 +92,7 @@
  * This call does not block if no task is pending. The |platform| has to be
  * created using |NewDefaultPlatform|.
  */
-V8_PLATFORM_EXPORT void RunIdleTasks(v8::Platform* platform,
+V8_EXPORT void RunIdleTasks(v8::Platform* platform,
                                      v8::Isolate* isolate,
                                      double idle_time_in_seconds);
 
diff -r -u --color up/v8/include/libplatform/v8-tracing.h nw/v8/include/libplatform/v8-tracing.h
--- up/v8/include/libplatform/v8-tracing.h	2024-03-25 17:43:57.000000000 +0000
+++ nw/v8/include/libplatform/v8-tracing.h	2024-04-11 17:51:36.761696531 +0000
@@ -34,7 +34,7 @@
 
 const int kTraceMaxNumArgs = 2;
 
-class V8_PLATFORM_EXPORT TraceObject {
+class V8_EXPORT TraceObject {
  public:
   union ArgValue {
     uint64_t as_uint;
@@ -45,7 +45,7 @@
   };
 
   TraceObject() = default;
-  ~TraceObject();
+  ~TraceObject() { delete[] parameter_copy_storage_; }
   void Initialize(
       char phase, const uint8_t* category_enabled_flag, const char* name,
       const char* scope, uint64_t id, uint64_t bind_id, int num_args,
diff -r -u --color up/v8/include/v8-array-buffer.h nw/v8/include/v8-array-buffer.h
--- up/v8/include/v8-array-buffer.h	2024-03-25 17:43:57.000000000 +0000
+++ nw/v8/include/v8-array-buffer.h	2024-04-11 17:51:36.765696538 +0000
@@ -186,7 +186,8 @@
      * while kReservation is for larger allocations with the ability to set
      * access permissions.
      */
-    enum class AllocationMode { kNormal, kReservation };
+    enum class AllocationMode { kNormal, kReservation, kNodeJS };
+    virtual void Free(void* data, size_t length, AllocationMode mode);
 
     /**
      * Convenience allocator.
@@ -232,6 +233,8 @@
    */
   static Local<ArrayBuffer> New(Isolate* isolate,
                                 std::shared_ptr<BackingStore> backing_store);
+  static Local<ArrayBuffer> NewNode(Isolate* isolate,
+                                std::shared_ptr<BackingStore> backing_store);
 
   /**
    * Returns a new standalone BackingStore that is allocated using the array
@@ -292,6 +295,8 @@
       "ok).")
   void Detach();
 
+  void set_nodejs(bool);
+
   /**
    * Detaches this ArrayBuffer and all its views (typed arrays).
    * Detaching sets the byte length of the buffer and all typed arrays to zero,
diff -r -u --color up/v8/include/v8-debug.h nw/v8/include/v8-debug.h
--- up/v8/include/v8-debug.h	2024-03-25 17:43:57.000000000 +0000
+++ nw/v8/include/v8-debug.h	2024-04-11 17:51:36.765696538 +0000
@@ -130,6 +130,8 @@
     kDetailed = kOverview | kIsEval | kIsConstructor | kScriptNameOrSourceURL
   };
 
+  V8_DEPRECATED("Use Isolate version")
+                Local<StackFrame> GetFrame(uint32_t index) const;
   /**
    * Returns a StackFrame at a particular index.
    */
diff -r -u --color up/v8/include/v8-initialization.h nw/v8/include/v8-initialization.h
--- up/v8/include/v8-initialization.h	2024-03-25 17:43:57.000000000 +0000
+++ nw/v8/include/v8-initialization.h	2024-04-11 17:51:36.765696538 +0000
@@ -151,6 +151,7 @@
    */
   static bool InitializeICUDefaultLocation(const char* exec_path,
                                            const char* icu_data_file = nullptr);
+  static void* RawICUData();
 
   /**
    * Initialize the external startup data. The embedder only needs to
diff -r -u --color up/v8/include/v8-isolate.h nw/v8/include/v8-isolate.h
--- up/v8/include/v8-isolate.h	2024-03-25 17:43:57.000000000 +0000
+++ nw/v8/include/v8-isolate.h	2024-04-11 17:51:36.765696538 +0000
@@ -209,6 +209,7 @@
  */
 class V8_EXPORT Isolate {
  public:
+  ArrayBuffer::Allocator* array_buffer_allocator();
   /**
    * Initial configuration parameters for a new Isolate.
    */
@@ -302,6 +303,7 @@
     CppHeap* cpp_heap = nullptr;
   };
 
+  void SetArrayBufferAllocatorShared(std::shared_ptr<ArrayBuffer::Allocator> allocator);
   /**
    * Stack-allocated class which sets the isolate for all operations
    * executed within a local scope.
diff -r -u --color up/v8/include/v8-platform.h nw/v8/include/v8-platform.h
--- up/v8/include/v8-platform.h	2024-03-25 17:43:57.000000000 +0000
+++ nw/v8/include/v8-platform.h	2024-04-11 17:51:36.765696538 +0000
@@ -12,6 +12,37 @@
 
 #include <memory>
 #include <string>
+#include "v8config.h"
+
+#ifdef V8_OS_WIN
+
+// Setup for Windows DLL export/import. When building the V8 DLL the
+// BUILDING_V8_SHARED needs to be defined. When building a program which uses
+// the V8 DLL USING_V8_SHARED needs to be defined. When either building the V8
+// static library or building a program which uses the V8 static library neither
+// BUILDING_V8_SHARED nor USING_V8_SHARED should be defined.
+#ifdef BUILDING_V8_SHARED
+# define V8_EXPORT __declspec(dllexport)
+#elif USING_V8_SHARED
+# define V8_EXPORT __declspec(dllimport)
+#else
+# define V8_EXPORT
+#endif  // BUILDING_V8_SHARED
+
+#else  // V8_OS_WIN
+
+// Setup for Linux shared library export.
+#if V8_HAS_ATTRIBUTE_VISIBILITY
+# ifdef BUILDING_V8_SHARED
+#  define V8_EXPORT __attribute__ ((visibility("default")))
+# else
+#  define V8_EXPORT
+# endif
+#else
+# define V8_EXPORT
+#endif
+
+#endif  // V8_OS_WIN
 
 #include "v8-source-location.h"  // NOLINT(build/include_directory)
 #include "v8config.h"  // NOLINT(build/include_directory)
@@ -1313,6 +1344,7 @@
       TaskPriority priority, std::unique_ptr<Task> task,
       double delay_in_seconds, const SourceLocation& location) = 0;
 };
+void V8_EXPORT SetTLSPlatform(Platform* platform);
 
 }  // namespace v8
 
diff -r -u --color up/v8/include/v8-primitive-object.h nw/v8/include/v8-primitive-object.h
--- up/v8/include/v8-primitive-object.h	2024-03-25 17:43:57.000000000 +0000
+++ nw/v8/include/v8-primitive-object.h	2024-04-11 17:51:36.765696538 +0000
@@ -78,6 +78,8 @@
  */
 class V8_EXPORT StringObject : public Object {
  public:
+  V8_DEPRECATED("Use Isolate* version") static
+                       Local<Value> New(Local<String> value);
   static Local<Value> New(Isolate* isolate, Local<String> value);
 
   Local<String> ValueOf() const;
diff -r -u --color up/v8/include/v8-primitive.h nw/v8/include/v8-primitive.h
--- up/v8/include/v8-primitive.h	2024-03-25 17:43:57.000000000 +0000
+++ nw/v8/include/v8-primitive.h	2024-04-11 17:51:36.765696538 +0000
@@ -69,6 +69,9 @@
     return reinterpret_cast<PrimitiveArray*>(data);
   }
 
+  V8_DEPRECATED("Use Isolate version")
+                void Set(int index, Local<Primitive> item);
+  V8_DEPRECATED("Use Isolate version") Local<Primitive> Get(int index);
  private:
   static void CheckCast(Data* obj);
 };
@@ -140,6 +143,7 @@
    * Returns the number of bytes in the UTF-8 encoded
    * representation of this string.
    */
+  V8_DEPRECATED("Use Isolate version instead") int Utf8Length() const;
   int Utf8Length(Isolate* isolate) const;
 
   /**
@@ -196,13 +200,24 @@
   // 16-bit character codes.
   int Write(Isolate* isolate, uint16_t* buffer, int start = 0, int length = -1,
             int options = NO_OPTIONS) const;
+  V8_DEPRECATED("Use Isolate* version")
+                int Write(uint16_t* buffer, int start = 0, int length = -1,
+                          int options = NO_OPTIONS) const;
   // One byte characters.
   int WriteOneByte(Isolate* isolate, uint8_t* buffer, int start = 0,
                    int length = -1, int options = NO_OPTIONS) const;
+  V8_DEPRECATED("Use Isolate* version")
+                int WriteOneByte(uint8_t* buffer, int start = 0,
+                                 int length = -1, int options = NO_OPTIONS)
+                    const;
   // UTF-8 encoded characters.
   int WriteUtf8(Isolate* isolate, char* buffer, int length = -1,
                 int* nchars_ref = nullptr, int options = NO_OPTIONS) const;
 
+  V8_DEPRECATED("Use Isolate* version")
+                int WriteUtf8(char* buffer, int length = -1,
+                              int* nchars_ref = NULL, int options = NO_OPTIONS)
+                    const;
   /**
    * A zero length string.
    */
@@ -446,6 +461,9 @@
   static Local<String> Concat(Isolate* isolate, Local<String> left,
                               Local<String> right);
 
+  V8_DEPRECATED("Use Isolate* version") static
+                       Local<String> Concat(Local<String> left,
+                                            Local<String> right);
   /**
    * Creates a new external string using the data defined in the given
    * resource. When the external string is no longer live on V8's heap the
@@ -510,6 +528,8 @@
    */
   class V8_EXPORT Utf8Value {
    public:
+   V8_DEPRECATED("Use Isolate version")
+                  explicit Utf8Value(Local<v8::Value> obj);
     Utf8Value(Isolate* isolate, Local<v8::Value> obj);
     ~Utf8Value();
     char* operator*() { return str_; }
@@ -533,6 +553,7 @@
    */
   class V8_EXPORT Value {
    public:
+   V8_DEPRECATED("Use Isolate version") explicit Value(Local<v8::Value> obj);
     Value(Isolate* isolate, Local<v8::Value> obj);
     ~Value();
     uint16_t* operator*() { return str_; }
diff -r -u --color up/v8/include/v8-script.h nw/v8/include/v8-script.h
--- up/v8/include/v8-script.h	2024-03-25 17:43:57.000000000 +0000
+++ nw/v8/include/v8-script.h	2024-04-11 17:51:36.765696538 +0000
@@ -718,6 +718,7 @@
       CompileOptions options = kNoCompileOptions,
       NoCacheReason no_cache_reason = kNoCacheNoReason);
 
+  static MaybeLocal<Module> CompileModuleWithCache(Isolate* isolate, Source* source);
   /**
    * Returns a task which streams script data into V8, or NULL if the script
    * cannot be streamed. The user is responsible for running the task on a
@@ -915,6 +916,9 @@
   return reinterpret_cast<Module*>(data);
 }
 
+void V8_EXPORT FixSourceNWBin(Isolate* v8_isolate, Local<UnboundScript> script);
+void V8_EXPORT FixSourceNWBin(Isolate* v8_isolate, Local<Module> module);
+
 }  // namespace v8
 
 #endif  // INCLUDE_V8_SCRIPT_H_
diff -r -u --color up/v8/include/v8-value.h nw/v8/include/v8-value.h
--- up/v8/include/v8-value.h	2024-03-25 17:43:57.000000000 +0000
+++ nw/v8/include/v8-value.h	2024-04-11 17:51:36.769696544 +0000
@@ -421,6 +421,10 @@
    */
   Local<Boolean> ToBoolean(Isolate* isolate) const;
 
+  V8_DEPRECATED("Use maybe version") Local<Boolean> ToBoolean() const;
+  V8_DEPRECATED("Use maybe version") Local<String> ToString() const;
+  V8_DEPRECATED("Use maybe version") Local<Object> ToObject() const;
+  V8_DEPRECATED("Use maybe version") Local<Integer> ToInteger() const;
   /**
    * Attempts to convert a string to an array index.
    * Returns an empty handle if the conversion fails.
@@ -442,7 +446,14 @@
   /** Returns the equivalent of `ToInt32()->Value()`. */
   V8_WARN_UNUSED_RESULT Maybe<int32_t> Int32Value(Local<Context> context) const;
 
+  V8_DEPRECATED("Use maybe version") bool BooleanValue() const;
+  V8_DEPRECATED("Use maybe version") double NumberValue() const;
+  V8_DEPRECATED("Use maybe version") int64_t IntegerValue() const;
+  V8_DEPRECATED("Use maybe version") uint32_t Uint32Value() const;
+  V8_DEPRECATED("Use maybe version") int32_t Int32Value() const;
+
   /** JS == */
+  V8_DEPRECATED("Use maybe version") bool Equals(Local<Value> that) const;
   V8_WARN_UNUSED_RESULT Maybe<bool> Equals(Local<Context> context,
                                            Local<Value> that) const;
   bool StrictEquals(Local<Value> that) const;
diff -r -u --color up/v8/include/v8-wasm.h nw/v8/include/v8-wasm.h
--- up/v8/include/v8-wasm.h	2024-03-25 17:43:57.000000000 +0000
+++ nw/v8/include/v8-wasm.h	2024-04-11 17:51:36.769696544 +0000
@@ -121,6 +121,9 @@
   static void CheckCast(Value* obj);
 };
 
+V8_DEPRECATED("Use WasmModuleObject")
+              typedef WasmModuleObject WasmCompiledModule;
+
 /**
  * The V8 interface for WebAssembly streaming compilation. When streaming
  * compilation is initiated, V8 passes a {WasmStreaming} object to the embedder
diff -r -u --color up/v8/include/v8config.h nw/v8/include/v8config.h
--- up/v8/include/v8config.h	2024-03-25 17:43:57.000000000 +0000
+++ nw/v8/include/v8config.h	2024-04-11 17:51:36.769696544 +0000
@@ -368,7 +368,7 @@
          && !defined(_WIN32)))                         /* not on windows */    \
      && !defined(COMPONENT_BUILD)                      /* no component build */\
      && __clang_major__ >= 17                          /* clang >= 17 */
-# define V8_HAS_ATTRIBUTE_PRESERVE_MOST (__has_attribute(preserve_most))
+//# define V8_HAS_ATTRIBUTE_PRESERVE_MOST (__has_attribute(preserve_most))
 #endif
 # define V8_HAS_ATTRIBUTE_VISIBILITY (__has_attribute(visibility))
 # define V8_HAS_ATTRIBUTE_WARN_UNUSED_RESULT \
diff -r -u --color up/v8/src/api/api.cc nw/v8/src/api/api.cc
--- up/v8/src/api/api.cc	2024-03-25 17:43:57.000000000 +0000
+++ nw/v8/src/api/api.cc	2024-04-11 17:51:36.773696551 +0000
@@ -179,6 +179,31 @@
 namespace v8 {
 
 static OOMErrorCallback g_oom_error_callback = nullptr;
+namespace {
+
+// TODO(delphick): Remove this completely when the deprecated functions that use
+// it are removed.
+// DO NOT USE THIS IN NEW CODE!
+i::Isolate* UnsafeIsolateFromHeapObject(i::Handle<i::HeapObject> obj) {
+  // Use MemoryChunk directly instead of Isolate::FromWritableHeapObject to
+  // temporarily allow isolate access from read-only space objects.
+  i::MemoryChunk* chunk = i::MemoryChunk::FromHeapObject(*obj);
+  return chunk->heap()->isolate();
+}
+
+// TODO(delphick): Remove this completely when the deprecated functions that use
+// it are removed.
+// DO NOT USE THIS IN NEW CODE!
+Local<Context> UnsafeContextFromHeapObject(i::Handle<i::Object> obj) {
+  // Use MemoryChunk directly instead of Isolate::FromWritableHeapObject to
+  // temporarily allow isolate access from read-only space objects.
+  i::MemoryChunk* chunk =
+      i::MemoryChunk::FromHeapObject(i::HeapObject::cast(*obj));
+  return reinterpret_cast<Isolate*>(chunk->heap()->isolate())
+      ->GetCurrentContext();
+}
+
+}  // namespace
 
 static ScriptOrigin GetScriptOriginForScript(i::Isolate* i_isolate,
                                              i::Handle<i::Script> script) {
@@ -354,6 +379,11 @@
   i::V8::SetSnapshotBlob(snapshot_blob);
 }
 
+void v8::ArrayBuffer::Allocator::Free(void* data, size_t length,
+                                      AllocationMode mode) {
+  UNIMPLEMENTED();
+}
+
 namespace {
 
 #ifdef V8_ENABLE_SANDBOX
@@ -2265,6 +2295,12 @@
   array->set(index, *Utils::OpenDirectHandle(*item));
 }
 
+void PrimitiveArray::Set(int index, Local<Primitive> item) {
+  i::Handle<i::FixedArray> array = Utils::OpenHandle(this);
+  i::Isolate* isolate = UnsafeIsolateFromHeapObject(array);
+  Set(reinterpret_cast<Isolate*>(isolate), index, item);
+}
+
 Local<Primitive> PrimitiveArray::Get(Isolate* v8_isolate, int index) {
   i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(v8_isolate);
   auto array = Utils::OpenDirectHandle(this);
@@ -2315,6 +2351,12 @@
       i::direct_handle(self->import_attributes(), i_isolate), i_isolate);
 }
 
+Local<Primitive> PrimitiveArray::Get(int index) {
+  i::Handle<i::FixedArray> array = Utils::OpenHandle(this);
+  i::Isolate* isolate = UnsafeIsolateFromHeapObject(array);
+  return Get(reinterpret_cast<Isolate*>(isolate), index);
+}
+
 Module::Status Module::GetStatus() const {
   auto self = Utils::OpenDirectHandle(this);
   switch (self->status()) {
@@ -2707,6 +2749,21 @@
   return ToApiHandle<Module>(i_isolate->factory()->NewSourceTextModule(shared));
 }
 
+MaybeLocal<Module> ScriptCompiler::CompileModuleWithCache(Isolate* isolate,
+                                                          Source* source) {
+  i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(isolate);
+
+  Utils::ApiCheck(source->GetResourceOptions().IsModule(),
+                  "v8::ScriptCompiler::CompileModule",
+                  "Invalid ScriptOrigin: is_module must be true");
+  auto maybe = CompileUnboundInternal(isolate, source, kConsumeCodeCache, kNoCacheNoReason);
+  Local<UnboundScript> unbound;
+  if (!maybe.ToLocal(&unbound)) return MaybeLocal<Module>();
+
+  i::Handle<i::SharedFunctionInfo> shared = Utils::OpenHandle(*unbound);
+  return ToApiHandle<Module>(i_isolate->factory()->NewSourceTextModule(shared));
+}
+
 // static
 V8_WARN_UNUSED_RESULT MaybeLocal<Function> ScriptCompiler::CompileFunction(
     Local<Context> context, Source* source, size_t arguments_count,
@@ -3325,6 +3382,11 @@
       i_isolate);
 }
 
+Local<StackFrame> StackTrace::GetFrame(uint32_t index) const {
+  i::Isolate* isolate = UnsafeIsolateFromHeapObject(Utils::OpenHandle(this));
+  return GetFrame(reinterpret_cast<Isolate*>(isolate), index);
+}
+
 int StackTrace::GetFrameCount() const {
   return Utils::OpenDirectHandle(this)->length();
 }
@@ -3354,8 +3416,8 @@
   i::Isolate* i_isolate = self->GetIsolate();
   i::Handle<i::Script> script(self->script(), i_isolate);
   i::Script::PositionInfo info;
-  CHECK(i::Script::GetPositionInfo(
-      script, i::StackFrameInfo::GetSourcePosition(self), &info));
+  i::Script::GetPositionInfo(
+     script, i::StackFrameInfo::GetSourcePosition(self), &info);
   if (script->HasSourceURLComment()) {
     info.line -= script->line_offset();
     if (info.line == 0) {
@@ -3736,6 +3798,25 @@
 
 // --- D a t a ---
 
+Local<Boolean> Value::ToBoolean() const {
+  return ToBoolean(Isolate::GetCurrent());
+}
+
+Local<String> Value::ToString() const {
+  return ToString(Isolate::GetCurrent()->GetCurrentContext())
+      .FromMaybe(Local<String>());
+}
+
+Local<Object> Value::ToObject() const {
+  return ToObject(Isolate::GetCurrent()->GetCurrentContext())
+      .FromMaybe(Local<Object>());
+}
+
+Local<Integer> Value::ToInteger() const {
+  return ToInteger(Isolate::GetCurrent()->GetCurrentContext())
+      .FromMaybe(Local<Integer>());
+}
+
 bool Value::FullIsUndefined() const {
   bool result = i::IsUndefined(*Utils::OpenDirectHandle(this));
   DCHECK_EQ(result, QuickIsUndefined());
@@ -4389,6 +4470,15 @@
                   "Value is not a RegExp");
 }
 
+bool Value::BooleanValue() const {
+  auto obj = Utils::OpenHandle(this);
+  if (i::IsSmi(*obj)) return *obj != i::Smi::zero();
+  DCHECK(obj->IsHeapObject());
+  i::Isolate* isolate =
+      UnsafeIsolateFromHeapObject(i::Handle<i::HeapObject>::cast(obj));
+  return i::Object::BooleanValue(*obj, isolate);
+}
+
 Maybe<double> Value::NumberValue(Local<Context> context) const {
   auto obj = Utils::OpenHandle(this);
   if (i::IsNumber(*obj)) return Just(i::Object::Number(*obj));
@@ -4400,6 +4490,13 @@
   return Just(i::Object::Number(*num));
 }
 
+double Value::NumberValue() const {
+  auto obj = Utils::OpenHandle(this);
+  if (i::IsNumber(*obj)) return i::Object::Number(*obj);
+  return NumberValue(UnsafeContextFromHeapObject(obj))
+      .FromMaybe(std::numeric_limits<double>::quiet_NaN());
+}
+
 Maybe<int64_t> Value::IntegerValue(Local<Context> context) const {
   auto obj = Utils::OpenHandle(this);
   if (i::IsNumber(*obj)) {
@@ -4413,6 +4510,18 @@
   return Just(NumberToInt64(*num));
 }
 
+int64_t Value::IntegerValue() const {
+  auto obj = Utils::OpenHandle(this);
+  if (i::IsNumber(*obj)) {
+    if (i::IsSmi(*obj)) {
+      return i::Smi::ToInt(*obj);
+    } else {
+      return static_cast<int64_t>(i::Object::Number(*obj));
+    }
+  }
+  return IntegerValue(UnsafeContextFromHeapObject(obj)).FromMaybe(0);
+}
+
 Maybe<int32_t> Value::Int32Value(Local<Context> context) const {
   auto obj = Utils::OpenHandle(this);
   if (i::IsNumber(*obj)) return Just(NumberToInt32(*obj));
@@ -4425,6 +4534,12 @@
                           : static_cast<int32_t>(i::Object::Number(*num)));
 }
 
+int32_t Value::Int32Value() const {
+  auto obj = Utils::OpenHandle(this);
+  if (i::IsNumber(*obj)) return NumberToInt32(*obj);
+  return Int32Value(UnsafeContextFromHeapObject(obj)).FromMaybe(0);
+}
+
 Maybe<uint32_t> Value::Uint32Value(Local<Context> context) const {
   auto obj = Utils::OpenHandle(this);
   if (i::IsNumber(*obj)) return Just(NumberToUint32(*obj));
@@ -4437,6 +4552,12 @@
                           : static_cast<uint32_t>(i::Object::Number(*num)));
 }
 
+uint32_t Value::Uint32Value() const {
+  auto obj = Utils::OpenHandle(this);
+  if (i::IsNumber(*obj)) return NumberToUint32(*obj);
+  return Uint32Value(UnsafeContextFromHeapObject(obj)).FromMaybe(0);
+}
+
 MaybeLocal<Uint32> Value::ToArrayIndex(Local<Context> context) const {
   auto self = Utils::OpenHandle(this);
   if (i::IsSmi(*self)) {
@@ -4472,6 +4593,20 @@
   return result;
 }
 
+bool Value::Equals(Local<Value> that) const {
+  auto self = Utils::OpenHandle(this);
+  auto other = Utils::OpenHandle(*that);
+  if (i::IsSmi(*self) && i::IsSmi(*other)) {
+    return i::Object::Number(*self) == i::Object::Number(*other);
+  }
+  if (IsJSObject(*self) && IsJSObject(*other)) {
+    return *self == *other;
+  }
+  auto heap_object = i::IsSmi(*self) ? other : self;
+  auto context = UnsafeContextFromHeapObject(heap_object);
+  return Equals(context, that).FromMaybe(false);
+}
+
 bool Value::StrictEquals(Local<Value> that) const {
   auto self = Utils::OpenHandle(this);
   auto other = Utils::OpenHandle(*that);
@@ -5822,6 +5957,11 @@
   return helper.Check(*str);
 }
 
+int String::Utf8Length() const {
+  i::Isolate* isolate = UnsafeIsolateFromHeapObject(Utils::OpenHandle(this));
+  return Utf8Length(reinterpret_cast<Isolate*>(isolate));
+}
+
 int String::Utf8Length(Isolate* v8_isolate) const {
   auto str = Utils::OpenHandle(this);
   str = i::String::Flatten(reinterpret_cast<i::Isolate*>(v8_isolate), str);
@@ -5974,6 +6114,7 @@
 }
 }  // anonymous namespace
 
+
 int String::WriteUtf8(Isolate* v8_isolate, char* buffer, int capacity,
                       int* nchars_ref, int options) const {
   auto str = Utils::OpenHandle(this);
@@ -5992,6 +6133,14 @@
   }
 }
 
+int String::WriteUtf8(char* buffer, int capacity, int* nchars_ref,
+                      int options) const {
+  i::Handle<i::String> str = Utils::OpenHandle(this);
+  i::Isolate* isolate = UnsafeIsolateFromHeapObject(str);
+  return WriteUtf8(reinterpret_cast<Isolate*>(isolate), buffer, capacity,
+                   nchars_ref, options);
+}
+
 template <typename CharType>
 static inline int WriteHelper(i::Isolate* i_isolate, const String* string,
                               CharType* buffer, int start, int length,
@@ -6013,12 +6162,23 @@
   return write_length;
 }
 
+int String::WriteOneByte(uint8_t* buffer, int start, int length,
+                         int options) const {
+  i::Isolate* isolate = UnsafeIsolateFromHeapObject(Utils::OpenHandle(this));
+  return WriteHelper(isolate, this, buffer, start, length, options);
+}
+
 int String::WriteOneByte(Isolate* v8_isolate, uint8_t* buffer, int start,
                          int length, int options) const {
   return WriteHelper(reinterpret_cast<i::Isolate*>(v8_isolate), this, buffer,
                      start, length, options);
 }
 
+int String::Write(uint16_t* buffer, int start, int length, int options) const {
+  i::Isolate* isolate = UnsafeIsolateFromHeapObject(Utils::OpenHandle(this));
+  return WriteHelper(isolate, this, buffer, start, length, options);
+}
+
 int String::Write(Isolate* v8_isolate, uint16_t* buffer, int start, int length,
                   int options) const {
   return WriteHelper(reinterpret_cast<i::Isolate*>(v8_isolate), this, buffer,
@@ -6535,6 +6695,10 @@
   return i::InitializeICUDefaultLocation(exec_path, icu_data_file);
 }
 
+void* v8::V8::RawICUData() {
+  return i::RawICUData();
+}
+
 void v8::V8::InitializeExternalStartupData(const char* directory_path) {
   i::InitializeExternalStartupData(directory_path);
 }
@@ -7590,6 +7754,12 @@
   return Utils::ToLocal(result);
 }
 
+Local<String> v8::String::Concat(Local<String> left, Local<String> right) {
+  i::Handle<i::String> left_string = Utils::OpenHandle(*left);
+  i::Isolate* isolate = UnsafeIsolateFromHeapObject(left_string);
+  return Concat(reinterpret_cast<Isolate*>(isolate), left, right);
+}
+
 MaybeLocal<String> v8::String::NewExternalTwoByte(
     Isolate* v8_isolate, v8::String::ExternalStringResource* resource) {
   CHECK(resource && resource->data());
@@ -7892,6 +8062,12 @@
   return i::IsTrue(js_primitive_wrapper->value(), i_isolate);
 }
 
+Local<v8::Value> v8::StringObject::New(Local<String> value) {
+  i::Handle<i::String> string = Utils::OpenHandle(*value);
+  i::Isolate* isolate = UnsafeIsolateFromHeapObject(string);
+  return New(reinterpret_cast<Isolate*>(isolate), value);
+}
+
 Local<v8::Value> v8::StringObject::New(Isolate* v8_isolate,
                                        Local<String> value) {
   auto string = Utils::OpenHandle(*value);
@@ -9035,6 +9211,25 @@
       static_cast<v8::BackingStore*>(backing_store.release()));
 }
 
+Local<ArrayBuffer> v8::ArrayBuffer::NewNode(
+    Isolate* isolate, std::shared_ptr<BackingStore> backing_store) {
+  CHECK_IMPLIES(backing_store->ByteLength() != 0,
+                backing_store->Data() != nullptr);
+  i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(isolate);
+  API_RCS_SCOPE(i_isolate, ArrayBuffer, New);
+  ENTER_V8_NO_SCRIPT_NO_EXCEPTION(i_isolate);
+  std::shared_ptr<i::BackingStore> i_backing_store(
+      ToInternal(std::move(backing_store)));
+  Utils::ApiCheck(
+      !i_backing_store->is_shared(), "v8_ArrayBuffer_New",
+      "Cannot construct ArrayBuffer with a BackingStore of SharedArrayBuffer");
+  i_backing_store->set_nodejs(true);
+  i::Handle<i::JSArrayBuffer> obj =
+      i_isolate->factory()->NewJSArrayBuffer(std::move(i_backing_store));
+  obj->set_is_node_js(true);
+  return Utils::ToLocal(obj);
+}
+
 Local<ArrayBuffer> v8::ArrayBufferView::Buffer() {
   auto obj = Utils::OpenDirectHandle(this);
   i::Isolate* i_isolate = obj->GetIsolate();
@@ -9444,6 +9639,11 @@
   i_isolate->ClearKeptObjects();
 }
 
+ArrayBuffer::Allocator* Isolate::array_buffer_allocator() {
+  i::Isolate* isolate = reinterpret_cast<i::Isolate*>(this);
+  return isolate->array_buffer_allocator();
+}
+
 v8::Local<v8::Context> Isolate::GetCurrentContext() {
   i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(this);
   i::Tagged<i::Context> context = i_isolate->context();
@@ -9648,6 +9848,13 @@
 
 Isolate::CreateParams::~CreateParams() = default;
 
+void Isolate::SetArrayBufferAllocatorShared(
+                                            std::shared_ptr<ArrayBuffer::Allocator> allocator) {
+  i::Isolate* isolate = reinterpret_cast<i::Isolate*>(this);
+  CHECK_EQ(allocator.get(), isolate->array_buffer_allocator());
+  isolate->set_array_buffer_allocator_shared(std::move(allocator));
+}
+
 // static
 // This is separate so that tests can provide a different |isolate|.
 void Isolate::Initialize(Isolate* v8_isolate,
@@ -10677,6 +10884,9 @@
   return microtask_queue->IsRunningMicrotasks();
 }
 
+String::Utf8Value::Utf8Value(v8::Local<v8::Value> obj)
+  : Utf8Value(Isolate::GetCurrent(), obj) {}
+
 String::Utf8Value::Utf8Value(v8::Isolate* v8_isolate, v8::Local<v8::Value> obj)
     : str_(nullptr), length_(0) {
   if (obj.IsEmpty()) return;
@@ -10694,6 +10904,9 @@
 
 String::Utf8Value::~Utf8Value() { i::DeleteArray(str_); }
 
+String::Value::Value(v8::Local<v8::Value> obj)
+  : Value(Isolate::GetCurrent(), obj) {}
+
 String::Value::Value(v8::Isolate* v8_isolate, v8::Local<v8::Value> obj)
     : str_(nullptr), length_(0) {
   if (obj.IsEmpty()) return;
@@ -11500,6 +11713,29 @@
 }
 #endif  // !V8_ENABLE_WEBASSEMBLY
 
+void SetTLSPlatform(Platform* platform) {
+  i::V8::SetTLSPlatform(platform);
+}
+
+void FixSourceNWBin(Isolate* v8_isolate, Local<UnboundScript> script) {
+  i::Isolate* isolate = reinterpret_cast<i::Isolate*>(v8_isolate);
+  i::Handle<i::HeapObject> obj =
+    i::Handle<i::HeapObject>::cast(v8::Utils::OpenHandle(*script));
+  i::Handle<i::SharedFunctionInfo>
+    function_info(i::SharedFunctionInfo::cast(*obj), isolate);
+  i::Handle<i::Script> iscript(i::Script::cast(function_info->script()),
+                              isolate);
+  iscript->set_source(i::ReadOnlyRoots(isolate).undefined_value());
+}
+
+void FixSourceNWBin(Isolate* v8_isolate, Local<Module> module) {
+  i::Isolate* isolate = reinterpret_cast<i::Isolate*>(v8_isolate);
+  i::Handle<i::SourceTextModule> obj =
+    i::Handle<i::SourceTextModule>::cast(v8::Utils::OpenHandle(*module));
+  i::Handle<i::Script> iscript(i::Script::cast(obj->GetScript()), isolate);
+  iscript->set_source(i::ReadOnlyRoots(isolate).undefined_value());
+}
+
 namespace internal {
 
 const size_t HandleScopeImplementer::kEnteredContextsOffset =
diff -r -u --color up/v8/src/codegen/compiler.cc nw/v8/src/codegen/compiler.cc
--- up/v8/src/codegen/compiler.cc	2024-03-25 17:43:57.000000000 +0000
+++ nw/v8/src/codegen/compiler.cc	2024-04-11 17:51:36.829696645 +0000
@@ -3628,7 +3628,9 @@
     maybe_script = lookup_result.script();
     maybe_result = lookup_result.toplevel_sfi();
     is_compiled_scope = lookup_result.is_compiled_scope();
-    if (!maybe_result.is_null()) {
+    //NWJS#5168: will hit previous cache, use 0 source_length trick to
+    //bypass and try to consume cache
+    if (!maybe_result.is_null() && source->length()) {
       compile_timer.set_hit_isolate_cache();
     } else if (can_consume_code_cache) {
       compile_timer.set_consuming_code_cache();
diff -r -u --color up/v8/src/debug/debug-scopes.cc nw/v8/src/debug/debug-scopes.cc
--- up/v8/src/debug/debug-scopes.cc	2024-03-25 17:43:57.000000000 +0000
+++ nw/v8/src/debug/debug-scopes.cc	2024-04-11 17:51:36.917696793 +0000
@@ -310,7 +310,10 @@
   info_ = std::make_unique<ParseInfo>(isolate_, flags, &compile_state,
                                       reusable_compile_state_.get());
 
-  const bool parse_result =
+  bool has_source_code = shared_info->HasSourceCode();
+  bool parse_result = false;
+  if (has_source_code)
+    parse_result =
       flags.is_toplevel()
           ? parsing::ParseProgram(info_.get(), script, maybe_outer_scope,
                                   isolate_, parsing::ReportStatisticsMode::kNo)
diff -r -u --color up/v8/src/flags/flag-definitions.h nw/v8/src/flags/flag-definitions.h
--- up/v8/src/flags/flag-definitions.h	2024-03-25 17:43:57.000000000 +0000
+++ nw/v8/src/flags/flag-definitions.h	2024-04-11 17:51:36.941696833 +0000
@@ -2261,7 +2261,7 @@
 DEFINE_IMPLICATION(log_maps, log_code)
 
 // parser.cc
-DEFINE_BOOL(allow_natives_syntax, false, "allow natives syntax")
+DEFINE_BOOL(allow_natives_syntax, true, "allow natives syntax")
 DEFINE_BOOL(allow_natives_for_differential_fuzzing, false,
             "allow only natives explicitly allowlisted for differential "
             "fuzzers")
@@ -2559,6 +2559,7 @@
 DEFINE_BOOL(print_flag_values, false, "Print all flag values of V8")
 
 // Slow histograms are also enabled via --dump-counters in d8.
+DEFINE_BOOL(nw_module, false, "Whether the input file is a module")
 DEFINE_BOOL(slow_histograms, false,
             "Enable slow histograms with more overhead.")
 
diff -r -u --color up/v8/src/heap/marking-visitor-inl.h nw/v8/src/heap/marking-visitor-inl.h
--- up/v8/src/heap/marking-visitor-inl.h	2024-03-25 17:43:57.000000000 +0000
+++ nw/v8/src/heap/marking-visitor-inl.h	2024-04-11 17:51:36.961696867 +0000
@@ -323,6 +323,13 @@
     return false;
   }
 
+  Tagged<Object> script_obj = sfi->script();
+  if (!i::IsUndefined(script_obj)) {
+    Tagged<Script> script = Script::cast(script_obj);
+    if (i::IsUndefined(script->source()))
+      return false;
+  }
+
   return IsBytecodeArray(data);
 }
 
diff -r -u --color up/v8/src/init/icu_util.cc nw/v8/src/init/icu_util.cc
--- up/v8/src/init/icu_util.cc	2024-03-25 17:43:57.000000000 +0000
+++ nw/v8/src/init/icu_util.cc	2024-04-11 17:51:36.973696887 +0000
@@ -36,6 +36,10 @@
 }  // namespace
 #endif
 
+void* RawICUData() {
+  return (void*)g_icu_data_ptr;
+}
+
 bool InitializeICUDefaultLocation(const char* exec_path,
                                   const char* icu_data_file) {
 #if !defined(V8_INTL_SUPPORT)
diff -r -u --color up/v8/src/init/icu_util.h nw/v8/src/init/icu_util.h
--- up/v8/src/init/icu_util.h	2024-03-25 17:43:57.000000000 +0000
+++ nw/v8/src/init/icu_util.h	2024-04-11 17:51:36.973696887 +0000
@@ -18,6 +18,8 @@
 bool InitializeICUDefaultLocation(const char* exec_path,
                                   const char* icu_data_file);
 
+void* RawICUData();
+
 }  // namespace internal
 }  // namespace v8
 
diff -r -u --color up/v8/src/init/startup-data-util.cc nw/v8/src/init/startup-data-util.cc
--- up/v8/src/init/startup-data-util.cc	2024-03-25 17:43:57.000000000 +0000
+++ nw/v8/src/init/startup-data-util.cc	2024-04-11 17:51:36.973696887 +0000
@@ -77,10 +77,23 @@
 
 void InitializeExternalStartupData(const char* directory_path) {
 #ifdef V8_USE_EXTERNAL_STARTUP_DATA
+#if 0
   const char* snapshot_name = "snapshot_blob.bin";
   std::unique_ptr<char[]> snapshot =
       base::RelativePath(directory_path, snapshot_name);
   LoadFromFile(snapshot.get());
+#endif
+#ifdef __APPLE__
+#if V8_TARGET_ARCH_X64
+  const char* snapshot_name = "v8_context_snapshot.x86_64.bin";
+#else
+  const char* snapshot_name = "v8_context_snapshot.arm64.bin";
+#endif
+#else
+  const char* snapshot_name = "v8_context_snapshot.bin";
+#endif
+  std::unique_ptr<char[]> snapshot = base::RelativePath(directory_path, snapshot_name);
+  LoadFromFile(snapshot.get());
 #endif  // V8_USE_EXTERNAL_STARTUP_DATA
 }
 
diff -r -u --color up/v8/src/init/v8.cc nw/v8/src/init/v8.cc
--- up/v8/src/init/v8.cc	2024-03-25 17:43:57.000000000 +0000
+++ nw/v8/src/init/v8.cc	2024-04-11 17:51:36.973696887 +0000
@@ -96,11 +96,20 @@
 #endif
 
 // static
+base::Thread::LocalStorageKey platform_tls_key_;
+void V8::SetTLSPlatform(v8::Platform* platform) {
+  base::Thread::SetThreadLocal(platform_tls_key_, platform);
+}
+
 void V8::InitializePlatform(v8::Platform* platform) {
   AdvanceStartupState(V8StartupState::kPlatformInitializing);
   CHECK(!platform_);
   CHECK_NOT_NULL(platform);
   platform_ = platform;
+
+  platform_tls_key_ = base::Thread::CreateThreadLocalKey();
+  base::Thread::SetThreadLocal(platform_tls_key_, platform);
+
   v8::base::SetPrintStackTrace(platform_->GetStackTracePrinter());
   v8::tracing::TracingCategoryObserver::SetUp();
 #if defined(V8_OS_WIN) && defined(V8_ENABLE_ETW_STACK_WALKING)
@@ -281,7 +290,6 @@
 #endif
   IsolateAllocator::InitializeOncePerProcess();
   Isolate::InitializeOncePerProcess();
-
 #if defined(USE_SIMULATOR)
   Simulator::InitializeOncePerProcess();
 #endif
@@ -349,7 +357,11 @@
 }
 
 v8::Platform* V8::GetCurrentPlatform() {
-  v8::Platform* platform = reinterpret_cast<v8::Platform*>(
+  v8::Platform* platform;
+  platform = reinterpret_cast<v8::Platform*>(base::Thread::GetThreadLocal(platform_tls_key_));
+  if (platform)
+    return platform;
+  platform = reinterpret_cast<v8::Platform*>(
       base::Relaxed_Load(reinterpret_cast<base::AtomicWord*>(&platform_)));
   DCHECK(platform);
   return platform;
diff -r -u --color up/v8/src/init/v8.h nw/v8/src/init/v8.h
--- up/v8/src/init/v8.h	2024-03-25 17:43:57.000000000 +0000
+++ nw/v8/src/init/v8.h	2024-04-11 17:51:36.973696887 +0000
@@ -42,6 +42,7 @@
   [[noreturn]] V8_EXPORT_PRIVATE static void FatalProcessOutOfMemory(
       Isolate* isolate, const char* location, const char* detail);
 
+  static void SetTLSPlatform(v8::Platform* platform);
   static void InitializePlatform(v8::Platform* platform);
   V8_EXPORT_PRIVATE static void InitializePlatformForTesting(
       v8::Platform* platform);
diff -r -u --color up/v8/src/inspector/v8-heap-profiler-agent-impl.cc nw/v8/src/inspector/v8-heap-profiler-agent-impl.cc
--- up/v8/src/inspector/v8-heap-profiler-agent-impl.cc	2024-03-25 17:43:57.000000000 +0000
+++ nw/v8/src/inspector/v8-heap-profiler-agent-impl.cc	2024-04-11 17:51:36.977696894 +0000
@@ -390,6 +390,15 @@
     progress.reset(new HeapSnapshotProgress(&m_frontend));
 
   GlobalObjectNameResolver resolver(m_session);
+#ifdef __APPLE__
+    // exit the context we entered in g_uv_runloop_once or taking
+    // snapshot will fail.
+    v8::Isolate* isolate = v8::Isolate::GetCurrent();
+    v8::HandleScope handle_scope(isolate);
+    v8::Local<v8::Context> context = isolate->GetEnteredOrMicrotaskContext();
+    if (!context.IsEmpty())
+      context->Exit();
+#endif
   v8::HeapProfiler::HeapSnapshotOptions options;
   options.global_object_name_resolver = &resolver;
   options.control = progress.get();
@@ -406,6 +415,10 @@
           : v8::HeapProfiler::NumericsMode::kHideNumericValues;
   options.stack_state = stackState;
   const v8::HeapSnapshot* snapshot = profiler->TakeHeapSnapshot(options);
+#ifdef __APPLE__
+    if (!context.IsEmpty())
+      context->Enter();
+#endif
   if (!snapshot) return Response::ServerError("Failed to take heap snapshot");
   HeapSnapshotOutputStream stream(&m_frontend);
   snapshot->Serialize(&stream);
diff -r -u --color up/v8/src/inspector/v8-stack-trace-impl.cc nw/v8/src/inspector/v8-stack-trace-impl.cc
--- up/v8/src/inspector/v8-stack-trace-impl.cc	2024-03-25 17:43:57.000000000 +0000
+++ nw/v8/src/inspector/v8-stack-trace-impl.cc	2024-04-11 17:51:36.977696894 +0000
@@ -179,8 +179,8 @@
       m_lineNumber(lineNumber),
       m_columnNumber(columnNumber),
       m_hasSourceURLComment(hasSourceURLComment) {
-  DCHECK_NE(v8::Message::kNoLineNumberInfo, m_lineNumber + 1);
-  DCHECK_NE(v8::Message::kNoColumnInfo, m_columnNumber + 1);
+  //DCHECK_NE(v8::Message::kNoLineNumberInfo, m_lineNumber + 1);
+  //DCHECK_NE(v8::Message::kNoColumnInfo, m_columnNumber + 1);
 }
 
 const String16& StackFrame::functionName() const { return m_functionName; }
diff -r -u --color up/v8/src/libplatform/tracing/trace-object.cc nw/v8/src/libplatform/tracing/trace-object.cc
--- up/v8/src/libplatform/tracing/trace-object.cc	2024-03-25 17:43:57.000000000 +0000
+++ nw/v8/src/libplatform/tracing/trace-object.cc	2024-04-11 17:51:36.985696907 +0000
@@ -99,7 +99,7 @@
   }
 }
 
-TraceObject::~TraceObject() { delete[] parameter_copy_storage_; }
+//TraceObject::~TraceObject() { delete[] parameter_copy_storage_; }
 
 void TraceObject::UpdateDuration(int64_t timestamp, int64_t cpu_timestamp) {
   duration_ = timestamp - ts_;
Only in nw/v8/src: nwjc.cc
diff -r -u --color up/v8/src/objects/backing-store.cc nw/v8/src/objects/backing-store.cc
--- up/v8/src/objects/backing-store.cc	2024-03-25 17:43:57.000000000 +0000
+++ nw/v8/src/objects/backing-store.cc	2024-04-11 17:51:36.997696927 +0000
@@ -144,6 +144,7 @@
       is_resizable_by_js_(resizable == ResizableFlag::kResizable),
       is_wasm_memory_(is_wasm_memory),
       is_wasm_memory64_(is_wasm_memory64),
+      is_nodejs_(false),
       holds_shared_ptr_to_allocator_(false),
       has_guard_regions_(has_guard_regions),
       globally_registered_(false),
@@ -225,6 +226,16 @@
     return;
   }
 
+  if (is_nodejs_) {
+    // JSArrayBuffer backing store. Deallocate through the embedder's allocator.
+    auto allocator = reinterpret_cast<v8::ArrayBuffer::Allocator*>(
+        get_v8_api_array_buffer_allocator());
+    TRACE_BS("BSn:free   bs=%p mem=%p (length=%zu, capacity=%zu)\n", this,
+             buffer_start_, byte_length(), byte_capacity_);
+    allocator->Free(buffer_start_, byte_length_, v8::ArrayBuffer::Allocator::AllocationMode::kNodeJS);
+    return;
+  }
+
   // JSArrayBuffer backing store. Deallocate through the embedder's allocator.
   auto allocator = get_v8_api_array_buffer_allocator();
   TRACE_BS("BS:free   bs=%p mem=%p (length=%zu, capacity=%zu)\n", this,
@@ -710,7 +721,7 @@
 std::unique_ptr<BackingStore> BackingStore::WrapAllocation(
     void* allocation_base, size_t allocation_length,
     v8::BackingStore::DeleterCallback deleter, void* deleter_data,
-    SharedFlag shared) {
+    SharedFlag shared, bool is_nodejs) {
   bool is_empty_deleter = (deleter == v8::BackingStore::EmptyDeleter);
   auto result = new BackingStore(allocation_base,               // start
                                  allocation_length,             // length
@@ -723,6 +734,7 @@
                                  false,              // has_guard_regions
                                  true,               // custom_deleter
                                  is_empty_deleter);  // empty_deleter
+  result->is_nodejs_ = is_nodejs;
   result->type_specific_data_.deleter = {deleter, deleter_data};
   TRACE_BS("BS:wrap   bs=%p mem=%p (length=%zu)\n", result,
            result->buffer_start(), result->byte_length());
diff -r -u --color up/v8/src/objects/backing-store.h nw/v8/src/objects/backing-store.h
--- up/v8/src/objects/backing-store.h	2024-03-25 17:43:57.000000000 +0000
+++ nw/v8/src/objects/backing-store.h	2024-04-11 17:51:36.997696927 +0000
@@ -75,7 +75,7 @@
   static std::unique_ptr<BackingStore> WrapAllocation(
       void* allocation_base, size_t allocation_length,
       v8::BackingStore::DeleterCallback deleter, void* deleter_data,
-      SharedFlag shared);
+      SharedFlag shared, bool is_nodejs = false);
 
   // Create an empty backing store.
   static std::unique_ptr<BackingStore> EmptyBackingStore(SharedFlag shared);
@@ -91,6 +91,7 @@
   bool is_shared() const { return is_shared_; }
   bool is_resizable_by_js() const { return is_resizable_by_js_; }
   bool is_wasm_memory() const { return is_wasm_memory_; }
+  bool is_node_js() const { return is_nodejs_; }
   bool has_guard_regions() const { return has_guard_regions_; }
 
   bool IsEmpty() const {
@@ -108,6 +109,7 @@
            !is_resizable_by_js_ && buffer_start_ != nullptr;
   }
 
+  void set_nodejs(bool nodejs) { is_nodejs_ = nodejs; }
   // Wrapper around ArrayBuffer::Allocator::Reallocate.
   bool Reallocate(Isolate* isolate, size_t new_byte_length);
 
@@ -221,6 +223,7 @@
   const bool is_resizable_by_js_ : 1;
   const bool is_wasm_memory_ : 1;
   const bool is_wasm_memory64_ : 1;
+  bool is_nodejs_ : 1;
   bool holds_shared_ptr_to_allocator_ : 1;
   const bool has_guard_regions_ : 1;
   bool globally_registered_ : 1;
diff -r -u --color up/v8/src/objects/js-array-buffer-inl.h nw/v8/src/objects/js-array-buffer-inl.h
--- up/v8/src/objects/js-array-buffer-inl.h	2024-03-25 17:43:57.000000000 +0000
+++ nw/v8/src/objects/js-array-buffer-inl.h	2024-04-11 17:51:37.005696941 +0000
@@ -174,6 +174,8 @@
                     JSArrayBuffer::IsSharedBit)
 BIT_FIELD_ACCESSORS(JSArrayBuffer, bit_field, is_resizable_by_js,
                     JSArrayBuffer::IsResizableByJsBit)
+BIT_FIELD_ACCESSORS(JSArrayBuffer, bit_field, is_node_js,
+                    JSArrayBuffer::IsNodejsBit)
 
 bool JSArrayBuffer::IsEmpty() const {
   auto backing_store = GetBackingStore();
diff -r -u --color up/v8/src/objects/js-array-buffer.h nw/v8/src/objects/js-array-buffer.h
--- up/v8/src/objects/js-array-buffer.h	2024-03-25 17:43:57.000000000 +0000
+++ nw/v8/src/objects/js-array-buffer.h	2024-04-11 17:51:37.005696941 +0000
@@ -71,6 +71,7 @@
 
   // [was_detached]: true => the buffer was previously detached.
   DECL_BOOLEAN_ACCESSORS(was_detached)
+  DECL_BOOLEAN_ACCESSORS(is_node_js)
 
   // [is_shared]: true if this is a SharedArrayBuffer or a
   // GrowableSharedArrayBuffer.
diff -r -u --color up/v8/src/objects/js-array-buffer.tq nw/v8/src/objects/js-array-buffer.tq
--- up/v8/src/objects/js-array-buffer.tq	2024-03-25 17:43:57.000000000 +0000
+++ nw/v8/src/objects/js-array-buffer.tq	2024-04-11 17:51:37.005696941 +0000
@@ -9,6 +9,7 @@
   is_asm_js_memory: bool: 1 bit;
   is_shared: bool: 1 bit;
   is_resizable_by_js: bool: 1 bit;
+  is_nodejs: bool: 1 bit;
 }
 
 extern class JSArrayBuffer extends JSObjectWithEmbedderSlots {
diff -r -u --color up/v8/src/objects/js-function.cc nw/v8/src/objects/js-function.cc
--- up/v8/src/objects/js-function.cc	2024-03-25 17:43:57.000000000 +0000
+++ nw/v8/src/objects/js-function.cc	2024-04-11 17:51:37.009696948 +0000
@@ -1302,6 +1302,13 @@
     return NativeCodeFunctionSourceString(isolate, shared_info);
   }
 
+  //NWJS#6061: moved here or it will crash when trying to print
+  //function as a class
+  // Check if we have source code for the {function}.
+  if (!shared_info->HasSourceCode()) {
+    return NativeCodeFunctionSourceString(isolate, shared_info);
+  }
+
   if (IsClassConstructor(shared_info->kind())) {
     // Check if we should print {function} as a class.
     Handle<Object> maybe_class_positions = JSReceiver::GetDataProperty(
@@ -1318,11 +1325,6 @@
     }
   }
 
-  // Check if we have source code for the {function}.
-  if (!shared_info->HasSourceCode()) {
-    return NativeCodeFunctionSourceString(isolate, shared_info);
-  }
-
   // If this function was compiled from asm.js, use the recorded offset
   // information.
 #if V8_ENABLE_WEBASSEMBLY
diff -r -u --color up/v8/src/objects/script.h nw/v8/src/objects/script.h
--- up/v8/src/objects/script.h	2024-03-25 17:43:57.000000000 +0000
+++ nw/v8/src/objects/script.h	2024-04-11 17:51:37.029696982 +0000
@@ -250,8 +250,10 @@
   friend FactoryBase<Factory>;
   friend FactoryBase<LocalFactory>;
 
+public:
   // Hide torque-generated accessor, use Script::SetSource instead.
   using TorqueGeneratedScript::set_source;
+private:
 
   // Bit positions in the flags field.
   DEFINE_TORQUE_GENERATED_SCRIPT_FLAGS()
diff -r -u --color up/v8/src/profiler/tracing-cpu-profiler.cc nw/v8/src/profiler/tracing-cpu-profiler.cc
--- up/v8/src/profiler/tracing-cpu-profiler.cc	2024-03-25 17:43:57.000000000 +0000
+++ nw/v8/src/profiler/tracing-cpu-profiler.cc	2024-04-11 17:51:37.041697001 +0000
@@ -28,6 +28,7 @@
 #if defined(V8_USE_PERFETTO)
   TrackEvent::RemoveSessionObserver(this);
 #else
+  if (V8::GetCurrentPlatform())
   V8::GetCurrentPlatform()->GetTracingController()->RemoveTraceStateObserver(
       this);
 #endif
diff -r -u --color up/v8/src/snapshot/code-serializer.cc nw/v8/src/snapshot/code-serializer.cc
--- up/v8/src/snapshot/code-serializer.cc	2024-03-25 17:43:57.000000000 +0000
+++ nw/v8/src/snapshot/code-serializer.cc	2024-04-11 17:51:37.057697028 +0000
@@ -470,6 +470,7 @@
   if (!maybe_result.ToHandle(&result)) {
     // Deserializing may fail if the reservations cannot be fulfilled.
     if (v8_flags.profile_deserialization) PrintF("[Deserializing failed]\n");
+    cached_data->Reject();
     return MaybeHandle<SharedFunctionInfo>();
   }
 
@@ -776,9 +777,12 @@
     SerializedCodeSanityCheckResult* rejection_result) {
   DisallowGarbageCollection no_gc;
   SerializedCodeData scd(cached_data);
+  *rejection_result = SerializedCodeSanityCheckResult::kSuccess;
+#if 0
   *rejection_result = scd.SanityCheck(
       Snapshot::ExtractReadOnlySnapshotChecksum(isolate->snapshot_blob()),
       expected_source_hash);
+#endif
   if (*rejection_result != SerializedCodeSanityCheckResult::kSuccess) {
     cached_data->Reject();
     return SerializedCodeData(nullptr, 0);
diff -r -u --color up/v8/src/snapshot/deserializer.cc nw/v8/src/snapshot/deserializer.cc
--- up/v8/src/snapshot/deserializer.cc	2024-03-25 17:43:57.000000000 +0000
+++ nw/v8/src/snapshot/deserializer.cc	2024-04-11 17:51:37.057697028 +0000
@@ -265,7 +265,9 @@
 #ifdef DEBUG
   num_api_references_ = GetNumApiReferences(isolate);
 #endif  // DEBUG
-  CHECK_EQ(magic_number_, SerializedData::kMagicNumber);
+  bool ret =
+    (magic_number_ == SerializedData::kMagicNumber);
+  valid_ = ret;
 }
 
 template <typename IsolateT>
diff -r -u --color up/v8/src/snapshot/deserializer.h nw/v8/src/snapshot/deserializer.h
--- up/v8/src/snapshot/deserializer.h	2024-03-25 17:43:57.000000000 +0000
+++ nw/v8/src/snapshot/deserializer.h	2024-04-11 17:51:37.057697028 +0000
@@ -112,6 +112,8 @@
 
   Handle<HeapObject> ReadObject();
 
+  bool valid_ = true;
+
  private:
   // A circular queue of hot objects. This is added to in the same order as in
   // Serializer::HotObjectsList, but this stores the objects as a vector of
diff -r -u --color up/v8/src/snapshot/object-deserializer.cc nw/v8/src/snapshot/object-deserializer.cc
--- up/v8/src/snapshot/object-deserializer.cc	2024-03-25 17:43:57.000000000 +0000
+++ nw/v8/src/snapshot/object-deserializer.cc	2024-04-11 17:51:37.057697028 +0000
@@ -34,6 +34,8 @@
 
 MaybeHandle<HeapObject> ObjectDeserializer::Deserialize() {
   DCHECK(deserializing_user_code());
+  if (!valid_)
+    return MaybeHandle<HeapObject>();
   HandleScope scope(isolate());
   Handle<HeapObject> result;
   {
Only in nw/v8/src: v8.gyp
